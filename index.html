<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>Web SV Piano</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700&display=swap" media="print" onload="this.media='all'">
    <style>
        * { box-sizing: border-box; }
        body {
            margin: 0; padding: 0; min-height: 100vh; overflow-y: auto;
            font-family: 'M PLUS Rounded 1c', 'Noto Sans SC', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            display: flex; flex-direction: row;
            color: var(--daw-text-primary); user-select: none;
            background: var(--daw-bg-dark);
        }
        body::-webkit-scrollbar { width: 6px; }
        body::-webkit-scrollbar-track { background: transparent; }
        body::-webkit-scrollbar-thumb { background: rgba(255,255,255,0.15); border-radius: 4px; }
        body::-webkit-scrollbar-thumb:hover { background: rgba(255,255,255,0.25); }
        
        #bg-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: -1; }
        .bg-slide { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-size: cover; background-position: center; transition: opacity 1.5s ease-in-out; opacity: 0; }
        .bg-slide.active { opacity: 1; }
        .overlay { position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: var(--overlay-tint); }

        /* === DAW 布局结构 === */
        #app-container { display: flex; width: 100%; min-height: 100vh; position: relative; }

        /* 左侧边栏 */
        #sidebar {
            width: var(--sidebar-width); height: 100vh;
            background: var(--sidebar-bg); backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border-right: 1px solid var(--sidebar-border);
            display: flex; flex-direction: column;
            overflow: hidden; transition: width var(--transition-normal);
            position: sticky; top: 0; z-index: 100; flex-shrink: 0;
            align-self: flex-start;
            box-shadow: 4px 0 24px rgba(0, 0, 0, 0.15);
        }
        #sidebar.collapsed { width: var(--sidebar-collapsed-width); }
        #sidebar.collapsed #sidebar-header { justify-content: center; padding: var(--space-md) 0; }

        #sidebar-header {
            padding: var(--space-md) var(--space-lg);
            border-bottom: 1px solid var(--sidebar-border);
            display: flex; align-items: center; justify-content: space-between;
            flex-shrink: 0;
            background: var(--glass-bg-deeper);
        }
        #sidebar-title {
            font-weight: 700; font-size: var(--font-lg);
            color: var(--daw-accent);
            text-shadow: 0 1px 8px rgba(var(--daw-accent-rgb), 0.3);
            letter-spacing: 1.5px; white-space: nowrap; overflow: hidden;
            transition: opacity var(--transition-fast);
            margin: 0; width: auto; text-align: left;
        }
        #sidebar.collapsed #sidebar-title { opacity: 0; width: 0; }

        #sidebar-toggle {
            width: var(--toggle-btn-size, 32px); height: var(--toggle-btn-size, 32px); border: none;
            background: rgba(var(--daw-accent-rgb), 0.1); color: var(--daw-text-muted);
            border-radius: var(--radius-md); cursor: pointer;
            display: flex; align-items: center; justify-content: center;
            font-size: var(--font-lg); transition: all var(--transition-fast);
            flex-shrink: 0;
        }
        #sidebar-toggle:hover { background: rgba(var(--daw-accent-rgb), 0.2); color: var(--daw-text-primary); transform: scale(1.05); }

        #sidebar-content {
            flex: 1; overflow-y: auto; overflow-x: hidden;
            padding: var(--space-sm);
        }
        #sidebar-content::-webkit-scrollbar { width: 4px; }
        #sidebar-content::-webkit-scrollbar-track { background: transparent; }
        #sidebar-content::-webkit-scrollbar-thumb { background: var(--scrollbar-thumb); border-radius: 3px; }
        #sidebar-content::-webkit-scrollbar-thumb:hover { background: var(--scrollbar-thumb-hover); }

        /* 手风琴分组 */
        .sidebar-section {
            margin-bottom: var(--space-sm);
            background: var(--gradient-subtle);
            border-radius: var(--radius-lg);
            border: 1px solid var(--glass-border);
            overflow: hidden;
            transition: border-color var(--transition-fast);
        }
        .sidebar-section:hover { border-color: rgba(var(--daw-accent-rgb), 0.15); }
        .section-header {
            padding: var(--space-sm) var(--space-md);
            cursor: pointer; display: flex; align-items: center;
            justify-content: space-between; user-select: none;
            background: var(--glass-bg-deeper);
            transition: background var(--transition-fast);
        }
        .section-header:hover { background: rgba(var(--daw-accent-rgb), 0.08); }
        .section-title {
            font-size: var(--font-xs); font-weight: bold;
            color: var(--daw-text-secondary); text-transform: uppercase;
            letter-spacing: 1px; display: flex; align-items: center;
            gap: var(--space-sm);
        }
        .section-icon { font-size: var(--font-sm); }
        .section-chevron {
            font-size: var(--font-xs); transition: transform var(--transition-fast);
            color: var(--daw-text-muted);
        }
        .sidebar-section.collapsed .section-chevron { transform: rotate(-90deg); }
        .section-content {
            padding: var(--space-md);
            display: flex; flex-direction: column; gap: var(--space-sm);
            max-height: 600px; overflow: hidden;
            transition: max-height var(--transition-normal), padding var(--transition-normal), opacity var(--transition-fast);
        }
        .sidebar-section.collapsed .section-content {
            max-height: 0; padding-top: 0; padding-bottom: 0; opacity: 0;
        }

        /* 侧边栏折叠时隐藏内容 */
        #sidebar.collapsed #sidebar-content,
        #sidebar.collapsed #sidebar-footer { display: none; }
        #sidebar.collapsed .section-header { justify-content: center; padding: var(--space-sm); }

        #sidebar-footer {
            padding: var(--space-sm) var(--space-md);
            border-top: 1px solid var(--sidebar-border);
            background: var(--glass-bg-deeper); flex-shrink: 0;
        }

        /* 主内容区域 */
        #main-content {
            flex: 1;
            display: flex; flex-direction: column; align-items: center;
            padding: var(--space-lg) var(--space-xl);
            gap: var(--space-md);
            overflow-x: hidden;
        }

        /* 工具类 */
        .hidden { display: none; }
        .label-small { font-size: var(--font-xs); color: #ccc; }
        .label-hint { font-size: var(--font-xs); color: #999; }
        .flex-row { display: flex; align-items: center; gap: var(--space-sm); }
        .flex-col { display: flex; flex-direction: column; gap: var(--space-sm); }
        
        h1 { font-weight: 700; font-size: var(--font-xl); margin: 0 0 var(--space-md) 0; color: var(--daw-text-primary); text-shadow: 0 2px 12px rgba(var(--daw-accent-rgb), 0.2); letter-spacing: 1.5px; text-align: center; width: 100%; }
        
        #startOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0, 0, 0, 0.8); backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px); display: flex; flex-direction: column; justify-content: center; align-items: center; z-index: 9999; }
        #startBtn { padding: var(--space-lg) 52px; font-size: var(--font-lg); background: var(--start-btn-gradient); color: #fff; border: none; border-radius: 50px; cursor: pointer; font-weight: bold; box-shadow: var(--start-btn-shadow); transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); letter-spacing: 1px; }
        #startBtn:hover { transform: scale(1.05); filter: brightness(1.1); }
        #loadingText { margin-top: 20px; color: var(--daw-accent-secondary); font-size: var(--font-md); font-weight: bold; display: none; }
        #loadingBar { width: 300px; height: 4px; background: rgba(255,255,255,0.12); border-radius: 3px; margin-top: 15px; overflow: hidden; display: none; }
        #loadingFill { height: 100%; background: var(--loading-gradient); width: 0%; transition: width 0.3s; border-radius: 3px; }

        .piano-container {
            background: transparent;
            padding: 0;
            border: none;
            position: relative; width: 100%;
        }
        .piano { display: flex; position: relative; width: 100%; }
        .piano.two-rows { display: none; }
        .piano-row {
            display: flex; position: relative; width: 100%;
        }
        .piano-rows-wrapper { display: none; flex-direction: column; gap: 6px; align-items: stretch; }
        .piano-rows-wrapper.active { display: flex; }
        
        .key { 
            cursor: pointer; display: flex; align-items: flex-end; justify-content: center; 
            padding-bottom: 8px; user-select: none; border-radius: 0 0 6px 6px; 
            font-size: 11px; font-weight: bold; transition: background 0.06s, transform 0.06s; 
            position: relative;
        }
        
        .key-label { 
            position: absolute; bottom: 24px; font-size: 8px; opacity: 0.5; 
            pointer-events: none; text-transform: uppercase; font-family: monospace;
            max-width: 30px; overflow: hidden; text-overflow: clip;
        }
        .black-key .key-label { color: #aaa; bottom: 10px; max-width: 20px; }
        .white-key .key-label { color: #666; }

        .white-key { flex: 1; min-width: 0; background: linear-gradient(180deg, #fff 0%, #e8e8e8 100%); color: #444; border: 1px solid #bbb; z-index: 1; box-shadow: 0 4px 8px rgba(0,0,0,0.15); }
        .black-key { background: linear-gradient(180deg, #333 0%, #000 100%); color: white; z-index: 2; position: absolute; border: 1px solid #000; box-shadow: 2px 2px 4px rgba(0,0,0,0.4); }
        
        .white-key.active { background: var(--key-active-white); transform: translateY(2px); box-shadow: var(--key-active-white-glow); }
        .black-key.active { background: linear-gradient(180deg, #444 0%, #222 100%); transform: translateY(2px); box-shadow: var(--key-active-black-glow); }

        #playerSection {
            width: 100%;
            background: rgba(0, 0, 0, 0.25);
            backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
            padding: var(--space-md) var(--space-lg);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: var(--radius-lg);
        }
        
        #playerHeader { display: flex; justify-content: space-between; align-items: center; margin-bottom: var(--space-sm); }
        #playerTitle { font-size: var(--font-sm); font-weight: bold; color: var(--daw-text-secondary); }
        #timeDisplay { font-size: var(--font-xs); color: var(--daw-text-muted); font-family: monospace; }
        
        #progressWrapper {
            position: relative; width: 100%; height: 6px;
            background: rgba(var(--daw-accent-rgb), 0.12); border-radius: 4px;
            cursor: pointer; overflow: visible;
        }
        #progressFill { height: 100%; background: var(--gradient-main); border-radius: 4px; width: 0%; pointer-events: none; }
        #progressHandle {
            position: absolute; top: 50%; transform: translate(-50%, -50%);
            width: 16px; height: 16px; background: white; border-radius: 50%;
            box-shadow: 0 0 8px rgba(0,0,0,0.5); cursor: grab; left: 0%;
            display: none;
        }
        #progressHandle.visible { display: block; }
        
        #playerControls { display: flex; gap: var(--space-sm); margin-top: var(--space-md); align-items: center; justify-content: center; flex-wrap: wrap; }
        
        #midiInfoPanel {
            display: none; margin-top: var(--space-md); padding: var(--space-md);
            background: var(--glass-bg-deeper); border-radius: var(--radius-md);
            border: 1px solid var(--glass-border);
        }
        #midiInfoPanel.visible { display: block; }
        #midiInfoPanel h3 { margin: 0 0 var(--space-sm) 0; font-size: var(--font-xs); color: var(--info-highlight); font-weight: bold; }
        .midi-info-grid { display: grid; grid-template-columns: repeat(5, 1fr); gap: var(--space-sm); }
        .midi-info-item { text-align: center; }
        .midi-info-value { font-size: var(--font-md); font-weight: bold; color: var(--daw-accent-secondary); }
        .midi-info-label { font-size: var(--font-xs); color: var(--daw-text-muted); margin-top: 2px; }
        .midi-info-value.ready { color: #2ed573; }
        .midi-info-value.rendering { color: #ffa502; }

        /* === 侧边栏控制项样式 === */
        .control-group { display: flex; flex-direction: column; gap: var(--space-xs); }
        .panel-label { font-size: var(--font-xs); color: var(--daw-text-secondary); font-weight: bold; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 2px; }

        select, button, input[type="number"] {
            padding: var(--space-sm) var(--space-md); border-radius: var(--radius-md); border: none;
            font-family: 'M PLUS Rounded 1c', 'Noto Sans SC', 'PingFang SC', 'Microsoft YaHei', sans-serif;
            font-weight: bold; cursor: pointer; transition: all var(--transition-fast);
            font-size: var(--font-xs);
        }
        select, input[type="number"] {
            background: rgba(var(--daw-accent-rgb), 0.08); color: var(--daw-text-primary);
            border: 1px solid rgba(var(--daw-accent-rgb), 0.15);
        }
        #sidebar select, #sidebar input[type="number"] { width: 100%; }
        select:hover, input[type="number"]:hover {
            background: rgba(var(--daw-accent-rgb), 0.14);
            border-color: rgba(var(--daw-accent-rgb), 0.25);
        }
        select:focus, input[type="number"]:focus {
            outline: none; border-color: var(--daw-accent);
            box-shadow: 0 0 0 2px var(--focus-ring);
        }
        input[type="number"] { text-align: center; }
        option { background: #2a2028; color: var(--daw-text-primary); }

        .btn {
            padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-md);
            font-size: var(--font-xs); font-weight: bold;
            cursor: pointer; border: none;
            transition: all var(--transition-fast);
            text-align: center;
        }
        #sidebar .btn { width: 100%; }
        .btn:hover { transform: translateY(-1px); box-shadow: var(--glow-soft); }
        .btn:active { transform: translateY(0); }
        .btn:disabled { opacity: 0.35; cursor: not-allowed; transform: none !important; }

        .btn-record { background: var(--btn-record); color: white; }
        .btn-record.recording { background: var(--btn-record-active); animation: pulse 1.5s ease-in-out infinite; }
        @keyframes pulse { 0%, 100% { box-shadow: 0 0 4px rgba(var(--daw-accent-rgb), 0.2); } 50% { box-shadow: 0 0 12px rgba(var(--daw-accent-rgb), 0.4); } }

        .btn-play { background: var(--btn-play); color: white; }
        .btn-play.playing { background: var(--btn-play-active); }
        .btn-pause { background: var(--btn-pause); color: white; }
        .btn-stop { background: var(--btn-stop); color: white; }
        .btn-download { background: var(--btn-download); color: white; }
        .btn-upload { background: var(--btn-upload); color: white; position: relative; overflow: hidden; }
        .btn-upload input[type="file"] { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; cursor: pointer; }
        .btn-export { background: var(--btn-export); color: white; }
        .btn-loop { background: rgba(var(--daw-accent-secondary-rgb), 0.08); color: var(--daw-text-muted); }
        .btn-loop.active { background: var(--btn-loop-active-bg); color: var(--btn-loop-active-color); border: 1px solid var(--btn-loop-active-border); }
        .btn-reset { background: rgba(var(--daw-accent-rgb), 0.15); color: var(--daw-text-secondary); }

        #bindOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); border-radius: 20px;
            display: none; flex-direction: column; justify-content: center; align-items: center;
            z-index: 100; text-align: center;
        }
        #bindOverlay.active { display: flex; }
        .bind-msg { font-size: var(--font-sm); color: var(--daw-accent-secondary); margin-bottom: 8px; }
        .bind-note { font-size: var(--font-xl); font-weight: bold; color: var(--daw-text-primary); margin-bottom: 12px; }
        .cancel-bind { font-size: var(--font-xs); color: var(--daw-text-muted); cursor: pointer; text-decoration: underline; }

        .slider-panel {
            display: flex; flex-direction: column; gap: var(--space-md);
            background: rgba(var(--daw-accent-rgb), 0.04);
            padding: var(--space-md); border-radius: var(--radius-md);
        }
        .slider-group {
            display: flex; align-items: center;
            justify-content: space-between; gap: var(--space-sm);
        }
        .slider-group span { font-size: var(--font-xs); color: var(--daw-text-muted); min-width: 40px; }
        input[type=range] { -webkit-appearance: none; background: transparent; flex: 1; }
        input[type=range]::-webkit-slider-runnable-track { height: 3px; background: rgba(var(--daw-accent-secondary-rgb), 0.2); border-radius: 2px; }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none; height: 14px; width: 14px; border-radius: 50%;
            background: var(--daw-accent-secondary); margin-top: -5px; cursor: pointer;
            transition: all var(--transition-fast);
        }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.15); box-shadow: 0 0 6px rgba(var(--daw-accent-secondary-rgb), 0.4); }
        .value-display { font-size: var(--font-xs); color: var(--daw-accent-secondary); font-family: monospace; min-width: 45px; text-align: right; }

        #metronome-display {
            display: flex; align-items: center; gap: var(--space-sm);
            background: var(--glass-bg-deeper); padding: var(--space-sm) var(--space-md);
            border-radius: var(--radius-lg);
        }
        #beat-indicator { width: 8px; height: 8px; border-radius: 50%; background: rgba(var(--daw-accent-rgb), 0.2); transition: all 0.1s; }
        #beat-indicator.on { background: var(--daw-accent); box-shadow: 0 0 6px rgba(var(--daw-accent-rgb), 0.5); }

        #status { font-size: var(--font-xs); text-shadow: 0 1px 3px rgba(0,0,0,0.8); text-align: center; margin: 0; }
        #midiStatus { font-size: var(--font-xs); color: var(--daw-text-muted); padding: var(--space-xs) var(--space-sm); background: rgba(var(--daw-accent-rgb), 0.06); border-radius: var(--radius-sm); text-align: center; }
        #octave-display {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: var(--space-sm) var(--space-lg);
            font-size: var(--font-md);
            font-weight: 700;
            font-family: 'M PLUS Rounded 1c', sans-serif;
            color: var(--daw-accent);
            background: linear-gradient(135deg, rgba(var(--daw-accent-rgb), 0.08), rgba(var(--daw-accent-rgb), 0.15));
            border: 2px solid rgba(var(--daw-accent-rgb), 0.3);
            border-radius: 12px;
            letter-spacing: 1px;
            text-shadow: 0 1px 3px rgba(0, 0, 0, 0.2);
            box-shadow: 0 2px 8px rgba(var(--daw-accent-rgb), 0.15);
            transition: all 0.3s ease;
        }
        #octave-display:hover {
            border-color: rgba(var(--daw-accent-rgb), 0.5);
            box-shadow: 0 4px 12px rgba(var(--daw-accent-rgb), 0.25);
            transform: translateY(-1px);
        }

        /* === 音符瀑布可视化器（横向钢琴卷帘） === */
        #visualizerSection {
            width: 100%;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: var(--radius-lg);
            overflow: hidden;
        }
        #visualizerHeader {
            display: flex; justify-content: space-between; align-items: center;
            padding: var(--space-sm) var(--space-md); border-bottom: 1px solid var(--glass-border);
            background: rgba(var(--daw-accent-rgb), 0.04);
        }
        #visualizerTitle { font-size: var(--font-xs); font-weight: bold; color: var(--daw-text-secondary); }
        #visualizerWrapper {
            display: flex; flex-direction: row;
            height: 900px; position: relative;
            transition: height 0.3s ease;
            overflow: hidden;
        }
        #visualizerWrapper.collapsed { height: 0; }

        /* 左侧垂直钢琴 */
        #miniPiano {
            width: 80px; flex-shrink: 0;
            background: #1a1a1a;
            border-right: 1px solid rgba(var(--daw-accent-rgb), 0.12);
            position: relative;
            overflow: hidden;
        }
        .mini-key {
            position: absolute; left: 0; right: 0;
            display: flex; align-items: center; justify-content: flex-end;
            padding-right: 6px; font-size: var(--font-xs);
            font-family: 'Consolas', 'Monaco', monospace;
            box-sizing: border-box;
            transition: filter 0.06s;
        }
        .mini-key.white {
            background: linear-gradient(90deg, #d0cec8 0%, #e8e6e0 15%, #f5f3ed 50%, #faf8f4 85%, #eceae4 100%);
            border-bottom: 1px solid #c0bdb5;
            border-top: 1px solid rgba(255,255,255,0.6);
            box-shadow: inset 0 0 1px rgba(0,0,0,0.05);
            color: #999;
            letter-spacing: 0.5px;
        }
        .mini-key.black {
            width: 58%;
            background: linear-gradient(90deg, #0a0a0a 0%, #1e1e1e 20%, #2a2a2a 50%, #222 80%, #181818 100%);
            border-bottom: 1px solid #000;
            border-top: 1px solid rgba(255,255,255,0.04);
            box-shadow: 2px 0 4px rgba(0,0,0,0.5), inset 0 1px 0 rgba(255,255,255,0.06);
            color: #777;
            z-index: 1;
            border-radius: 0 2px 2px 0;
        }
        .mini-key.active {
            background: var(--mini-key-active) !important;
            box-shadow: inset 0 0 6px rgba(var(--daw-accent-rgb), 0.5), 0 0 4px rgba(var(--daw-accent-rgb), 0.3) !important;
        }

        /* 右侧音符画布 */
        #canvasWrapper {
            flex: 1; position: relative; overflow: hidden;
        }
        #fallingNotesCanvas {
            width: 100%; height: 100%;
            display: block;
        }
        #fallingNotesCanvas.edit-mode { cursor: crosshair; }
        #fallingNotesCanvas.edit-mode.dragging { cursor: grabbing; }
        #fallingNotesCanvas.edit-mode.resize-right { cursor: ew-resize; }

        /* 钢琴卷帘工具栏 */
        #pianoRollToolbar {
            display: flex; align-items: center; gap: 6px;
            padding: 5px 12px; background: var(--glass-bg-deeper);
            border-bottom: 1px solid var(--glass-border);
            flex-wrap: wrap;
        }
        .pr-tool-group { display: flex; gap: 3px; align-items: center; }
        .pr-tool-group::after { content: ''; width: 1px; height: 16px; background: rgba(var(--daw-accent-rgb), 0.12); margin: 0 4px; }
        .pr-tool-group:last-child::after { display: none; }
        .pr-tool-btn {
            padding: 3px 8px; font-size: var(--font-xs); font-weight: bold;
            border: 1px solid rgba(255,255,255,0.15); border-radius: 4px;
            background: rgba(255,255,255,0.08); color: #ccc;
            cursor: pointer; transition: all 0.15s;
        }
        .pr-tool-btn:hover { background: rgba(255,255,255,0.15); color: white; }
        .pr-tool-btn.active { background: rgba(var(--daw-accent-rgb), 0.2); border-color: var(--daw-accent); color: var(--daw-accent); }
        .pr-tool-label { font-size: var(--font-xs); color: #888; margin-right: 2px; }
        .pr-zoom-btn { width: 22px; text-align: center; }
        .btn-toggle {
            background: rgba(255,255,255,0.1); color: #aaa;
            padding: 4px 10px; font-size: var(--font-xs); border: none;
            border-radius: 4px; cursor: pointer;
        }
        .btn-toggle:hover { background: rgba(255,255,255,0.2); color: white; }

        /* === 轨道控制面板 === */
        #trackControlsPanel {
            display: none; margin-top: var(--space-md); padding: var(--space-sm) var(--space-md);
            background: var(--glass-bg-deeper); border-radius: var(--radius-md);
            border: 1px solid var(--glass-border);
        }
        #trackControlsPanel.visible { display: block; }
        #trackControlsHeader {
            display: flex; justify-content: space-between; align-items: center;
            margin-bottom: var(--space-sm);
        }
        #trackControlsHeader span { font-size: var(--font-xs); color: var(--info-highlight); font-weight: bold; }
        #trackList {
            max-height: 240px; overflow-y: auto;
            transition: max-height 0.3s ease;
        }
        #trackList.collapsed { max-height: 0; overflow: hidden; }
        .track-item {
            display: flex; align-items: center; gap: var(--space-sm);
            padding: var(--space-sm); margin: 4px 0;
            background: rgba(var(--daw-accent-rgb), 0.04); border-radius: var(--radius-sm);
            flex-wrap: wrap;
        }
        .track-color { width: var(--font-sm); height: var(--font-sm); border-radius: 3px; flex-shrink: 0; }
        .track-name {
            flex: 1; font-size: var(--font-xs); color: var(--daw-text-primary);
            white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
            max-width: 160px;
        }
        .track-preset-row {
            width: 100%; display: flex; align-items: center; gap: var(--space-xs);
            padding-left: var(--space-lg);
        }
        .track-preset-row select {
            flex: 1; font-size: var(--font-xs); padding: 2px 4px;
        }
        .track-instrument {
            font-size: var(--font-xs); padding: 2px var(--space-xs); border-radius: 4px;
            background: rgba(var(--daw-accent-rgb), 0.1); color: var(--daw-text-primary); border: none;
        }
        .btn-mute, .btn-solo {
            width: var(--font-xl); height: var(--font-xl); font-size: var(--font-xs); font-weight: bold;
            border: none; border-radius: 4px; cursor: pointer;
            display: flex; align-items: center; justify-content: center;
        }
        .btn-mute { background: #555; color: #aaa; }
        .btn-mute.active { background: #ff4757; color: white; }
        .btn-solo { background: #555; color: #aaa; }
        .btn-solo.active { background: #ffa502; color: white; }
        .track-volume { width: 60px; height: 4px; }

        /* ========== 设计系统变量 ========== */
        :root {
            /* 间距阶梯 */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 12px;
            --space-lg: 16px;
            --space-xl: 24px;

            /* 字号阶梯 */
            --font-xs: 11px;
            --font-sm: 13px;
            --font-md: 15px;
            --font-lg: 18px;
            --font-xl: 24px;

            /* 圆角阶梯 */
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 14px;

            /* 侧边栏 */
            --sidebar-width: 280px;
            --sidebar-collapsed-width: 48px;

            /* 过渡动画 */
            --transition-fast: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            --transition-normal: 0.35s cubic-bezier(0.4, 0, 0.2, 1);

            /* 钢琴卷帘编辑器 */
            --pr-bg-darkest: #141419;
            --pr-bg-dark: #1b1b22;
            --pr-bg-medium: #23232e;
            --pr-bg-light: #2e2e3a;
            --pr-border: #2a2a36;
            --pr-border-light: #3a3a48;
            --pr-text-primary: #e0e0e0;
            --pr-text-secondary: #999999;
            --pr-text-muted: #666666;
            --pr-accent: #5ec4b6;
            --pr-accent-hover: #7dd4c8;
            --pr-accent-dim: rgba(94, 196, 182, 0.3);
            --pr-playhead: #ff6b6b;
            --pr-velocity-bar: #5ec4b6;
            --pr-key-white: #d0d0d0;
            --pr-key-black: #1e1e28;
        }

        /* ========== 主题：樱花淡雅 ========== */
        [data-theme="sakura"], :root {
            --daw-bg-dark: #1e1520;
            --daw-accent: #d4a0b8;
            --daw-accent-rgb: 212, 160, 184;
            --daw-accent-secondary: #b8a0d0;
            --daw-accent-secondary-rgb: 184, 160, 208;
            --daw-text-primary: #f5eef5;
            --daw-text-secondary: #e0c0d4;
            --daw-text-muted: #a898a0;
            --sidebar-bg: rgba(35, 18, 30, 0.65);
            --sidebar-border: rgba(212, 160, 184, 0.1);
            --overlay-tint: linear-gradient(135deg, rgba(40, 15, 35, 0.45) 0%, rgba(25, 15, 40, 0.5) 100%);
            --glass-bg: rgba(35, 18, 30, 0.45);
            --glass-bg-deeper: rgba(25, 10, 22, 0.55);
            --glass-border: rgba(212, 160, 184, 0.1);
            --glass-blur: 22px;
            --gradient-main: linear-gradient(135deg, #d4a0b8, #b8a0d0);
            --gradient-subtle: linear-gradient(135deg, rgba(212, 160, 184, 0.15), rgba(184, 160, 208, 0.1));
            --glow-soft: 0 0 20px rgba(212, 160, 184, 0.15);
            --glow-accent: 0 0 12px rgba(212, 160, 184, 0.3);
            --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.2), 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-elevated: 0 12px 40px rgba(0, 0, 0, 0.3);
            --btn-play: #8ec4a0;
            --btn-play-active: #c8a868;
            --btn-pause: #c8a868;
            --btn-stop: #c88898;
            --btn-record: #c88898;
            --btn-record-active: #d06878;
            --btn-download: #90aed0;
            --btn-upload: #b0a0c8;
            --btn-export: #80b8a0;
            --btn-loop-active-bg: rgba(184, 160, 208, 0.2);
            --btn-loop-active-color: #b8a0d0;
            --btn-loop-active-border: rgba(184, 160, 208, 0.35);
            --key-active-white: linear-gradient(180deg, #f5e0ec 0%, #ecc8dc 100%);
            --key-active-white-glow: 0 0 10px rgba(212, 160, 184, 0.4);
            --key-active-black-glow: 0 0 10px rgba(184, 160, 208, 0.4);
            --mini-key-active: linear-gradient(90deg, #d4a0b8 0%, #e0c0d0 100%);
            --scrollbar-thumb: rgba(212, 160, 184, 0.15);
            --scrollbar-thumb-hover: rgba(212, 160, 184, 0.25);
            --focus-ring: rgba(212, 160, 184, 0.25);
            --start-btn-gradient: linear-gradient(135deg, #d4a0b8 0%, #c8a0d0 50%, #b8a0d0 100%);
            --start-btn-shadow: 0 8px 30px rgba(212, 160, 184, 0.35);
            --loading-gradient: linear-gradient(90deg, #d4a0b8, #b8a0d0);
            --info-highlight: #d0b888;
        }

        /* ========== 主题：薄荷清新 ========== */
        [data-theme="mint"] {
            --daw-bg-dark: #131e1c;
            --daw-accent: #7ec0a8;
            --daw-accent-rgb: 126, 192, 168;
            --daw-accent-secondary: #88b0d0;
            --daw-accent-secondary-rgb: 136, 176, 208;
            --daw-text-primary: #eef5f3;
            --daw-text-secondary: #b0d4c8;
            --daw-text-muted: #88a098;
            --sidebar-bg: rgba(15, 30, 28, 0.65);
            --sidebar-border: rgba(126, 192, 168, 0.1);
            --overlay-tint: linear-gradient(135deg, rgba(12, 28, 25, 0.45) 0%, rgba(15, 22, 32, 0.5) 100%);
            --glass-bg: rgba(15, 30, 28, 0.45);
            --glass-bg-deeper: rgba(10, 22, 20, 0.55);
            --glass-border: rgba(126, 192, 168, 0.1);
            --glass-blur: 22px;
            --gradient-main: linear-gradient(135deg, #7ec0a8, #88b0d0);
            --gradient-subtle: linear-gradient(135deg, rgba(126, 192, 168, 0.15), rgba(136, 176, 208, 0.1));
            --glow-soft: 0 0 20px rgba(126, 192, 168, 0.12);
            --glow-accent: 0 0 12px rgba(126, 192, 168, 0.25);
            --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.2), 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-elevated: 0 12px 40px rgba(0, 0, 0, 0.3);
            --btn-play: #7ec0a0;
            --btn-play-active: #b0b878;
            --btn-pause: #b0b878;
            --btn-stop: #c08888;
            --btn-record: #c08888;
            --btn-record-active: #c87070;
            --btn-download: #88b0d0;
            --btn-upload: #a098c0;
            --btn-export: #70b898;
            --btn-loop-active-bg: rgba(136, 176, 208, 0.2);
            --btn-loop-active-color: #88b0d0;
            --btn-loop-active-border: rgba(136, 176, 208, 0.35);
            --key-active-white: linear-gradient(180deg, #ddf0e8 0%, #c0e0d0 100%);
            --key-active-white-glow: 0 0 10px rgba(126, 192, 168, 0.35);
            --key-active-black-glow: 0 0 10px rgba(136, 176, 208, 0.35);
            --mini-key-active: linear-gradient(90deg, #7ec0a8 0%, #a0d8c0 100%);
            --scrollbar-thumb: rgba(126, 192, 168, 0.15);
            --scrollbar-thumb-hover: rgba(126, 192, 168, 0.25);
            --focus-ring: rgba(126, 192, 168, 0.25);
            --start-btn-gradient: linear-gradient(135deg, #7ec0a8 0%, #88b8c0 50%, #88b0d0 100%);
            --start-btn-shadow: 0 8px 30px rgba(126, 192, 168, 0.3);
            --loading-gradient: linear-gradient(90deg, #7ec0a8, #88b0d0);
            --info-highlight: #b8c888;
        }

        /* ========== 主题：黄昏浪漫 ========== */
        [data-theme="twilight"] {
            --daw-bg-dark: #1e1515;
            --daw-accent: #d0a088;
            --daw-accent-rgb: 208, 160, 136;
            --daw-accent-secondary: #b090c0;
            --daw-accent-secondary-rgb: 176, 144, 192;
            --daw-text-primary: #f8f0e8;
            --daw-text-secondary: #dcc0b0;
            --daw-text-muted: #a89890;
            --sidebar-bg: rgba(32, 18, 18, 0.65);
            --sidebar-border: rgba(208, 160, 136, 0.1);
            --overlay-tint: linear-gradient(135deg, rgba(30, 15, 15, 0.45) 0%, rgba(25, 15, 28, 0.5) 100%);
            --glass-bg: rgba(32, 18, 18, 0.45);
            --glass-bg-deeper: rgba(22, 12, 12, 0.55);
            --glass-border: rgba(208, 160, 136, 0.1);
            --glass-blur: 22px;
            --gradient-main: linear-gradient(135deg, #d0a088, #b090c0);
            --gradient-subtle: linear-gradient(135deg, rgba(208, 160, 136, 0.15), rgba(176, 144, 192, 0.1));
            --glow-soft: 0 0 20px rgba(208, 160, 136, 0.12);
            --glow-accent: 0 0 12px rgba(208, 160, 136, 0.25);
            --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.2), 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-elevated: 0 12px 40px rgba(0, 0, 0, 0.3);
            --btn-play: #90b898;
            --btn-play-active: #c8b078;
            --btn-pause: #c8b078;
            --btn-stop: #c88888;
            --btn-record: #c88888;
            --btn-record-active: #c87068;
            --btn-download: #90a8c8;
            --btn-upload: #b098b8;
            --btn-export: #80b8a0;
            --btn-loop-active-bg: rgba(176, 144, 192, 0.2);
            --btn-loop-active-color: #b090c0;
            --btn-loop-active-border: rgba(176, 144, 192, 0.35);
            --key-active-white: linear-gradient(180deg, #f0e0d8 0%, #e0c8b8 100%);
            --key-active-white-glow: 0 0 10px rgba(208, 160, 136, 0.35);
            --key-active-black-glow: 0 0 10px rgba(176, 144, 192, 0.35);
            --mini-key-active: linear-gradient(90deg, #d0a088 0%, #e0c0a8 100%);
            --scrollbar-thumb: rgba(208, 160, 136, 0.15);
            --scrollbar-thumb-hover: rgba(208, 160, 136, 0.25);
            --focus-ring: rgba(208, 160, 136, 0.25);
            --start-btn-gradient: linear-gradient(135deg, #d0a088 0%, #c098b0 50%, #b090c0 100%);
            --start-btn-shadow: 0 8px 30px rgba(208, 160, 136, 0.3);
            --loading-gradient: linear-gradient(90deg, #d0a088, #b090c0);
            --info-highlight: #c8b888;
        }

        /* ========== 主题：海洋深蓝 ========== */
        [data-theme="ocean"] {
            --daw-bg-dark: #0e1520;
            --daw-accent: #5ca0d8;
            --daw-accent-rgb: 92, 160, 216;
            --daw-accent-secondary: #68c8e0;
            --daw-accent-secondary-rgb: 104, 200, 224;
            --daw-text-primary: #e8f0f8;
            --daw-text-secondary: #a0c8e0;
            --daw-text-muted: #708898;
            --sidebar-bg: rgba(10, 18, 30, 0.65);
            --sidebar-border: rgba(92, 160, 216, 0.1);
            --overlay-tint: linear-gradient(135deg, rgba(8, 15, 28, 0.45) 0%, rgba(10, 20, 35, 0.5) 100%);
            --glass-bg: rgba(10, 18, 30, 0.45);
            --glass-bg-deeper: rgba(6, 12, 22, 0.55);
            --glass-border: rgba(92, 160, 216, 0.1);
            --glass-blur: 22px;
            --gradient-main: linear-gradient(135deg, #5ca0d8, #68c8e0);
            --gradient-subtle: linear-gradient(135deg, rgba(92, 160, 216, 0.15), rgba(104, 200, 224, 0.1));
            --glow-soft: 0 0 20px rgba(92, 160, 216, 0.12);
            --glow-accent: 0 0 12px rgba(92, 160, 216, 0.25);
            --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.2), 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-elevated: 0 12px 40px rgba(0, 0, 0, 0.3);
            --btn-play: #68c0a0;
            --btn-play-active: #a0c080;
            --btn-pause: #c8b878;
            --btn-stop: #c88888;
            --btn-record: #c88888;
            --btn-record-active: #d07070;
            --btn-download: #5ca0d8;
            --btn-upload: #8898c8;
            --btn-export: #68b8a0;
            --btn-loop-active-bg: rgba(104, 200, 224, 0.2);
            --btn-loop-active-color: #68c8e0;
            --btn-loop-active-border: rgba(104, 200, 224, 0.35);
            --key-active-white: linear-gradient(180deg, #d8e8f8 0%, #b0d0e8 100%);
            --key-active-white-glow: 0 0 10px rgba(92, 160, 216, 0.4);
            --key-active-black-glow: 0 0 10px rgba(104, 200, 224, 0.4);
            --mini-key-active: linear-gradient(90deg, #5ca0d8 0%, #80c0e8 100%);
            --scrollbar-thumb: rgba(92, 160, 216, 0.15);
            --scrollbar-thumb-hover: rgba(92, 160, 216, 0.25);
            --focus-ring: rgba(92, 160, 216, 0.25);
            --start-btn-gradient: linear-gradient(135deg, #5ca0d8 0%, #60b8d8 50%, #68c8e0 100%);
            --start-btn-shadow: 0 8px 30px rgba(92, 160, 216, 0.35);
            --loading-gradient: linear-gradient(90deg, #5ca0d8, #68c8e0);
            --info-highlight: #88c8d0;
        }

        /* ========== 主题：赛博霓虹 ========== */
        [data-theme="cyber"] {
            --daw-bg-dark: #0c0c18;
            --daw-accent: #e060d0;
            --daw-accent-rgb: 224, 96, 208;
            --daw-accent-secondary: #60d0f0;
            --daw-accent-secondary-rgb: 96, 208, 240;
            --daw-text-primary: #f0e8f8;
            --daw-text-secondary: #d0a8e0;
            --daw-text-muted: #8878a0;
            --sidebar-bg: rgba(12, 8, 22, 0.7);
            --sidebar-border: rgba(224, 96, 208, 0.12);
            --overlay-tint: linear-gradient(135deg, rgba(10, 5, 20, 0.5) 0%, rgba(5, 10, 25, 0.5) 100%);
            --glass-bg: rgba(15, 8, 25, 0.5);
            --glass-bg-deeper: rgba(8, 4, 18, 0.6);
            --glass-border: rgba(224, 96, 208, 0.1);
            --glass-blur: 22px;
            --gradient-main: linear-gradient(135deg, #e060d0, #60d0f0);
            --gradient-subtle: linear-gradient(135deg, rgba(224, 96, 208, 0.15), rgba(96, 208, 240, 0.1));
            --glow-soft: 0 0 20px rgba(224, 96, 208, 0.15);
            --glow-accent: 0 0 12px rgba(224, 96, 208, 0.3);
            --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.25), 0 2px 8px rgba(0, 0, 0, 0.15);
            --shadow-elevated: 0 12px 40px rgba(0, 0, 0, 0.35);
            --btn-play: #60d0a0;
            --btn-play-active: #d0c060;
            --btn-pause: #d0c060;
            --btn-stop: #e06080;
            --btn-record: #e06080;
            --btn-record-active: #f04060;
            --btn-download: #60a0e0;
            --btn-upload: #b080d0;
            --btn-export: #60c8a0;
            --btn-loop-active-bg: rgba(96, 208, 240, 0.2);
            --btn-loop-active-color: #60d0f0;
            --btn-loop-active-border: rgba(96, 208, 240, 0.35);
            --key-active-white: linear-gradient(180deg, #f0d8f0 0%, #e0b0e0 100%);
            --key-active-white-glow: 0 0 12px rgba(224, 96, 208, 0.5);
            --key-active-black-glow: 0 0 12px rgba(96, 208, 240, 0.5);
            --mini-key-active: linear-gradient(90deg, #e060d0 0%, #f090e0 100%);
            --scrollbar-thumb: rgba(224, 96, 208, 0.15);
            --scrollbar-thumb-hover: rgba(224, 96, 208, 0.3);
            --focus-ring: rgba(224, 96, 208, 0.25);
            --start-btn-gradient: linear-gradient(135deg, #e060d0 0%, #a060e0 50%, #60d0f0 100%);
            --start-btn-shadow: 0 8px 30px rgba(224, 96, 208, 0.4);
            --loading-gradient: linear-gradient(90deg, #e060d0, #60d0f0);
            --info-highlight: #60d0f0;
        }

        /* ========== 主题：森林暗绿 ========== */
        [data-theme="forest"] {
            --daw-bg-dark: #101a12;
            --daw-accent: #6ab878;
            --daw-accent-rgb: 106, 184, 120;
            --daw-accent-secondary: #a0b868;
            --daw-accent-secondary-rgb: 160, 184, 104;
            --daw-text-primary: #e8f0e8;
            --daw-text-secondary: #b0d0b0;
            --daw-text-muted: #789078;
            --sidebar-bg: rgba(12, 22, 14, 0.65);
            --sidebar-border: rgba(106, 184, 120, 0.1);
            --overlay-tint: linear-gradient(135deg, rgba(10, 20, 12, 0.45) 0%, rgba(15, 22, 12, 0.5) 100%);
            --glass-bg: rgba(12, 22, 14, 0.45);
            --glass-bg-deeper: rgba(8, 16, 10, 0.55);
            --glass-border: rgba(106, 184, 120, 0.1);
            --glass-blur: 22px;
            --gradient-main: linear-gradient(135deg, #6ab878, #a0b868);
            --gradient-subtle: linear-gradient(135deg, rgba(106, 184, 120, 0.15), rgba(160, 184, 104, 0.1));
            --glow-soft: 0 0 20px rgba(106, 184, 120, 0.12);
            --glow-accent: 0 0 12px rgba(106, 184, 120, 0.25);
            --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.2), 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-elevated: 0 12px 40px rgba(0, 0, 0, 0.3);
            --btn-play: #6ab878;
            --btn-play-active: #b8b868;
            --btn-pause: #b8b868;
            --btn-stop: #c08878;
            --btn-record: #c08878;
            --btn-record-active: #c87060;
            --btn-download: #78a0c0;
            --btn-upload: #98a878;
            --btn-export: #60b888;
            --btn-loop-active-bg: rgba(160, 184, 104, 0.2);
            --btn-loop-active-color: #a0b868;
            --btn-loop-active-border: rgba(160, 184, 104, 0.35);
            --key-active-white: linear-gradient(180deg, #d8f0d8 0%, #b8d8b8 100%);
            --key-active-white-glow: 0 0 10px rgba(106, 184, 120, 0.4);
            --key-active-black-glow: 0 0 10px rgba(160, 184, 104, 0.4);
            --mini-key-active: linear-gradient(90deg, #6ab878 0%, #90d098 100%);
            --scrollbar-thumb: rgba(106, 184, 120, 0.15);
            --scrollbar-thumb-hover: rgba(106, 184, 120, 0.25);
            --focus-ring: rgba(106, 184, 120, 0.25);
            --start-btn-gradient: linear-gradient(135deg, #6ab878 0%, #80b870 50%, #a0b868 100%);
            --start-btn-shadow: 0 8px 30px rgba(106, 184, 120, 0.3);
            --loading-gradient: linear-gradient(90deg, #6ab878, #a0b868);
            --info-highlight: #b0c878;
        }

        /* ========== 主题：薰衣草紫 ========== */
        [data-theme="lavender"] {
            --daw-bg-dark: #161220;
            --daw-accent: #a088d0;
            --daw-accent-rgb: 160, 136, 208;
            --daw-accent-secondary: #d088b0;
            --daw-accent-secondary-rgb: 208, 136, 176;
            --daw-text-primary: #f0ecf8;
            --daw-text-secondary: #c8b8e0;
            --daw-text-muted: #9088a0;
            --sidebar-bg: rgba(20, 15, 30, 0.65);
            --sidebar-border: rgba(160, 136, 208, 0.1);
            --overlay-tint: linear-gradient(135deg, rgba(18, 12, 28, 0.45) 0%, rgba(22, 12, 22, 0.5) 100%);
            --glass-bg: rgba(20, 15, 30, 0.45);
            --glass-bg-deeper: rgba(14, 10, 22, 0.55);
            --glass-border: rgba(160, 136, 208, 0.1);
            --glass-blur: 22px;
            --gradient-main: linear-gradient(135deg, #a088d0, #d088b0);
            --gradient-subtle: linear-gradient(135deg, rgba(160, 136, 208, 0.15), rgba(208, 136, 176, 0.1));
            --glow-soft: 0 0 20px rgba(160, 136, 208, 0.12);
            --glow-accent: 0 0 12px rgba(160, 136, 208, 0.3);
            --shadow-card: 0 8px 32px rgba(0, 0, 0, 0.2), 0 2px 8px rgba(0, 0, 0, 0.1);
            --shadow-elevated: 0 12px 40px rgba(0, 0, 0, 0.3);
            --btn-play: #80c0a0;
            --btn-play-active: #c0b078;
            --btn-pause: #c0b078;
            --btn-stop: #c88890;
            --btn-record: #c88890;
            --btn-record-active: #d07078;
            --btn-download: #88a0d0;
            --btn-upload: #a088d0;
            --btn-export: #78b8a0;
            --btn-loop-active-bg: rgba(208, 136, 176, 0.2);
            --btn-loop-active-color: #d088b0;
            --btn-loop-active-border: rgba(208, 136, 176, 0.35);
            --key-active-white: linear-gradient(180deg, #e8d8f0 0%, #d0b8e0 100%);
            --key-active-white-glow: 0 0 10px rgba(160, 136, 208, 0.4);
            --key-active-black-glow: 0 0 10px rgba(208, 136, 176, 0.4);
            --mini-key-active: linear-gradient(90deg, #a088d0 0%, #c0a8e0 100%);
            --scrollbar-thumb: rgba(160, 136, 208, 0.15);
            --scrollbar-thumb-hover: rgba(160, 136, 208, 0.25);
            --focus-ring: rgba(160, 136, 208, 0.25);
            --start-btn-gradient: linear-gradient(135deg, #a088d0 0%, #b888c0 50%, #d088b0 100%);
            --start-btn-shadow: 0 8px 30px rgba(160, 136, 208, 0.35);
            --loading-gradient: linear-gradient(90deg, #a088d0, #d088b0);
            --info-highlight: #c0a8d8;
        }

        .pr-modal {
            display: none;
            position: fixed;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: rgba(0, 0, 0, 0.92);
            z-index: 20000;
            backdrop-filter: blur(8px);
        }
        .pr-modal.active {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .pr-modal-content {
            width: 96vw; height: 92vh;
            background: var(--pr-bg-darkest);
            border-radius: 8px;
            border: 1px solid var(--pr-border);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.6);
        }

        /* 顶部标题栏 */
        .pr-modal-header {
            display: flex;
            align-items: center;
            padding: 10px 16px;
            background: var(--pr-bg-dark);
            border-bottom: 1px solid var(--pr-border);
            flex-shrink: 0;
            gap: 16px;
        }
        .pr-modal-title {
            font-size: var(--font-sm);
            font-weight: bold;
            color: var(--pr-text-primary);
            white-space: nowrap;
        }
        .pr-modal-toolbar {
            display: flex;
            gap: 12px;
            align-items: center;
            flex: 1;
            flex-wrap: wrap;
        }
        .pr-modal-close {
            width: 32px; height: 32px;
            background: transparent;
            border: none;
            color: var(--pr-text-secondary);
            font-size: var(--font-xl);
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.15s;
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            line-height: 1;
            padding: 0;
        }
        .pr-modal-close:hover {
            background: rgba(255, 100, 100, 0.25);
            color: #ff6b6b;
        }

        /* 导出弹窗 */
        .export-track-item {
            display: flex; align-items: center; gap: 8px;
            padding: 6px 8px; border-radius: 4px;
            background: rgba(255,255,255,0.04);
            font-size: var(--font-xs); color: var(--pr-text-secondary);
        }
        .export-track-color {
            width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0;
        }
        .export-track-name { flex: 1; color: var(--pr-text-primary); }
        .export-track-inst { opacity: 0.7; }
        .export-track-vol { opacity: 0.5; min-width: 40px; text-align: right; }
        .export-track-muted { opacity: 0.3; text-decoration: line-through; }
        .export-format-info {
            text-align: center; font-size: var(--font-xs);
            color: var(--pr-text-secondary); opacity: 0.6;
            padding: 4px 0;
        }
        .export-progress-bar {
            width: 100%; height: 6px; border-radius: 3px;
            background: rgba(255,255,255,0.08); overflow: hidden;
        }
        #exportProgressFill {
            height: 100%; width: 0%; border-radius: 3px;
            background: var(--accent, #4fc3f7);
            transition: width 0.3s ease;
        }
        /* 主界面后台渲染迷你进度 */
        #exportBgProgress {
            display: none; align-items: center; gap: 8px;
            padding: 4px 8px; margin-top: 4px;
            background: rgba(255,255,255,0.04); border-radius: 4px;
            font-size: var(--font-xs); color: var(--text-secondary);
        }
        #exportBgBar {
            flex: 1; height: 4px; border-radius: 2px;
            background: rgba(255,255,255,0.08); overflow: hidden;
        }
        #exportBgFill {
            height: 100%; width: 0%; border-radius: 2px;
            background: var(--accent, #4fc3f7);
            transition: width 0.3s ease;
        }
        #exportBgText { white-space: nowrap; opacity: 0.7; }

        /* 工具组 */
        .prm-tool-group {
            display: flex;
            gap: 4px;
            align-items: center;
            padding-right: 12px;
            border-right: 1px solid var(--pr-border);
        }
        .prm-tool-group:last-child {
            border-right: none;
            padding-right: 0;
        }
        .prm-tool-label {
            font-size: var(--font-xs);
            color: var(--pr-text-muted);
            margin-right: 4px;
            text-transform: uppercase;
        }
        .prm-tool-btn {
            padding: 5px 10px;
            font-size: var(--font-xs);
            font-weight: 500;
            border: 1px solid var(--pr-border);
            border-radius: 3px;
            background: var(--pr-bg-medium);
            color: var(--pr-text-secondary);
            cursor: pointer;
            transition: all 0.1s;
        }
        .prm-tool-btn:hover {
            background: var(--pr-bg-light);
            color: var(--pr-text-primary);
            border-color: var(--pr-border-light);
        }
        .prm-tool-btn.active {
            background: var(--pr-accent);
            color: white;
            border-color: var(--pr-accent);
        }
        .prm-select, .prm-input {
            padding: 4px 8px;
            font-size: var(--font-xs);
            background: var(--pr-bg-medium);
            color: var(--pr-text-primary);
            border: 1px solid var(--pr-border);
            border-radius: 3px;
        }
        .prm-input { width: 55px; }
        .prm-select { min-width: 60px; }

        /* 主编辑区域 */
        .pr-modal-body {
            flex: 1;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            background: var(--pr-bg-darkest);
        }

        /* 时间标尺行 */
        .pr-ruler-row {
            display: flex;
            height: 30px;
            flex-shrink: 0;
            border-bottom: 1px solid var(--pr-border);
            background: var(--pr-bg-dark);
        }
        .pr-ruler-corner {
            width: 120px;
            background: var(--pr-bg-dark);
            border-right: 1px solid var(--pr-border);
            flex-shrink: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: var(--font-xs);
            color: var(--pr-text-muted);
        }
        .pr-time-ruler {
            flex: 1;
            display: block;
        }

        /* 主编辑行 */
        .pr-main-row {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* 钢琴键盘 */
        .pr-piano-keys {
            width: 120px;
            background: var(--pr-bg-medium);
            border-right: 1px solid var(--pr-border);
            position: relative;
            overflow: hidden;
            flex-shrink: 0;
        }
        .pr-piano-key {
            position: absolute;
            left: 0;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            padding-right: 10px;
            font-size: var(--font-xs);
            font-family: 'Consolas', 'Monaco', monospace;
            box-sizing: border-box;
            border-bottom: 1px solid rgba(0,0,0,0.15);
            cursor: pointer;
            transition: filter 0.1s;
        }
        .pr-piano-key.white {
            width: 100%;
            background: linear-gradient(90deg, #b0b0b0 0%, #d8d8d8 100%);
            color: #444;
        }
        .pr-piano-key.black {
            width: 65%;
            background: linear-gradient(90deg, #111118 0%, #2a2a35 100%);
            color: #888;
            z-index: 1;
        }
        .pr-piano-key.c-note {
            background: linear-gradient(90deg, #7ab8ad 0%, #9ad0c5 100%);
        }
        .pr-piano-key .octave-label {
            font-weight: bold;
            color: #2a8a7a;
        }
        .pr-piano-key:hover {
            filter: brightness(1.15);
        }
        .pr-piano-key.active {
            background: linear-gradient(90deg, var(--pr-accent) 0%, var(--pr-accent-hover) 100%) !important;
            color: white !important;
        }

        /* 画布容器 */
        .pr-canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
            background: var(--pr-bg-darkest);
        }
        .pr-note-canvas {
            width: 100%; height: 100%;
            display: block;
        }

        /* 力度编辑区 */
        .pr-velocity-row {
            display: flex;
            height: 80px;
            flex-shrink: 0;
            border-top: 1px solid var(--pr-border);
            background: var(--pr-bg-dark);
        }
        .pr-velocity-label {
            width: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            background: var(--pr-bg-medium);
            border-right: 1px solid var(--pr-border);
            flex-shrink: 0;
            gap: 4px;
        }
        .pr-velocity-label-text {
            font-size: var(--font-xs);
            color: var(--pr-text-muted);
            text-transform: uppercase;
        }
        .pr-velocity-value {
            font-size: var(--font-md);
            font-weight: bold;
            color: var(--pr-velocity-bar);
            font-family: 'Consolas', monospace;
        }
        .pr-velocity-canvas {
            flex: 1;
            display: block;
            background: var(--pr-bg-darkest);
        }

        /* 播放控制栏 */
        .prm-transport-bar {
            display: flex;
            align-items: center;
            padding: 6px 16px;
            background: #18181f;
            border-bottom: 1px solid var(--pr-border);
            gap: 10px;
            flex-shrink: 0;
        }
        .prm-transport-btn {
            width: 34px; height: 28px;
            border: 1px solid var(--pr-border);
            border-radius: 4px;
            background: var(--pr-bg-medium);
            color: var(--pr-text-secondary);
            font-size: var(--font-sm);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.12s;
        }
        .prm-transport-btn:hover {
            background: var(--pr-bg-light);
            color: white;
        }
        .prm-transport-btn.playing {
            background: rgba(94, 196, 182, 0.3);
            color: var(--pr-accent);
            border-color: var(--pr-accent);
        }
        .prm-transport-time {
            font-size: var(--font-xs);
            font-family: 'Consolas', monospace;
            color: var(--pr-text-primary);
            min-width: 110px;
            text-align: center;
        }
        .prm-transport-progress {
            flex: 1;
            height: 6px;
            cursor: pointer;
        }
        .prm-transport-progress-bg {
            width: 100%; height: 100%;
            background: var(--pr-bg-light);
            border-radius: 3px;
            overflow: hidden;
            position: relative;
        }
        .prm-transport-progress-fill {
            height: 100%;
            background: var(--pr-accent);
            border-radius: 3px;
            width: 0%;
            transition: width 0.1s linear;
        }

        /* ========== 主题切换器 ========== */
        #theme-switcher {
            display: flex; gap: var(--space-sm); align-items: center; flex-wrap: wrap;
            padding: var(--space-sm) var(--space-lg);
            border-bottom: 1px solid var(--sidebar-border);
            background: rgba(var(--daw-accent-rgb), 0.03);
        }
        #theme-switcher .theme-label {
            font-size: var(--font-xs); color: var(--daw-text-muted);
            text-transform: uppercase; letter-spacing: 1px;
            margin-right: auto;
        }
        .theme-dot {
            width: var(--theme-dot-size, 22px); height: var(--theme-dot-size, 22px); border-radius: 50%;
            border: 2px solid transparent; cursor: pointer;
            transition: all var(--transition-fast);
            position: relative; overflow: hidden;
        }
        .theme-dot::before {
            content: ''; position: absolute;
            top: 2px; left: 2px; right: 2px; bottom: 2px;
            border-radius: 50%;
        }
        .theme-dot:hover { transform: scale(1.15); }
        .theme-dot.active { border-color: var(--daw-text-primary); box-shadow: var(--glow-accent); }
        .theme-dot[data-theme="sakura"]::before { background: linear-gradient(135deg, #d4a0b8, #b8a0d0); }
        .theme-dot[data-theme="mint"]::before { background: linear-gradient(135deg, #7ec0a8, #88b0d0); }
        .theme-dot[data-theme="twilight"]::before { background: linear-gradient(135deg, #d0a088, #b090c0); }
        .theme-dot[data-theme="ocean"]::before { background: linear-gradient(135deg, #5ca0d8, #68c8e0); }
        .theme-dot[data-theme="cyber"]::before { background: linear-gradient(135deg, #e060d0, #60d0f0); }
        .theme-dot[data-theme="forest"]::before { background: linear-gradient(135deg, #6ab878, #a0b868); }
        .theme-dot[data-theme="lavender"]::before { background: linear-gradient(135deg, #a088d0, #d088b0); }
        #sidebar.collapsed #theme-switcher { display: none; }

        /* 响应式 */
        @media (max-width: 1000px) {
            #sidebar { width: 220px; }
            #sidebar.collapsed { width: var(--sidebar-collapsed-width); }
            .pr-modal-content { width: 98vw; height: 95vh; }
            .pr-piano-keys, .pr-ruler-corner, .pr-velocity-label { width: 80px; }
            .pr-modal-toolbar { gap: 8px; }
            .prm-tool-group { padding-right: 8px; }
        }
        @media (max-width: 768px) {
            #sidebar { width: var(--sidebar-collapsed-width); }
            #sidebar:not(.collapsed) { width: 260px; position: absolute; height: 100%; z-index: 200; box-shadow: 5px 0 20px rgba(0,0,0,0.5); }
            #main-content { padding: var(--space-sm); }
        }

        /* ========== Interactive Tour ========== */
        #tour-overlay {
            position: fixed; top: 0; left: 0; width: 100vw; height: 100vh;
            z-index: 15000; pointer-events: none; opacity: 0; transition: opacity 0.3s ease;
        }
        #tour-overlay.active { opacity: 1; pointer-events: auto; }
        #tour-overlay svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; }
        #tour-cutout {
            transition: x 0.35s cubic-bezier(0.4,0,0.2,1), y 0.35s cubic-bezier(0.4,0,0.2,1),
                        width 0.35s cubic-bezier(0.4,0,0.2,1), height 0.35s cubic-bezier(0.4,0,0.2,1);
        }
        .tour-tooltip {
            position: fixed; z-index: 15001; max-width: 340px; min-width: 260px;
            background: var(--glass-bg-deeper); backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border: 1px solid rgba(var(--daw-accent-rgb), 0.25); border-radius: var(--radius-lg);
            box-shadow: var(--shadow-elevated), 0 0 30px rgba(var(--daw-accent-rgb), 0.15);
            opacity: 0; transform: translateY(8px); pointer-events: none;
            transition: opacity 0.35s cubic-bezier(0.4,0,0.2,1), transform 0.35s cubic-bezier(0.4,0,0.2,1);
        }
        .tour-tooltip.visible { opacity: 1; transform: translateY(0); pointer-events: auto; }
        .tour-tooltip-arrow {
            position: absolute; width: 12px; height: 12px;
            background: var(--glass-bg-deeper); border: 1px solid rgba(var(--daw-accent-rgb), 0.25);
            transform: rotate(45deg); z-index: -1;
        }
        .tour-tooltip-header { padding: 14px 16px 0; display: flex; align-items: center; gap: 8px; }
        .tour-tooltip-step {
            font-size: var(--font-xs); font-weight: bold; color: var(--daw-accent);
            background: rgba(var(--daw-accent-rgb), 0.12); padding: 2px 8px; border-radius: 10px; white-space: nowrap;
        }
        .tour-tooltip-title { font-size: var(--font-sm); font-weight: 700; color: var(--daw-text-primary); }
        .tour-tooltip-body { padding: 10px 16px 14px; font-size: var(--font-xs); line-height: 1.6; color: var(--daw-text-secondary); }
        .tour-tooltip-footer {
            display: flex; align-items: center; justify-content: space-between;
            padding: 10px 16px; border-top: 1px solid rgba(var(--daw-accent-rgb), 0.1);
        }
        .tour-tooltip-dots { display: flex; gap: 5px; }
        .tour-dot {
            width: 6px; height: 6px; border-radius: 50%;
            background: rgba(var(--daw-accent-rgb), 0.2); transition: all 0.2s;
        }
        .tour-dot.active { background: var(--daw-accent); width: 16px; border-radius: 3px; }
        .tour-tooltip-nav { display: flex; gap: 6px; }
        .tour-nav-btn {
            padding: 5px 14px; font-size: var(--font-xs); font-weight: bold; border: none;
            border-radius: var(--radius-md); cursor: pointer; transition: all var(--transition-fast); font-family: inherit;
        }
        .tour-nav-btn:hover { transform: translateY(-1px); }
        .tour-btn-skip { background: transparent; color: var(--daw-text-muted); }
        .tour-btn-skip:hover { color: var(--daw-text-primary); }
        .tour-btn-prev { background: rgba(var(--daw-accent-rgb), 0.1); color: var(--daw-text-secondary); }
        .tour-btn-prev:hover { background: rgba(var(--daw-accent-rgb), 0.2); }
        .tour-btn-next { background: var(--gradient-main); color: #fff; box-shadow: 0 2px 8px rgba(var(--daw-accent-rgb), 0.3); }
        .tour-btn-next:hover { filter: brightness(1.1); }
        #tour-help-btn {
            position: fixed; bottom: 16px; left: 16px;
            width: var(--help-btn-size, 36px); height: var(--help-btn-size, 36px);
            border-radius: 50%; background: var(--glass-bg-deeper);
            backdrop-filter: blur(var(--glass-blur)); -webkit-backdrop-filter: blur(var(--glass-blur));
            border: 1px solid rgba(var(--daw-accent-rgb), 0.2); color: var(--daw-accent);
            font-size: var(--font-md); font-weight: bold; cursor: pointer; z-index: 150;
            display: flex; align-items: center; justify-content: center;
            transition: all var(--transition-fast); box-shadow: var(--glow-soft);
        }
        #tour-help-btn:hover { transform: scale(1.1); border-color: var(--daw-accent); box-shadow: var(--glow-accent); }
        @media (max-width: 768px) {
            .tour-tooltip { max-width: 280px; min-width: 220px; }
            .tour-tooltip-body { font-size: var(--font-xs); }
            #tour-help-btn { bottom: 12px; left: 12px; width: var(--help-btn-size, 32px); height: var(--help-btn-size, 32px); font-size: var(--font-sm); }
        }
    </style>
</head>
<body>

    <div id="bg-container">
        <div class="overlay"></div>
        <div class="bg-slide active" id="bg1"></div>
        <div class="bg-slide" id="bg2"></div>
    </div>

    <div id="startOverlay">
        <button id="startBtn">✨ 点击进入音乐世界 ✨</button>
        <div id="loadingText">加载钢琴音色...</div>
        <div id="loadingBar"><div id="loadingFill"></div></div>
    </div>

    <!-- === DAW 布局主容器 === -->
    <div id="app-container">

        <!-- 左侧边栏 -->
        <aside id="sidebar">
            <div id="sidebar-header">
                <h1 id="sidebar-title">Web SV Piano</h1>
                <button id="sidebar-toggle" title="折叠/展开侧边栏">☰</button>
            </div>

            <div id="theme-switcher">
                <span class="theme-label">Theme</span>
                <div class="theme-dot active" data-theme="sakura" title="樱花淡雅"></div>
                <div class="theme-dot" data-theme="mint" title="薄荷清新"></div>
                <div class="theme-dot" data-theme="twilight" title="黄昏浪漫"></div>
                <div class="theme-dot" data-theme="ocean" title="海洋深蓝"></div>
                <div class="theme-dot" data-theme="cyber" title="赛博霓虹"></div>
                <div class="theme-dot" data-theme="forest" title="森林暗绿"></div>
                <div class="theme-dot" data-theme="lavender" title="薰衣草紫"></div>
            </div>

            <div id="sidebar-content">

                <!-- MIDI -->
                <div class="sidebar-section">
                    <div class="section-header">
                        <div class="section-title"><span class="section-icon">🎹</span><span>MIDI</span></div>
                        <span class="section-chevron">▼</span>
                    </div>
                    <div class="section-content">
                        <div id="midiStatus">未连接</div>
                    </div>
                </div>

                <!-- 音色 -->
                <div class="sidebar-section">
                    <div class="section-header">
                        <div class="section-title"><span class="section-icon">🎛️</span><span>音色</span></div>
                        <span class="section-chevron">▼</span>
                    </div>
                    <div class="section-content">
                        <select class="btn" id="modeSelect" style="cursor:pointer;">
                            <option value="piano">🎹 钢琴</option>
                            <option value="voice">🎤 人声唱调</option>
                            <option value="violin">🎻 小提琴</option>
                            <option value="guitar">🎸 电吉他</option>
                            <option value="drums">🥁 鼓组</option>
                        </select>
                        <select id="voicePresetSelect" class="hidden"></select>
                        <div id="voiceEffectsPanel" class="hidden">
                            <label class="label-small flex-row">
                                <input type="checkbox" id="voiceReverbToggle"> 🏛️ 空间混响
                            </label>
                            <select id="voiceIRSelect" class="hidden" style="margin-top:6px;">
                                <option value="derlon_sanctuary">圣殿 (Sanctuary)</option>
                                <option value="five_columns_long">大厅 (Five Columns)</option>
                                <option value="large_long_echo_hall">回声厅 (Echo Hall)</option>
                                <option value="french_18th_century_salon">沙龙 (18th Salon)</option>
                                <option value="bottle_hall">瓶厅 (Bottle Hall)</option>
                            </select>
                            <div id="reverbParamsPanel" class="hidden" style="margin-top:4px;padding:4px 0;">
                                <div style="display:flex;align-items:center;justify-content:space-between;">
                                    <span class="label-small" style="margin:0;">混响量</span>
                                    <div style="display:flex;align-items:center;gap:4px;">
                                        <input type="range" id="vcReverbSend" min="0" max="1" step="0.05" value="0.55" style="width:80px;">
                                        <span id="vcReverbSendVal" style="min-width:28px;text-align:right;" class="value-display">0.55</span>
                                    </div>
                                </div>
                            </div>
                            <label class="label-small flex-row" style="margin-top:6px;">
                                <input type="checkbox" id="voiceDoublerToggle"> 👥 人声加倍
                            </label>
                            <div id="doublerParamsPanel" class="hidden" style="margin-top:4px;padding:4px 0;flex-direction:column;gap:6px;">
                                <div style="display:flex;align-items:center;justify-content:space-between;">
                                    <span class="label-small" style="margin:0;">加倍量</span>
                                    <div style="display:flex;align-items:center;gap:4px;">
                                        <input type="range" id="vcDoublerMix" min="0" max="0.5" step="0.01" value="0.25" style="width:80px;">
                                        <span id="vcDoublerMixVal" style="min-width:28px;text-align:right;" class="value-display">0.25</span>
                                    </div>
                                </div>
                                <div style="display:flex;align-items:center;justify-content:space-between;">
                                    <span class="label-small" style="margin:0;">音高偏移</span>
                                    <div style="display:flex;align-items:center;gap:4px;">
                                        <input type="range" id="vcDoublerPitch" min="0.01" max="0.2" step="0.005" value="0.035" style="width:80px;">
                                        <span id="vcDoublerPitchVal" style="min-width:36px;text-align:right;" class="value-display">0.035</span>
                                    </div>
                                </div>
                                <div style="display:flex;align-items:center;justify-content:space-between;">
                                    <span class="label-small" style="margin:0;">声像宽度</span>
                                    <div style="display:flex;align-items:center;gap:4px;">
                                        <input type="range" id="vcDoublerWidth" min="0" max="1" step="0.05" value="0.35" style="width:80px;">
                                        <span id="vcDoublerWidthVal" style="min-width:28px;text-align:right;" class="value-display">0.35</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <select id="drumPresetSelect" class="hidden">
                            <option value="acoustic">Acoustic</option>
                            <option value="tr808">TR-808</option>
                            <option value="electronic">Electronic</option>
                            <option value="sampled">Sampled (真实采样)</option>
                        </select>
                        <div class="label-hint">选择乐器音色</div>
                    </div>
                </div>

                <!-- 键位 -->
                <div class="sidebar-section collapsed">
                    <div class="section-header">
                        <div class="section-title"><span class="section-icon">⌨️</span><span>键位</span></div>
                        <span class="section-chevron">▼</span>
                    </div>
                    <div class="section-content">
                        <div class="label-hint">右键绑定 · [ ] 换八度</div>
                        <button class="btn btn-reset" id="resetMapBtn">↺ 恢复默认</button>
                    </div>
                </div>

                <!-- 节奏 -->
                <div class="sidebar-section">
                    <div class="section-header">
                        <div class="section-title"><span class="section-icon">🎚️</span><span>节奏</span></div>
                        <span class="section-chevron">▼</span>
                    </div>
                    <div class="section-content">
                        <input type="number" id="bpmInput" value="120" min="40" max="240">
                        <div id="metronome-display">
                            <div id="beat-indicator"></div>
                            <label class="label-small"><input type="checkbox" id="metronomeToggle" style="width:12px;height:12px;"> 节拍器</label>
                        </div>
                    </div>
                </div>

                <!-- 量化 -->
                <div class="sidebar-section collapsed">
                    <div class="section-header">
                        <div class="section-title"><span class="section-icon">📐</span><span>量化</span></div>
                        <span class="section-chevron">▼</span>
                    </div>
                    <div class="section-content">
                        <select id="quantizeSelect">
                            <option value="0">自由</option>
                            <option value="4" selected>1/4</option>
                            <option value="8">1/8</option>
                            <option value="16">1/16</option>
                        </select>
                        <div class="slider-group">
                            <span>强度</span>
                            <input type="range" id="humanizeSlider" min="0" max="1" step="0.1" value="1.0">
                            <span id="humanizeVal" class="value-display">100%</span>
                        </div>
                    </div>
                </div>

                <!-- 人性化 -->
                <div class="sidebar-section collapsed">
                    <div class="section-header">
                        <div class="section-title"><span class="section-icon">🎭</span><span>人性化</span></div>
                        <span class="section-chevron">▼</span>
                    </div>
                    <div class="section-content">
                        <select id="humanizePresetSelect">
                            <option value="none">无（纯量化）</option>
                            <option value="subtle">轻微</option>
                            <option value="natural">自然</option>
                            <option value="loose">松散</option>
                            <option value="swing">摇摆</option>
                            <option value="laid_back">慵懒</option>
                        </select>
                    </div>
                </div>

                <!-- 混响 -->
                <div class="sidebar-section collapsed">
                    <div class="section-header">
                        <div class="section-title"><span class="section-icon">🌌</span><span>混响</span></div>
                        <span class="section-chevron">▼</span>
                    </div>
                    <div class="section-content">
                        <div class="slider-panel">
                            <div class="slider-group"><span>Wet</span><input type="range" id="wetSlider" min="0" max="1" step="0.05" value="0.2"><span class="value-display">0.2</span></div>
                            <div class="slider-group"><span>Size</span><input type="range" id="decaySlider" min="0.5" max="10" step="0.5" value="3"><span class="value-display">3.0</span></div>
                        </div>
                    </div>
                </div>

                <!-- 背景 -->
                <div class="sidebar-section collapsed">
                    <div class="section-header">
                        <div class="section-title"><span class="section-icon">🖼️</span><span>背景</span></div>
                        <span class="section-chevron">▼</span>
                    </div>
                    <div class="section-content">
                        <button class="btn" id="customBgBtn" style="width:100%;position:relative;overflow:hidden;">
                            📁 选择图片
                            <input type="file" id="customBgInput" accept="image/*" style="position:absolute;top:0;left:0;width:100%;height:100%;opacity:0;cursor:pointer;">
                        </button>
                        <button class="btn" id="resetBgBtn" style="width:100%;">🔄 恢复默认</button>
                    </div>
                </div>

                <!-- 录制 & 导入 -->
                <div class="sidebar-section">
                    <div class="section-header">
                        <div class="section-title"><span class="section-icon">🔴</span><span>录制 / 导入</span></div>
                        <span class="section-chevron">▼</span>
                    </div>
                    <div class="section-content">
                        <div class="flex-row">
                            <button class="btn btn-record" id="recordBtn">⏺ 录制</button>
                            <button class="btn btn-download" id="downloadBtn" disabled>💾 MIDI</button>
                        </div>
                        <button class="btn btn-upload">
                            📁 上传 MIDI
                            <input type="file" id="midiFileInput" accept=".mid,.midi">
                        </button>
                    </div>
                </div>

            </div>

            <div id="sidebar-footer">
                <div id="status">等待启动...</div>
            </div>
        </aside>

        <!-- 主内容区域 -->
        <main id="main-content">
            <h1>Web SV 钢琴工作站 ♪</h1>

            <div class="piano-container">
                <div id="bindOverlay">
                    <div class="bind-msg">按下键盘任意键绑定到</div>
                    <div class="bind-note" id="targetBindNote">C4</div>
                    <div class="cancel-bind" onclick="cancelBind()">取消 (Esc)</div>
                </div>
                <div class="piano" id="piano"></div>
                <div class="piano-rows-wrapper" id="pianoRowsWrapper">
                    <div class="piano-row" id="pianoRow1"></div>
                    <div class="piano-row" id="pianoRow2"></div>
                </div>
            </div>

            <div style="display: flex; justify-content: center; margin: 12px 0;">
                <div id="octave-display">Octave: 0</div>
            </div>

            <div id="playerSection">
                <div id="playerHeader">
                    <span id="playerTitle">🎵 播放器</span>
                    <span id="timeDisplay">00:00 / 00:00</span>
                </div>
                <div id="progressWrapper">
                    <div id="progressFill"></div>
                    <div id="progressHandle"></div>
                </div>
                <div id="playerControls">
                    <button class="btn btn-play" id="playBtn" disabled>▶ 播放</button>
                    <button class="btn btn-pause" id="pauseBtn" disabled>⏸ 暂停</button>
                    <button class="btn btn-stop" id="stopBtn" disabled>⏹ 停止</button>
                    <button class="btn btn-loop" id="loopBtn" title="单曲循环">🔁 循环</button>
                    <button class="btn btn-export" id="exportWavBtn" disabled>💾 下载 WAV</button>
                </div>
                <div id="exportBgProgress" style="display:none;">
                    <div id="exportBgBar">
                        <div id="exportBgFill"></div>
                    </div>
                    <span id="exportBgText">渲染中...</span>
                    <button class="btn" id="exportBgOpen" style="padding:2px 8px;font-size:var(--font-xs);">查看</button>
                </div>
                <div id="midiInfoPanel">
                    <h3>📊 MIDI 信息</h3>
                    <div class="midi-info-grid">
                        <div class="midi-info-item">
                            <div class="midi-info-value" id="infoBpm">-</div>
                            <div class="midi-info-label">BPM</div>
                        </div>
                        <div class="midi-info-item">
                            <div class="midi-info-value" id="infoTracks">-</div>
                            <div class="midi-info-label">音轨</div>
                        </div>
                        <div class="midi-info-item">
                            <div class="midi-info-value" id="infoNotes">-</div>
                            <div class="midi-info-label">音符</div>
                        </div>
                        <div class="midi-info-item">
                            <div class="midi-info-value" id="infoDuration">-</div>
                            <div class="midi-info-label">时长</div>
                        </div>
                        <div class="midi-info-item">
                            <div class="midi-info-value" id="infoRenderStatus">-</div>
                            <div class="midi-info-label">音频</div>
                        </div>
                    </div>
                </div>
                <div id="trackControlsPanel">
                    <div id="trackControlsHeader">
                        <span>🎚️ 轨道 (<span id="trackCount">0</span>)</span>
                        <button class="btn-toggle" id="toggleTracksBtn">▼ 折叠</button>
                    </div>
                    <div id="trackList"></div>
                </div>
            </div>

            <!-- 横向钢琴卷帘可视化器 -->
            <div id="visualizerSection">
                <div id="visualizerHeader">
                    <span id="visualizerTitle">🎬 钢琴卷帘</span>
                    <div class="flex-row">
                        <button class="pr-tool-btn" id="openPianoRollModalBtn" title="打开钢琴卷帘编辑器" style="background:rgba(74,158,255,0.2);border-color:rgba(74,158,255,0.5);">编辑</button>
                        <button class="btn-toggle" id="toggleVisualizerBtn">▼ 折叠</button>
                    </div>
                </div>
                <div id="pianoRollToolbar" style="display:none;">
                    <div class="pr-tool-group">
                        <span class="pr-tool-label">工具</span>
                        <button class="pr-tool-btn active" id="toolSelect" data-tool="select" title="选择/移动 (V)">选择</button>
                        <button class="pr-tool-btn" id="toolDraw" data-tool="draw" title="绘制音符 (D)">绘制</button>
                        <button class="pr-tool-btn" id="toolErase" data-tool="erase" title="擦除音符 (E)">擦除</button>
                    </div>
                    <div class="pr-tool-group">
                        <span class="pr-tool-label">网格</span>
                        <select id="prGridSnap" class="pr-tool-btn" style="padding:2px 4px;">
                            <option value="0">自由</option>
                            <option value="4" selected>1/4</option>
                            <option value="8">1/8</option>
                            <option value="16">1/16</option>
                            <option value="32">1/32</option>
                        </select>
                    </div>
                    <div class="pr-tool-group">
                        <span class="pr-tool-label">缩放</span>
                        <button class="pr-tool-btn pr-zoom-btn" id="zoomInH" title="水平放大">H+</button>
                        <button class="pr-tool-btn pr-zoom-btn" id="zoomOutH" title="水平缩小">H-</button>
                        <button class="pr-tool-btn pr-zoom-btn" id="zoomInV" title="垂直放大">V+</button>
                        <button class="pr-tool-btn pr-zoom-btn" id="zoomOutV" title="垂直缩小">V-</button>
                    </div>
                    <div class="pr-tool-group">
                        <span class="pr-tool-label">操作</span>
                        <button class="pr-tool-btn" id="prUndo" title="撤销 (Ctrl+Z)">撤销</button>
                        <button class="pr-tool-btn" id="prRedo" title="重做 (Ctrl+Y)">重做</button>
                        <button class="pr-tool-btn" id="prDeleteSelected" title="删除选中 (Del)">删除</button>
                    </div>
                </div>
                <div id="visualizerWrapper">
                    <div id="miniPiano"></div>
                    <div id="canvasWrapper">
                        <canvas id="fallingNotesCanvas"></canvas>
                    </div>
                </div>
            </div>
        </main>

    </div>

    <script src="/lib/Tone.js"></script>
    <script src="/lib/Midi.min.js"></script>
    
    <script>
        // ★★★ 启动时强制清理 localStorage，确保干净状态 ★★★
        // 如果你想保留自定义键位，注释掉下面这行
        // localStorage.removeItem('sv_piano_keymap');

        // === 背景轮播 ===
        const backgroundImages = [
            "/public/images/1.jpg",
            "/public/images/2.jpg"
        ];
        let currentBgIndex = 0;
        const slide1 = document.getElementById('bg1');
        const slide2 = document.getElementById('bg2');
        let activeSlide = slide1, nextSlide = slide2;
        slide1.style.backgroundImage = `url('${backgroundImages[0]}')`;

        // === 自定义背景 ===
        let bgCarouselId = null;
        let useCustomBg = false;

        // 启动轮播
        function startBgCarousel() {
            if (bgCarouselId) return;
            bgCarouselId = setInterval(() => {
                if (useCustomBg) return;
                currentBgIndex = (currentBgIndex + 1) % backgroundImages.length;
                const img = new Image(); img.src = backgroundImages[currentBgIndex];
                img.onload = () => {
                    nextSlide.style.backgroundImage = `url('${backgroundImages[currentBgIndex]}')`;
                    nextSlide.classList.add('active'); activeSlide.classList.remove('active');
                    [activeSlide, nextSlide] = [nextSlide, activeSlide];
                };
            }, 10000);
        }

        function applyCustomBg(dataUrl) {
            useCustomBg = true;
            nextSlide.style.backgroundImage = `url('${dataUrl}')`;
            nextSlide.classList.add('active'); activeSlide.classList.remove('active');
            [activeSlide, nextSlide] = [nextSlide, activeSlide];
            localStorage.setItem('sv_piano_custom_bg', dataUrl);
        }

        function resetToDefaultBg() {
            useCustomBg = false;
            localStorage.removeItem('sv_piano_custom_bg');
            currentBgIndex = 0;
            nextSlide.style.backgroundImage = `url('${backgroundImages[0]}')`;
            nextSlide.classList.add('active'); activeSlide.classList.remove('active');
            [activeSlide, nextSlide] = [nextSlide, activeSlide];
        }

        document.getElementById('customBgInput').addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (ev) => applyCustomBg(ev.target.result);
            reader.readAsDataURL(file);
        });

        document.getElementById('resetBgBtn').addEventListener('click', resetToDefaultBg);

        // 恢复已保存的自定义背景
        const savedCustomBg = localStorage.getItem('sv_piano_custom_bg');
        if (savedCustomBg) {
            applyCustomBg(savedCustomBg);
        }

        startBgCarousel();

        // === 侧边栏交互 ===
        (function initSidebar() {
            const sidebar = document.getElementById('sidebar');
            const toggleBtn = document.getElementById('sidebar-toggle');

            // 侧边栏折叠/展开
            toggleBtn.addEventListener('click', () => {
                sidebar.classList.toggle('collapsed');
                // 触发 resize 事件让 canvas 重新计算尺寸
                setTimeout(() => window.dispatchEvent(new Event('resize')), 350);
            });

            // 手风琴折叠/展开
            document.querySelectorAll('.section-header').forEach(header => {
                header.addEventListener('click', (e) => {
                    e.stopPropagation();
                    header.parentElement.classList.toggle('collapsed');
                });
            });

            // 主题切换
            const savedTheme = localStorage.getItem('piano-theme') || 'sakura';
            document.documentElement.setAttribute('data-theme', savedTheme);
            document.querySelectorAll('.theme-dot').forEach(dot => {
                if (dot.dataset.theme === savedTheme) dot.classList.add('active');
                else dot.classList.remove('active');
                dot.addEventListener('click', () => {
                    const theme = dot.dataset.theme;
                    document.documentElement.setAttribute('data-theme', theme);
                    localStorage.setItem('piano-theme', theme);
                    document.querySelectorAll('.theme-dot').forEach(d => d.classList.remove('active'));
                    dot.classList.add('active');
                });
            });
        })();

        // === Interactive Tour Engine ===
        class AppTour {
            constructor(steps) {
                this.steps = steps;
                this.currentIndex = -1;
                this.isActive = false;
                this._build();
            }

            _build() {
                this.overlay = document.createElement('div');
                this.overlay.id = 'tour-overlay';
                this.overlay.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg">
                    <defs><mask id="tour-spotlight-mask">
                        <rect width="100%" height="100%" fill="white"/>
                        <rect id="tour-cutout" rx="10" ry="10" fill="black" x="0" y="0" width="0" height="0"/>
                    </mask></defs>
                    <rect width="100%" height="100%" fill="rgba(0,0,0,0.65)" mask="url(#tour-spotlight-mask)" style="cursor:pointer;"/>
                </svg>`;

                this.tooltip = document.createElement('div');
                this.tooltip.className = 'tour-tooltip';
                this.tooltip.innerHTML = `<div class="tour-tooltip-arrow"></div>
                    <div class="tour-tooltip-header">
                        <span class="tour-tooltip-step"></span>
                        <span class="tour-tooltip-title"></span>
                    </div>
                    <div class="tour-tooltip-body"></div>
                    <div class="tour-tooltip-footer">
                        <div class="tour-tooltip-dots"></div>
                        <div class="tour-tooltip-nav">
                            <button class="tour-nav-btn tour-btn-skip">跳过</button>
                            <button class="tour-nav-btn tour-btn-prev">← 上一步</button>
                            <button class="tour-nav-btn tour-btn-next">下一步 →</button>
                        </div>
                    </div>`;

                document.body.appendChild(this.overlay);
                document.body.appendChild(this.tooltip);

                this.tooltip.querySelector('.tour-btn-next').addEventListener('click', () => this.next());
                this.tooltip.querySelector('.tour-btn-prev').addEventListener('click', () => this.prev());
                this.tooltip.querySelector('.tour-btn-skip').addEventListener('click', () => this.end());
                this.overlay.querySelector('svg rect[mask]').addEventListener('click', () => this.next());

                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape' && this.isActive) this.end();
                });

                const helpBtn = document.createElement('button');
                helpBtn.id = 'tour-help-btn';
                helpBtn.textContent = '?';
                helpBtn.title = '使用指引';
                helpBtn.addEventListener('click', () => this.start(0));
                document.body.appendChild(helpBtn);
            }

            start(fromIndex = 0) {
                if (this.isActive) return;
                this.isActive = true;
                this.currentIndex = fromIndex - 1;
                this.tooltip.style.display = '';
                this.overlay.classList.add('active');
                this.next();
                this._resizeHandler = () => { if (this.isActive) this._positionCurrent(); };
                window.addEventListener('resize', this._resizeHandler);
                document.getElementById('main-content')?.addEventListener('scroll', this._resizeHandler);
                window.addEventListener('scroll', this._resizeHandler);
            }

            next() {
                if (this.currentIndex >= this.steps.length - 1) { this.end(); return; }
                this.currentIndex++;
                this._showStep(this.currentIndex);
            }

            prev() {
                if (this.currentIndex <= 0) return;
                this.currentIndex--;
                this._showStep(this.currentIndex);
            }

            end() {
                this.isActive = false;
                this.overlay.classList.remove('active');
                this.tooltip.classList.remove('visible');
                this.tooltip.style.display = 'none';
                localStorage.setItem('sv_piano_tour_done', '1');
                window.removeEventListener('resize', this._resizeHandler);
                document.getElementById('main-content')?.removeEventListener('scroll', this._resizeHandler);
                window.removeEventListener('scroll', this._resizeHandler);
            }

            _showStep(index) {
                const step = this.steps[index];
                if (step.onBefore) step.onBefore();
                const delay = step.onBefore ? 400 : 0;
                setTimeout(() => {
                    requestAnimationFrame(() => {
                        if (!this.isActive) return;
                        this._updateContent(step, index);
                        this._positionCurrent();
                    });
                }, delay);
            }

            _positionCurrent() {
                const step = this.steps[this.currentIndex];
                const el = document.querySelector(step.target);
                if (!el || el.offsetParent === null || el.classList.contains('hidden')) {
                    // Element not visible, skip
                    if (this.currentIndex < this.steps.length - 1) this.next();
                    else this.end();
                    return;
                }
                const rect = el.getBoundingClientRect();
                const pad = step.padding ?? 8;
                const cutout = document.getElementById('tour-cutout');
                cutout.setAttribute('x', rect.left - pad);
                cutout.setAttribute('y', rect.top - pad);
                cutout.setAttribute('width', rect.width + pad * 2);
                cutout.setAttribute('height', rect.height + pad * 2);
                this._positionTooltip(rect, step.position || 'bottom', pad);
            }

            _positionTooltip(targetRect, preferredPos, pad) {
                const tt = this.tooltip;
                const arrow = tt.querySelector('.tour-tooltip-arrow');
                tt.style.visibility = 'hidden';
                tt.classList.add('visible');
                const ttRect = tt.getBoundingClientRect();
                tt.style.visibility = '';

                const gap = 14;
                const vw = window.innerWidth;
                const vh = window.innerHeight;
                const positions = {
                    bottom: { top: targetRect.bottom + pad + gap, left: targetRect.left + targetRect.width / 2 - ttRect.width / 2, fits: targetRect.bottom + pad + gap + ttRect.height < vh },
                    top: { top: targetRect.top - pad - gap - ttRect.height, left: targetRect.left + targetRect.width / 2 - ttRect.width / 2, fits: targetRect.top - pad - gap - ttRect.height > 0 },
                    right: { top: targetRect.top + targetRect.height / 2 - ttRect.height / 2, left: targetRect.right + pad + gap, fits: targetRect.right + pad + gap + ttRect.width < vw },
                    left: { top: targetRect.top + targetRect.height / 2 - ttRect.height / 2, left: targetRect.left - pad - gap - ttRect.width, fits: targetRect.left - pad - gap - ttRect.width > 0 }
                };

                let pos = preferredPos;
                if (!positions[pos].fits) pos = Object.keys(positions).find(k => positions[k].fits) || 'bottom';
                let { top, left } = positions[pos];
                left = Math.max(8, Math.min(left, vw - ttRect.width - 8));
                top = Math.max(8, Math.min(top, vh - ttRect.height - 8));
                tt.style.top = top + 'px';
                tt.style.left = left + 'px';

                // Arrow
                const arrowStyles = {
                    bottom: { top: '-6px', left: '50%', marginLeft: '-6px', bottom: '', right: '', borderRight: 'none', borderBottom: 'none' },
                    top: { bottom: '-6px', left: '50%', marginLeft: '-6px', top: '', right: '', borderLeft: 'none', borderTop: 'none' },
                    right: { left: '-6px', top: '50%', marginTop: '-6px', bottom: '', right: '', borderTop: 'none', borderRight: 'none' },
                    left: { right: '-6px', top: '50%', marginTop: '-6px', bottom: '', left: '', borderBottom: 'none', borderLeft: 'none' }
                };
                Object.assign(arrow.style, { top: '', bottom: '', left: '', right: '', marginLeft: '', marginTop: '', borderTop: '', borderBottom: '', borderLeft: '', borderRight: '', ...arrowStyles[pos] });
                tt.classList.add('visible');
            }

            _updateContent(step, index) {
                const tt = this.tooltip;
                tt.classList.remove('visible');
                tt.querySelector('.tour-tooltip-step').textContent = `${index + 1} / ${this.steps.length}`;
                tt.querySelector('.tour-tooltip-title').textContent = step.title;
                tt.querySelector('.tour-tooltip-body').innerHTML = step.content;
                tt.querySelector('.tour-tooltip-dots').innerHTML = this.steps.map((_, i) =>
                    `<div class="tour-dot${i === index ? ' active' : ''}"></div>`
                ).join('');
                tt.querySelector('.tour-btn-prev').style.display = index === 0 ? 'none' : '';
                tt.querySelector('.tour-btn-next').textContent = index === this.steps.length - 1 ? '完成 ✓' : '下一步 →';
            }
        }

        const TOUR_STEPS = [
            {
                target: '#sidebar', position: 'right', title: '🎛️ 控制面板',
                content: '所有的乐器设置、录制控制、MIDI 选项都在这个侧边栏里。<br>点击左上角 <b>☰</b> 可以折叠/展开。',
                onBefore: () => { document.getElementById('sidebar').classList.remove('collapsed'); }
            },
            {
                target: '#modeSelect', position: 'right', title: '🎵 切换音色',
                content: '从下拉菜单选择乐器音色：<br><b>🎹 钢琴 / 🎤 人声 / 🎻 小提琴 / 🎸 吉他 / 🥁 鼓组</b>',
                onBefore: () => {
                    const s = document.getElementById('modeSelect')?.closest('.sidebar-section');
                    if (s) s.classList.remove('collapsed');
                }
            },
            {
                target: '.piano-container', position: 'top', title: '🎹 演奏键盘',
                content: '用鼠标点击琴键，或者用电脑键盘演奏。<br>键盘上的字母对应不同的音符。<b>右键点击</b>琴键可以自定义键位绑定。',
                onBefore: () => { window.scrollTo({ top: 0, behavior: 'smooth' }); }
            },
            {
                target: '#octave-display', position: 'left', title: '🔢 八度调节',
                content: '按键盘上的 <b>[</b> 和 <b>]</b> 键来上下移动八度，扩展你的音域范围。'
            },
            {
                target: '#recordBtn', position: 'right', title: '⏺ 录制',
                content: '点击开始录制你的演奏，再次点击停止。<br>录制完成后可以回放、编辑，或下载为 MIDI 文件。',
                onBefore: () => {
                    const s = document.getElementById('recordBtn')?.closest('.sidebar-section');
                    if (s) s.classList.remove('collapsed');
                }
            },
            {
                target: '.btn-upload', position: 'right', title: '📁 导入 MIDI',
                content: '上传 <b>.mid</b> 文件，可以可视化播放并跟着学习曲目。<br>支持多轨 MIDI，每个轨道可以独立控制。'
            },
            {
                target: '#playerSection', position: 'top', title: '▶️ 播放控制',
                content: '播放、暂停、停止、循环你的录制或导入的 MIDI。<br>可以拖动进度条跳转，也可以导出为 <b>WAV</b> 音频文件。',
                onBefore: () => { document.getElementById('playerSection')?.scrollIntoView({ behavior: 'smooth', block: 'center' }); }
            },
            {
                target: '#visualizerSection', position: 'top', title: '🎼 音符瀑布',
                content: '实时显示你演奏和回放的音符。<br>点击 <b>编辑</b> 按钮可以打开全屏钢琴卷帘编辑器，绘制和修改音符。',
                onBefore: () => {
                    const w = document.getElementById('visualizerWrapper');
                    if (w && w.classList.contains('collapsed')) document.getElementById('toggleVisualizerBtn')?.click();
                    document.getElementById('visualizerSection')?.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            },
            {
                target: '#voiceCloneBtn', position: 'right', title: '🎙️ 声线克隆',
                content: '上传一段 5-25 秒的音频，AI 会克隆这个声线。<br>然后你就可以用这个声音来弹钢琴了！<br><i>（需要先切换到人声模式）</i>'
            },
            {
                target: '#theme-switcher', position: 'right', title: '🎨 主题 & 快捷键',
                content: '七种视觉主题随心切换：<b>樱花 · 薄荷 · 黄昏 · 海洋 · 赛博 · 森林 · 薰衣草</b><br><br>⌨️ 快捷键速查：<br><b>[ ]</b> — 切换八度<br><b>Space</b> — 播放/暂停<br><b>右键琴键</b> — 绑定按键<br><b>V / D / E</b> — 编辑器工具<br><b>Ctrl+Z / Y</b> — 撤销/重做<br><br>随时点击左下角 <b>?</b> 重新查看本指引。'
            }
        ];

        // === 全局变量 ===
        let pianoSampler = null;
        let pianoBuffers = null;

        // 人声采样模式（samples/girl）
        let voiceSampler = null;
        let voiceBuffers = null;
        let voiceConvolver = null;     // Tone.Convolver 卷积混响
        let voiceReverbSend = null;    // 混响发送增益（控制湿声量）
        let voiceDoublerL = null;      // 人声加倍器左声道 PitchShift
        let voiceDoublerR = null;      // 人声加倍器右声道 PitchShift
        let voiceDoublerPanL = null;   // 左声道 Panner
        let voiceDoublerPanR = null;   // 右声道 Panner
        let voiceDoublerGain = null;   // 加倍器混合增益
        let voiceDoublerLPF = null;    // 加倍器低通滤波（让加倍声偏暗）
        let voiceReverbEnabled = false;
        let voiceDoublerEnabled = false;
        let currentVoiceIR = 'derlon_sanctuary';

        // 小提琴采样器
        let violinSampler = null;
        let violinBuffers = null;

        // 电吉他采样器 (GuitarSamplerEngine 实例)
        let guitarSampler = null;

        // 鼓组
        let drumKit = null;

        // 轨道专用采样器/鼓组缓存
        const voiceSamplerCache = {};  // { presetKey: Tone.Sampler }
        const drumKitCache = {};       // { presetKey: DrumKit }

        let currentSoundMode = 'piano'; // 'piano' | 'voice' | 'violin' | 'guitar' | 'drums'

        let reverb = null;
        let reverbWorkletNode = null;
        let reverbWetGain = null;
        let reverbDryGain = null;
        let audioContext = null;

        // Freeverb AudioWorklet 处理器代码
        const freeverbProcessorCode = `
class FreeverbProcessor extends AudioWorkletProcessor {
    constructor() {
        super();
        this.sampleRate = sampleRate;

        // 梳状滤波器延迟时间（采样数）
        const combTunings = [1116, 1188, 1277, 1356, 1422, 1491, 1557, 1617];
        // 全通滤波器延迟时间
        const allpassTunings = [556, 441, 341, 225];

        // 立体声展宽
        const stereoSpread = 23;

        // 初始化梳状滤波器缓冲区
        this.combL = combTunings.map(t => ({ buf: new Float32Array(t), idx: 0, filterStore: 0 }));
        this.combR = combTunings.map(t => ({ buf: new Float32Array(t + stereoSpread), idx: 0, filterStore: 0 }));

        // 初始化全通滤波器缓冲区
        this.allpassL = allpassTunings.map(t => ({ buf: new Float32Array(t), idx: 0 }));
        this.allpassR = allpassTunings.map(t => ({ buf: new Float32Array(t + stereoSpread), idx: 0 }));

        // 参数
        this.wet = 0.2;
        this.dry = 0.8;
        this.roomSize = 0.84;
        this.damp = 0.2;

        this.port.onmessage = (e) => {
            if (e.data.wet !== undefined) this.wet = e.data.wet;
            if (e.data.dry !== undefined) this.dry = 1 - e.data.wet * 0.5;
            if (e.data.roomSize !== undefined) this.roomSize = e.data.roomSize;
            if (e.data.damp !== undefined) this.damp = e.data.damp;
        };
    }

    process(inputs, outputs, parameters) {
        const input = inputs[0];
        const output = outputs[0];

        if (!input || !input[0]) return true;

        const inL = input[0];
        const inR = input[1] || input[0];
        const outL = output[0];
        const outR = output[1] || output[0];

        const wet = this.wet;
        const dry = this.dry;
        const roomSize = this.roomSize;
        const damp = this.damp;
        const damp2 = 1 - damp;

        for (let i = 0; i < inL.length; i++) {
            const inputSample = (inL[i] + inR[i]) * 0.5;
            let wetL = 0, wetR = 0;

            // 梳状滤波器（并行）
            for (let c = 0; c < 8; c++) {
                const combL = this.combL[c];
                const combR = this.combR[c];

                // 左声道
                const outCombL = combL.buf[combL.idx];
                combL.filterStore = outCombL * damp2 + combL.filterStore * damp;
                combL.buf[combL.idx] = inputSample + combL.filterStore * roomSize;
                combL.idx = (combL.idx + 1) % combL.buf.length;
                wetL += outCombL;

                // 右声道
                const outCombR = combR.buf[combR.idx];
                combR.filterStore = outCombR * damp2 + combR.filterStore * damp;
                combR.buf[combR.idx] = inputSample + combR.filterStore * roomSize;
                combR.idx = (combR.idx + 1) % combR.buf.length;
                wetR += outCombR;
            }

            // 全通滤波器（串行）
            for (let a = 0; a < 4; a++) {
                const apL = this.allpassL[a];
                const apR = this.allpassR[a];
                const feedback = 0.5;

                // 左声道
                const bufOutL = apL.buf[apL.idx];
                apL.buf[apL.idx] = wetL + bufOutL * feedback;
                wetL = bufOutL - wetL * feedback;
                apL.idx = (apL.idx + 1) % apL.buf.length;

                // 右声道
                const bufOutR = apR.buf[apR.idx];
                apR.buf[apR.idx] = wetR + bufOutR * feedback;
                wetR = bufOutR - wetR * feedback;
                apR.idx = (apR.idx + 1) % apR.buf.length;
            }

            // 混合干湿信号
            outL[i] = inL[i] * dry + wetL * wet;
            outR[i] = inR[i] * dry + wetR * wet;
        }

        return true;
    }
}
registerProcessor('freeverb-processor', FreeverbProcessor);
`;

        let isRecording = false;
        let isPlaying = false;
        let isPaused = false;
        let isLooping = false;
        let recordingStartTime = 0;
        let audioStarted = false;
        let activeNotes = {};
        let recordedEvents = [];
        let playbackTimeouts = [];
        let playbackStartTime = 0;
        let playbackPausedAt = 0;
        let totalDuration = 0;
        let progressAnimationId = null;
        let metronomeInterval = null;

        // === MIDI 输入相关 ===
        let midiAccess = null;
        let sustainPedal = false;
        let sustainedNotes = {};

        // === 多轨道和可视化器 ===
        let trackManager = null;
        let visualizer = null;
        let visualizerVisible = true;

        // 轨道颜色预设（最多16轨）
        const TRACK_COLORS = [
            '#5ec4b6', '#4ECDC4', '#45B7D1', '#96CEB4',
            '#FFEAA7', '#DDA0DD', '#98D8C8', '#F7DC6F',
            '#BB8FCE', '#85C1E9', '#F8B500', '#00CED1',
            '#FF69B4', '#32CD32', '#FF7F50', '#9370DB'
        ];

        const statusEl = document.getElementById('status');
        const progressFill = document.getElementById('progressFill');
        const progressHandle = document.getElementById('progressHandle');
        const progressWrapper = document.getElementById('progressWrapper');
        const timeDisplay = document.getElementById('timeDisplay');
        const renderStatusEl = document.getElementById('infoRenderStatus');

        const PIANO_SAMPLES = {
            'A0': 'A0.mp3', 'C1': 'C1.mp3', 'A1': 'A1.mp3',
            'C2': 'C2.mp3', 'A2': 'A2.mp3',
            'C3': 'C3.mp3', 'A3': 'A3.mp3',
            'C4': 'C4.mp3', 'D#4': 'Ds4.mp3', 'F#4': 'Fs4.mp3', 'A4': 'A4.mp3',
            'C5': 'C5.mp3', 'D#5': 'Ds5.mp3', 'F#5': 'Fs5.mp3', 'A5': 'A5.mp3',
            'C6': 'C6.mp3', 'A6': 'A6.mp3', 'C7': 'C7.mp3', 'C8': 'C8.mp3'
        };
        const PIANO_BASE_URL = "/samples/piano/";

        // === 小提琴采样配置 (VSCO 2 CE) ===
        const VIOLIN_SAMPLES = {
            'G3': 'LLVln_ArcoVib_G3_f.mp3',
            'A3': 'LLVln_ArcoVib_A3_f.mp3',
            'C4': 'LLVln_ArcoVib_C4_f.mp3',
            'E4': 'LLVln_ArcoVib_E4_f.mp3',
            'G4': 'LLVln_ArcoVib_G4_f.mp3',
            'A4': 'LLVln_ArcoVib_A4_f.mp3',
            'C5': 'LLVln_ArcoVib_C5_f.mp3',
            'E5': 'LLVln_ArcoVib_E5_f.mp3',
            'G5': 'LLVln_ArcoVib_G5_f.mp3',
            'A5': 'LLVln_ArcoVib_A5_f.mp3',
            'C6': 'LLVln_ArcoVib_C6_f.mp3',
            'E6': 'LLVln_ArcoVib_E6_f.mp3',
            'G6': 'LLVln_ArcoVib_G6_f.mp3',
            'A6': 'LLVln_ArcoVib_A6_f.mp3',
            'C7': 'LLVln_ArcoVib_C7_f.mp3'
        };
        const VIOLIN_BASE_URL = "/samples/violin/";
        const VIOLIN_RANGE = { min: 'G3', max: 'C7' };  // 小提琴音域

        // === 电吉他采样配置 (来源: lotkey/free-sample-libraries-sfz) ===
        // 完整采样：6音符 × 4力度层 × 2变体 × 2奏法 = 96个文件
        const GUITAR_BASE_URL = "/samples/guitar/";
        const GUITAR_RANGE = { min: 'E2', max: 'E6' };  // 电吉他常用音域
        const GUITAR_NOTES = ['G#1', 'D#2', 'G#2', 'C#3', 'F3', 'A#3'];
        const GUITAR_VELOCITY_LAYERS = 4;  // 力度层数
        const GUITAR_ROUND_ROBINS = 2;     // 变体数

        // 生成完整采样映射
        function buildGuitarSampleMap() {
            const samples = {};
            GUITAR_NOTES.forEach(note => {
                // 文件名中 # 替换为 s (例如 G#1 → Gs1)
                const fileNote = note.replace('#', 's');
                for (let vel = 1; vel <= GUITAR_VELOCITY_LAYERS; vel++) {
                    for (let rr = 1; rr <= GUITAR_ROUND_ROBINS; rr++) {
                        // 普通奏法
                        const key = `${note}_${vel}_${rr}`;
                        samples[key] = `${fileNote}_${vel}_${rr}.mp3`;
                        // 闷音奏法
                        const mutedKey = `${note}_${vel}_${rr}_muted`;
                        samples[mutedKey] = `${fileNote}_${vel}_${rr}_muted.mp3`;
                    }
                }
            });
            return samples;
        }
        const GUITAR_SAMPLES = buildGuitarSampleMap();

        // 电吉他采样器类（支持力度层和 Round Robin）
        class GuitarSamplerEngine {
            constructor() {
                this.buffers = {};      // 所有采样 buffer
                this.loaded = false;
                this.roundRobinIndex = {}; // 每个音符的 round robin 计数器
                this.muted = false;     // 是否使用闷音
            }

            async load(reverb) {
                this.loaded = false;
                const basePath = GUITAR_BASE_URL;

                // 加载所有采样
                const loadPromises = [];
                for (const [key, filename] of Object.entries(GUITAR_SAMPLES)) {
                    const url = basePath + filename;
                    loadPromises.push(
                        Tone.ToneAudioBuffer.fromUrl(url)
                            .then(buffer => { this.buffers[key] = buffer; })
                            .catch(e => console.warn(`吉他采样加载失败: ${filename}`))
                    );
                }

                await Promise.all(loadPromises);
                this.loaded = Object.keys(this.buffers).length > 0;
                console.log(`🎸 电吉他采样加载完成: ${Object.keys(this.buffers).length} 个`);
                this.reverb = reverb;
            }

            // 根据力度选择力度层 (1-4)
            getVelocityLayer(velocity) {
                // velocity: 0-1 映射到 1-4
                if (velocity < 0.25) return 1;
                if (velocity < 0.5) return 2;
                if (velocity < 0.75) return 3;
                return 4;
            }

            // 找到最近的采样音符
            findNearestNote(note) {
                const midi = noteToMidi(note);
                let nearest = GUITAR_NOTES[0];
                let minDist = Infinity;
                for (const n of GUITAR_NOTES) {
                    const d = Math.abs(noteToMidi(n) - midi);
                    if (d < minDist) {
                        minDist = d;
                        nearest = n;
                    }
                }
                return { note: nearest, semitones: midi - noteToMidi(nearest) };
            }

            // 获取 round robin 变体
            getRoundRobin(note) {
                if (!this.roundRobinIndex[note]) this.roundRobinIndex[note] = 0;
                this.roundRobinIndex[note] = (this.roundRobinIndex[note] % GUITAR_ROUND_ROBINS) + 1;
                return this.roundRobinIndex[note];
            }

            // 触发音符
            triggerAttackRelease(note, duration, time, velocity = 0.8) {
                if (!this.loaded) return;

                const { note: sampleNote, semitones } = this.findNearestNote(note);
                const velLayer = this.getVelocityLayer(velocity);
                const rr = this.getRoundRobin(sampleNote);
                const suffix = this.muted ? '_muted' : '';
                const key = `${sampleNote}_${velLayer}_${rr}${suffix}`;

                const buffer = this.buffers[key];
                if (!buffer) return;

                // 创建播放器并调整音高
                const player = new Tone.Player(buffer);
                if (this.reverb) player.connect(this.reverb);
                else player.toDestination();

                // 音高偏移（半音）
                player.playbackRate = Math.pow(2, semitones / 12);
                player.volume.value = Tone.gainToDb(velocity);

                player.start(time);

                // 自动停止和清理
                const actualDuration = Math.min(duration, buffer.duration / player.playbackRate);
                player.stop(time + actualDuration);
                setTimeout(() => player.dispose(), (actualDuration + 0.5) * 1000);
            }

            triggerAttack(note, time, velocity = 0.8) {
                // 简化版：触发后自动衰减
                this.triggerAttackRelease(note, 2, time, velocity);
            }

            triggerRelease(note) {
                // 吉他采样是一次性播放自然衰减，无需手动释放
            }

            releaseAll() {
                // 吉他采样无需特别处理 release
            }
        }

        // === 鼓组配置 (GM Standard Drum Map, MIDI Channel 10) ===
        // GM 标准鼓映射：MIDI 35-81
        const GM_DRUM_MAP = {
            35: 'Acoustic Bass Drum',
            36: 'Bass Drum 1',
            37: 'Side Stick',
            38: 'Acoustic Snare',
            39: 'Hand Clap',
            40: 'Electric Snare',
            41: 'Low Floor Tom',
            42: 'Closed Hi-Hat',
            43: 'High Floor Tom',
            44: 'Pedal Hi-Hat',
            45: 'Low Tom',
            46: 'Open Hi-Hat',
            47: 'Low-Mid Tom',
            48: 'Hi-Mid Tom',
            49: 'Crash Cymbal 1',
            50: 'High Tom',
            51: 'Ride Cymbal 1',
            52: 'Chinese Cymbal',
            53: 'Ride Bell',
            54: 'Tambourine',
            55: 'Splash Cymbal',
            56: 'Cowbell',
            57: 'Crash Cymbal 2',
            69: 'Cabasa',
            70: 'Maracas',
            75: 'Claves',
            76: 'Hi Wood Block',
            77: 'Low Wood Block',
        };

        // DrumKit 类：用 Tone.js 合成器在启动时渲染所有鼓声为 buffer
        // 鼓组预设定义
        const DRUM_PRESETS = {
            // 真实采样鼓组 (The Open Source Drumkit, 4 velocity layers)
            sampled: {
                name: 'Sampled',
                isSampled: true,
                basePath: '/samples/drums/',
                velocityLayers: 4,
                // 每个 MIDI 号映射到 [v1(最轻), v2, v3, v4(最重)] 文件数组，或引用另一个 MIDI 号
                samples: {
                    35: ['kick-v1.mp3', 'kick-v2.mp3', 'kick-v3.mp3', 'kick-v4.mp3'],
                    36: 35,  // Bass Drum 1 → 同 kick
                    37: ['sidestick-v1.mp3', 'sidestick-v2.mp3', 'sidestick-v3.mp3', 'sidestick-v4.mp3'],
                    38: ['snare-v1.mp3', 'snare-v2.mp3', 'snare-v3.mp3', 'snare-v4.mp3'],
                    39: ['rimshot-v1.mp3', 'rimshot-v2.mp3', 'rimshot-v3.mp3', 'rimshot-v4.mp3'],
                    40: 38,  // Electric Snare → 同 snare
                    41: ['tom-low-v1.mp3', 'tom-low-v2.mp3', 'tom-low-v3.mp3', 'tom-low-v4.mp3'],
                    42: ['hihat-closed-v1.mp3', 'hihat-closed-v2.mp3', 'hihat-closed-v3.mp3', 'hihat-closed-v4.mp3'],
                    43: 41,  // High Floor Tom → 同 tom-low
                    44: ['hihat-foot-v1.mp3', 'hihat-foot-v2.mp3', 'hihat-foot-v3.mp3', 'hihat-foot-v4.mp3'],
                    45: ['tom-mid-v1.mp3', 'tom-mid-v2.mp3', 'tom-mid-v3.mp3', 'tom-mid-v4.mp3'],
                    46: ['hihat-open-v1.mp3', 'hihat-open-v2.mp3', 'hihat-open-v3.mp3', 'hihat-open-v4.mp3'],
                    47: 45,  // Low-Mid Tom → 同 tom-mid
                    48: ['tom-high-v1.mp3', 'tom-high-v2.mp3', 'tom-high-v3.mp3', 'tom-high-v4.mp3'],
                    49: ['crash-v1.mp3', 'crash-v2.mp3', 'crash-v3.mp3', 'crash-v4.mp3'],
                    50: 48,  // High Tom → 同 tom-high
                    51: ['ride-v1.mp3', 'ride-v2.mp3', 'ride-v3.mp3', 'ride-v4.mp3'],
                    52: 49,  // Chinese Cymbal → 同 crash
                    53: ['ride-bell-v1.mp3', 'ride-bell-v2.mp3', 'ride-bell-v3.mp3', 'ride-bell-v4.mp3'],
                    55: 49,  // Splash Cymbal → 同 crash
                    57: 49,  // Crash Cymbal 2 → 同 crash
                }
            }
        };

        let currentDrumPreset = 'sampled';

        class DrumKit {
            constructor() {
                this.buffers = {};  // midi -> ToneAudioBuffer
                this.ready = false;
                this.currentPreset = 'sampled';
            }

            async init(presetKey = 'sampled') {
                this.ready = false;
                this.currentPreset = presetKey;
                this.buffers = {};
                const preset = DRUM_PRESETS[presetKey];
                if (!preset) return;

                // 采样模式：加载多力度层 WAV 文件
                if (preset.isSampled) {
                    const fileCache = {};  // 缓存已加载文件
                    // 先处理引用关系，将数字引用解析为实际文件数组
                    const resolvedSamples = {};
                    for (const [midiStr, value] of Object.entries(preset.samples)) {
                        const midi = parseInt(midiStr);
                        if (typeof value === 'number') {
                            resolvedSamples[midi] = { ref: value };
                        } else {
                            resolvedSamples[midi] = { files: value };
                        }
                    }
                    // 先加载所有非引用的采样
                    for (const [midi, entry] of Object.entries(resolvedSamples)) {
                        if (entry.ref !== undefined) continue;
                        const layers = [];
                        for (const filename of entry.files) {
                            try {
                                if (fileCache[filename]) {
                                    layers.push(fileCache[filename]);
                                } else {
                                    const buffer = await Tone.ToneAudioBuffer.fromUrl(preset.basePath + filename);
                                    fileCache[filename] = buffer;
                                    layers.push(buffer);
                                }
                            } catch(e) {
                                console.warn(`采样加载失败: ${filename}`, e);
                                layers.push(null);
                            }
                        }
                        this.buffers[midi] = layers;
                    }
                    // 再处理引用
                    for (const [midi, entry] of Object.entries(resolvedSamples)) {
                        if (entry.ref === undefined) continue;
                        this.buffers[midi] = this.buffers[entry.ref] || [];
                    }
                } else {
                    // 合成模式：渲染合成器声音
                    for (const [midiStr, config] of Object.entries(preset.synths)) {
                        const midi = parseInt(midiStr);
                        const duration = Math.max(config.decay || 0.3, config.noiseDecay || 0) + 0.15;
                        try {
                            const buffer = await Tone.Offline(() => {
                                this.renderDrumSound(config, Tone.now());
                            }, duration);
                            this.buffers[midi] = buffer;
                        } catch(e) {
                            console.warn(`鼓声渲染失败 MIDI ${midi}:`, e);
                        }
                    }
                }
                this.ready = true;
                console.log(`鼓组 [${preset.name}] 初始化完成: ${Object.keys(this.buffers).length} 个鼓声`);
            }

            async switchPreset(presetKey) {
                if (presetKey === this.currentPreset && this.ready) return;
                console.log(`切换鼓组预设: ${DRUM_PRESETS[presetKey]?.name || presetKey}`);
                await this.init(presetKey);
                currentDrumPreset = presetKey;
            }

            renderDrumSound(config, time) {
                switch (config.type) {
                    case 'kick': {
                        const synth = new Tone.MembraneSynth({
                            pitchDecay: config.pitchDecay || 0.05,
                            octaves: config.octaves || 6,
                            oscillator: { type: 'sine' },
                            envelope: { attack: 0.001, decay: config.decay, sustain: 0, release: 0.1 }
                        }).toDestination();
                        synth.triggerAttackRelease(config.freq, config.decay, time);
                        break;
                    }
                    case 'snare': {
                        const membrane = new Tone.MembraneSynth({
                            pitchDecay: 0.01,
                            octaves: 4,
                            envelope: { attack: 0.001, decay: config.toneDecay, sustain: 0, release: 0.05 }
                        }).toDestination();
                        membrane.triggerAttackRelease(config.freq, config.toneDecay, time);
                        const noise = new Tone.NoiseSynth({
                            noise: { type: config.noiseType || 'white' },
                            envelope: { attack: 0.001, decay: config.noiseDecay, sustain: 0, release: 0.05 }
                        }).toDestination();
                        noise.triggerAttackRelease(config.noiseDecay, time);
                        break;
                    }
                    case 'hihat': {
                        const metal = new Tone.MetalSynth({
                            frequency: 300,
                            envelope: { attack: 0.001, decay: config.decay, release: 0.01 },
                            harmonicity: 5.1,
                            modulationIndex: 32,
                            resonance: config.resonance || 4000,
                            octaves: 1.5,
                            volume: -10
                        }).toDestination();
                        metal.triggerAttackRelease('16n', time);
                        break;
                    }
                    case 'tom': {
                        const synth = new Tone.MembraneSynth({
                            pitchDecay: 0.03,
                            octaves: 4,
                            oscillator: { type: 'sine' },
                            envelope: { attack: 0.001, decay: config.decay, sustain: 0, release: 0.1 }
                        }).toDestination();
                        synth.triggerAttackRelease(config.freq, config.decay, time);
                        break;
                    }
                    case 'cymbal': {
                        const metal = new Tone.MetalSynth({
                            frequency: config.freq || 400,
                            envelope: { attack: 0.001, decay: config.decay, release: 0.1 },
                            harmonicity: 5.1,
                            modulationIndex: 24,
                            resonance: 3000,
                            octaves: 1.5,
                            volume: -8
                        }).toDestination();
                        metal.triggerAttackRelease('4n', time);
                        break;
                    }
                    case 'clap': {
                        for (let i = 0; i < 3; i++) {
                            const noise = new Tone.NoiseSynth({
                                noise: { type: 'white' },
                                envelope: { attack: 0.001, decay: config.decay * 0.5, sustain: 0, release: 0.02 }
                            }).toDestination();
                            noise.triggerAttackRelease(config.decay, time + i * 0.01);
                        }
                        break;
                    }
                    case 'cowbell': {
                        const synth = new Tone.MetalSynth({
                            frequency: config.freq,
                            envelope: { attack: 0.001, decay: config.decay, release: 0.01 },
                            harmonicity: 2,
                            modulationIndex: 4,
                            resonance: 1200,
                            octaves: 0.5,
                            volume: -6
                        }).toDestination();
                        synth.triggerAttackRelease('16n', time);
                        break;
                    }
                    case 'stick': {
                        const synth = new Tone.Synth({
                            oscillator: { type: 'triangle' },
                            envelope: { attack: 0.001, decay: config.decay, sustain: 0, release: 0.01 }
                        }).toDestination();
                        synth.triggerAttackRelease(config.freq, config.decay, time);
                        break;
                    }
                    case 'tambourine':
                    case 'shaker': {
                        const noise = new Tone.NoiseSynth({
                            noise: { type: 'white' },
                            envelope: { attack: 0.001, decay: config.decay, sustain: 0, release: 0.02 }
                        }).toDestination();
                        const filter = new Tone.Filter(6000, 'highpass').toDestination();
                        noise.connect(filter);
                        noise.triggerAttackRelease(config.decay, time);
                        break;
                    }
                }
            }

            trigger(midi, time, velocity = 1.0) {
                if (!this.ready) return;
                let buf = this.buffers[midi];
                if (!buf) {
                    buf = this.findNearest(midi);
                    if (!buf) return;
                }
                // 力度层选择：数组形式 [v1(轻), v2, v3, v4(重)]
                if (Array.isArray(buf)) {
                    const layerCount = buf.length;
                    const idx = Math.min(Math.floor(velocity * layerCount), layerCount - 1);
                    const selected = buf[idx];
                    if (selected) this.playBuffer(selected, time, velocity);
                } else {
                    this.playBuffer(buf, time, velocity);
                }
            }

            playBuffer(buffer, time, velocity) {
                const player = new Tone.Player(buffer).toDestination();
                player.volume.value = Tone.gainToDb(velocity);
                player.start(time);
                player.onstop = () => { player.dispose(); };
            }

            findNearest(midi) {
                const keys = Object.keys(this.buffers).map(Number).sort((a, b) => a - b);
                if (keys.length === 0) return null;
                let closest = keys[0];
                let minDist = Math.abs(midi - closest);
                for (const k of keys) {
                    const d = Math.abs(midi - k);
                    if (d < minDist) { minDist = d; closest = k; }
                }
                // 返回整个值（可能是数组或单个 buffer）
                return this.buffers[closest];
            }

            getDrumName(midi) {
                return GM_DRUM_MAP[midi] || `Drum ${midi}`;
            }
        }

        // === 人声采样预设配置 ===
        const VOICE_PRESETS = {
            'default': {
                name: '默认女声',
                path: '/samples/girl/',
                range: { min: 'C4', max: 'C5' },
                notes: ['C4', 'Db4', 'D4', 'Eb4', 'E4', 'F4', 'Gb4', 'G4', 'Ab4', 'A4', 'Bb4', 'B4', 'C5']
            },
            'test_7d': {
                name: 'Test 7D',
                path: '/samples/test_7d/',
                range: { min: 'C4', max: 'C5' },
                notes: ['C4', 'Db4', 'D4', 'Eb4', 'E4', 'F4', 'Gb4', 'G4', 'Ab4', 'A4', 'Bb4', 'B4', 'C5']
            },
            'test_chenshuang': {
                name: 'Test 尘霜',
                path: '/samples/test_chenshuang/',
                range: { min: 'C4', max: 'C5' },
                notes: ['C4', 'Db4', 'D4', 'Eb4', 'E4', 'F4', 'Gb4', 'G4', 'Ab4', 'A4', 'Bb4', 'B4', 'C5']
            },
            '7d_chunri': {
                name: '7D 春日',
                path: '/samples/7d_chunri/',
                range: { min: 'C4', max: 'C5' },
                notes: ['C4', 'Db4', 'D4', 'Eb4', 'E4', 'F4', 'Gb4', 'G4', 'Ab4', 'A4', 'Bb4', 'B4', 'C5']
            },
            'humming': {
                name: '哼唱',
                path: '/samples/humming/',
                range: { min: 'C4', max: 'C5' },
                notes: ['C4', 'Db4', 'D4', 'Eb4', 'E4', 'F4', 'Gb4', 'G4', 'Ab4', 'A4', 'Bb4', 'B4', 'C5']
            }
        };
        let currentVoicePreset = 'default';

        // 严格模式：只有实际采样的音符才用人声
        let VOICE_SAMPLED_NOTES = new Set(['C4', 'Db4', 'D4', 'Eb4', 'E4', 'F4', 'Gb4', 'G4', 'Ab4', 'A4', 'Bb4', 'B4', 'C5']);

        // === 人性化预设 ===
        const HUMANIZE_PRESETS = {
            'none': { name: '无（纯量化）', timing: 0, velocity: 0, duration: 0 },
            'subtle': { name: '轻微', timing: 5, velocity: 5, duration: 0.03 },
            'natural': { name: '自然', timing: 12, velocity: 10, duration: 0.05 },
            'loose': { name: '松散', timing: 20, velocity: 15, duration: 0.08 },
            'swing': { name: '摇摆', timing: 10, velocity: 8, duration: 0.03, swingAmount: 0.2 },
            'laid_back': { name: '慵懒', timing: 8, velocity: 8, duration: 0.05, globalOffset: 10 }
        };
        let currentHumanizePreset = 'none';

        // 人声采样映射
        const VOICE_SAMPLES = {
            'C4': 'C4.mp3',
            'Db4': 'Db4.mp3',
            'D4': 'D4.mp3',
            'Eb4': 'Eb4.mp3',
            'E4': 'E4.mp3',
            'F4': 'F4.mp3',
            'Gb4': 'Gb4.mp3',
            'G4': 'G4.mp3',
            'Ab4': 'Ab4.mp3',
            'A4': 'A4.mp3',
            'Bb4': 'Bb4.mp3',
            'B4': 'B4.mp3',
            'C5': 'C5.mp3'
        };
        const VOICE_BASE_URL = "/samples/girl/";

        function formatTime(ms) {
            const s = Math.floor(ms / 1000);
            return `${Math.floor(s / 60).toString().padStart(2, '0')}:${(s % 60).toString().padStart(2, '0')}`;
        }

        // === 键位映射 ===
        const DEFAULT_KEYMAP = {
            'z': 'C3', 's': 'C#3', 'x': 'D3', 'd': 'D#3', 'c': 'E3', 'v': 'F3', 'g': 'F#3', 'b': 'G3', 'h': 'G#3', 'n': 'A3', 'j': 'A#3', 'm': 'B3',
            'q': 'C4', '2': 'C#4', 'w': 'D4', '3': 'D#4', 'e': 'E4', 'r': 'F4', '5': 'F#4', 't': 'G4', '6': 'G#4', 'y': 'A4', '7': 'A#4', 'u': 'B4', 'i': 'C5'
        };
        let keyMap = { ...DEFAULT_KEYMAP }; 
        let octaveShift = 0; 
        let bindingNote = null;

        // ★★★ 验证按键是否合法（只允许单个可打印字符）★★★
        function isValidKey(key) {
            return key.length === 1 && /^[a-z0-9]$/i.test(key);
        }

        function loadKeyMap() {
            try {
                const saved = localStorage.getItem('sv_piano_keymap');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    // ★★★ 完全替换，不是合并 ★★★
                    keyMap = {};
                    for (const [key, note] of Object.entries(parsed)) {
                        if (isValidKey(key)) {
                            keyMap[key.toLowerCase()] = note;
                        }
                    }
                    // 如果加载的键位为空，使用默认
                    if (Object.keys(keyMap).length === 0) {
                        keyMap = { ...DEFAULT_KEYMAP };
                    }
                } else {
                    keyMap = { ...DEFAULT_KEYMAP };
                }
            } catch (e) {
                keyMap = { ...DEFAULT_KEYMAP };
            }
            renderKeyLabels();
        }

        function saveKeyMap() { 
            localStorage.setItem('sv_piano_keymap', JSON.stringify(keyMap)); 
            renderKeyLabels(); 
        }

        function renderKeyLabels() {
            // 清除所有标签
            document.querySelectorAll('.key-label').forEach(el => el.remove());
            
            // 重新渲染
            for (const [key, baseNote] of Object.entries(keyMap)) {
                if (!isValidKey(key)) continue;
                
                const shiftedNote = shiftNoteOctave(baseNote, octaveShift);
                const keyEl = document.querySelector(`.key[data-note="${shiftedNote}"]`);
                if (keyEl) {
                    let label = keyEl.querySelector('.key-label');
                    if (!label) { 
                        label = document.createElement('div'); 
                        label.className = 'key-label'; 
                        keyEl.appendChild(label); 
                    }
                    const displayKey = key.toUpperCase();
                    // ★★★ 每个琴键只显示一个绑定键 ★★★
                    label.innerText = displayKey;
                }
            }
        }

        function shiftNoteOctave(note, shift) {
            const match = note.match(/^([A-G]#?)(\d+)$/);
            return match ? match[1] + (parseInt(match[2]) + shift) : note;
        }

        function updateOctaveDisplay() {
            document.getElementById('octave-display').innerText = `Octave: ${octaveShift > 0 ? '+' : ''}${octaveShift}`;
            renderKeyLabels();
        }

        function startBind(note) {
            bindingNote = note;
            document.getElementById('targetBindNote').innerText = note;
            document.getElementById('bindOverlay').classList.add('active');
            
            const bindHandler = (e) => {
                e.preventDefault(); 
                e.stopPropagation();
                
                if (e.key === 'Escape') { 
                    cancelBind(); 
                    return; 
                }
                
                const key = e.key.toLowerCase();
                
                // 只接受合法的单字符按键
                if (!isValidKey(key)) {
                    // 忽略特殊键，继续等待
                    window.addEventListener('keydown', bindHandler, { once: true });
                    return;
                }
                
                const baseNote = shiftNoteOctave(note, -octaveShift);
                
                // ★★★ 关键修复：先删除所有绑定到这个音符的旧键 ★★★
                for (const [existingKey, existingNote] of Object.entries(keyMap)) {
                    if (existingNote === baseNote) {
                        delete keyMap[existingKey];
                    }
                }
                
                // ★★★ 如果这个键已经绑定了其他音符，也要删除 ★★★
                // （这样可以防止一个键绑定多个音符）
                if (keyMap[key]) {
                    delete keyMap[key];
                }
                
                // 设置新绑定
                keyMap[key] = baseNote;
                
                saveKeyMap(); 
                cancelBind(); 
            };
            
            window.addEventListener('keydown', bindHandler, { once: true });
        }

        function cancelBind() { 
            document.getElementById('bindOverlay').classList.remove('active'); 
            bindingNote = null; 
        }

        window.addEventListener('keydown', (e) => {
            if (bindingNote || e.repeat || e.target.tagName === 'INPUT') return;
            const key = e.key.toLowerCase();
            if (key === ']') { octaveShift = Math.min(2, octaveShift + 1); updateOctaveDisplay(); return; }
            if (key === '[') { octaveShift = Math.max(-2, octaveShift - 1); updateOctaveDisplay(); return; }
            if (key === ' ') { e.preventDefault(); togglePlayPause(); return; }
            if (keyMap[key]) {
                const note = shiftNoteOctave(keyMap[key], octaveShift);
                const keyEl = document.querySelector(`.key[data-note="${note}"]`);
                if (keyEl) startNote(note, keyEl);
            }
        });

        window.addEventListener('keyup', (e) => {
            if (!e.key) return;
            const key = e.key.toLowerCase();
            if (keyMap[key]) stopNote(shiftNoteOctave(keyMap[key], octaveShift));
        });

        document.getElementById('resetMapBtn').addEventListener('click', () => {
            if(confirm('恢复默认键位？')) { 
                localStorage.removeItem('sv_piano_keymap');
                keyMap = { ...DEFAULT_KEYMAP }; 
                octaveShift = 0; 
                saveKeyMap(); 
                updateOctaveDisplay(); 
            }
        });

        // === 启动 ===
        document.getElementById('startBtn').addEventListener('click', async () => {
            const startBtn = document.getElementById('startBtn');
            const loadingText = document.getElementById('loadingText');
            const loadingBar = document.getElementById('loadingBar');
            const loadingFill = document.getElementById('loadingFill');
            
            startBtn.disabled = true;
            startBtn.style.display = 'none';
            loadingText.style.display = 'block';
            loadingBar.style.display = 'block';
            
            await Tone.start();
            audioContext = Tone.context.rawContext;
            audioStarted = true;
            
            loadingText.innerText = '加载钢琴采样...';
            loadingFill.style.width = '20%';
            
            pianoBuffers = new Tone.ToneAudioBuffers(PIANO_SAMPLES, () => {
                loadingFill.style.width = '80%';
                loadingText.innerText = '初始化...';
                initAudioEngine();
            }, PIANO_BASE_URL);

            let progress = 20;
            const progressInterval = setInterval(() => {
                if (pianoBuffers.loaded) clearInterval(progressInterval);
                else { progress += (80 - progress) * 0.05; loadingFill.style.width = progress + '%'; }
            }, 100);
        });

        // ★★★ 判断音符是否在人声采样的舒适范围内（严格模式）★★★
        function isNoteInVoiceRange(note) {
            const preset = VOICE_PRESETS[currentVoicePreset];
            if (!preset?.range) {
                // 没有 range 配置，使用旧的集合方式
                return VOICE_SAMPLED_NOTES.has(note);
            }

            const midi = noteToMidi(note);
            const minMidi = noteToMidi(preset.range.min);
            const maxMidi = noteToMidi(preset.range.max);

            return midi >= minMidi && midi <= maxMidi;
        }

        // 根据音域范围生成音符列表
        function generateNoteRange(minNote, maxNote) {
            const notes = [];
            let midi = noteToMidi(minNote);
            const maxMidi = noteToMidi(maxNote);

            while (midi <= maxMidi) {
                notes.push(midiToNote(midi));
                midi++;
            }
            return notes;
        }

        // ★★★ 智能选择采样器：人声模式下超出范围自动用钢琴 ★★★
        function getActiveSampler(note = null) {
            if (currentSoundMode === 'drums') {
                return null; // 鼓组使用 DrumKit 类，不返回 sampler
            }
            if (currentSoundMode === 'voice' && note && !isNoteInVoiceRange(note)) {
                return pianoSampler;
            }
            if (currentSoundMode === 'violin' && note && !isNoteInViolinRange(note)) {
                return pianoSampler;
            }
            if (currentSoundMode === 'guitar' && note && !isNoteInGuitarRange(note)) {
                return pianoSampler;
            }
            if (currentSoundMode === 'voice') return voiceSampler;
            if (currentSoundMode === 'violin') return violinSampler;
            if (currentSoundMode === 'guitar') return guitarSampler;
            return pianoSampler;
        }

        // 判断音符是否在小提琴音域内
        function isNoteInViolinRange(note) {
            const midi = noteToMidi(note);
            const minMidi = noteToMidi(VIOLIN_RANGE.min);
            const maxMidi = noteToMidi(VIOLIN_RANGE.max);
            return midi >= minMidi && midi <= maxMidi;
        }

        // 判断音符是否在电吉他音域内
        function isNoteInGuitarRange(note) {
            const midi = noteToMidi(note);
            const minMidi = noteToMidi(GUITAR_RANGE.min);
            const maxMidi = noteToMidi(GUITAR_RANGE.max);
            return midi >= minMidi && midi <= maxMidi;
        }

        async function initAudioEngine() {
            // 初始化 Freeverb AudioWorklet
            const ctx = Tone.getContext().rawContext;
            audioContext = ctx;

            try {
                const blob = new Blob([freeverbProcessorCode], { type: 'application/javascript' });
                const blobUrl = URL.createObjectURL(blob);
                await ctx.audioWorklet.addModule(blobUrl);
                URL.revokeObjectURL(blobUrl);

                reverbWorkletNode = new AudioWorkletNode(ctx, 'freeverb-processor', {
                    numberOfInputs: 1,
                    numberOfOutputs: 1,
                    outputChannelCount: [2]
                });
                reverbWorkletNode.connect(ctx.destination);

                // 创建 Tone.js 兼容的包装器
                reverb = Tone.getContext().createGain();
                Tone.connect(reverb, reverbWorkletNode);
                reverb.wet = { value: 0.2 }; // 模拟 Tone.Reverb 接口

                // 发送初始参数
                reverbWorkletNode.port.postMessage({ wet: 0.2 });

                console.log('🎵 Freeverb AudioWorklet 已启用');
            } catch (e) {
                console.warn('AudioWorklet 不可用，回退到 Tone.Reverb:', e);
                reverb = new Tone.Reverb({ decay: 3, preDelay: 0.1 }).toDestination();
                await reverb.generate();
                reverb.wet.value = 0.2;
            }

            pianoSampler = new Tone.Sampler({
                urls: {
                    'A0': pianoBuffers.get('A0'), 'C1': pianoBuffers.get('C1'), 'A1': pianoBuffers.get('A1'),
                    'C2': pianoBuffers.get('C2'), 'A2': pianoBuffers.get('A2'),
                    'C3': pianoBuffers.get('C3'), 'A3': pianoBuffers.get('A3'),
                    'C4': pianoBuffers.get('C4'), 'D#4': pianoBuffers.get('D#4'), 'F#4': pianoBuffers.get('F#4'), 'A4': pianoBuffers.get('A4'),
                    'C5': pianoBuffers.get('C5'), 'D#5': pianoBuffers.get('D#5'), 'F#5': pianoBuffers.get('F#5'), 'A5': pianoBuffers.get('A5'),
                    'C6': pianoBuffers.get('C6'), 'A6': pianoBuffers.get('A6'), 'C7': pianoBuffers.get('C7'), 'C8': pianoBuffers.get('C8')
                },
                release: 1.5  // 松开按键后延音1.5秒
            }).connect(reverb);

            // 人声专用卷积混响（发送-返回路由，避免依赖 Convolver.wet）
            voiceConvolver = new Tone.Convolver();
            voiceReverbSend = new Tone.Gain(0);  // 默认关闭（发送量=0）
            // 异步加载默认 IR
            loadVoiceIRBuffer('derlon_sanctuary');

            // 人声加倍器（PitchShift 双路微移 + Pan + LPF）— 模拟 VoxDoubler/MicroShift
            voiceDoublerGain = new Tone.Gain(0); // 默认关闭（增益=0）

            voiceDoublerL = new Tone.PitchShift({ pitch: -0.035, windowSize: 0.15, delayTime: 0.018 });
            voiceDoublerR = new Tone.PitchShift({ pitch: 0.035, windowSize: 0.15, delayTime: 0.025 });
            voiceDoublerPanL = new Tone.Panner(-0.35);
            voiceDoublerPanR = new Tone.Panner(0.35);
            voiceDoublerLPF = new Tone.Filter({ frequency: 3500, type: 'lowpass', rolloff: -12 });

            // 人声采样：后台预加载（不阻塞启动）
            voiceBuffers = new Tone.ToneAudioBuffers(VOICE_SAMPLES, () => {
                const voiceUrls = {};
                for (const note of Object.keys(VOICE_SAMPLES)) {
                    voiceUrls[note] = voiceBuffers.get(note);
                }
                voiceSampler = new Tone.Sampler({
                    urls: voiceUrls,
                    attack: 0.05,
                    release: 0.8,
                    curve: 'exponential'
                });
                // 默认干声直出，开关控制效果链
                reconnectVoiceSampler();

                // 初始化预设选择器
                initVoicePresetSelector();
                initVoiceEffectsPanel();
                initVoiceClone();
                discoverServerPresets();
                discoverIDBPresets();
            }, VOICE_BASE_URL);

            // 小提琴采样：后台预加载（VSCO 2 CE 真实采样）
            violinBuffers = new Tone.ToneAudioBuffers(VIOLIN_SAMPLES, () => {
                const violinUrls = {};
                for (const note of Object.keys(VIOLIN_SAMPLES)) {
                    violinUrls[note] = violinBuffers.get(note);
                }
                violinSampler = new Tone.Sampler({
                    urls: violinUrls,
                    release: 1.5  // 小提琴延音
                }).connect(reverb);
                console.log('🎻 小提琴采样加载完成');
            }, VIOLIN_BASE_URL);

            // 电吉他采样：后台预加载
            // 电吉他采样：使用自定义引擎支持力度层和 Round Robin
            guitarSampler = new GuitarSamplerEngine();
            guitarSampler.load(reverb).catch(e => console.warn('电吉他加载失败:', e));

            // 鼓组：后台合成初始化
            drumKit = new DrumKit();
            drumKit.init().then(() => {
                console.log('🥁 鼓组合成完成');
                drumKitCache['sampled'] = drumKit;
            }).catch(e => console.warn('鼓组初始化失败:', e));

            document.getElementById('loadingFill').style.width = '100%';
            document.getElementById('loadingText').innerText = '就绪！';
            loadKeyMap();

            setTimeout(() => {
                document.getElementById('startOverlay').style.opacity = '0';
                setTimeout(() => document.getElementById('startOverlay').style.display = 'none', 500);
                // Initialize tour after overlay fades
                setTimeout(() => {
                    window.appTour = new AppTour(TOUR_STEPS);
                    if (!localStorage.getItem('sv_piano_tour_done')) {
                        window.appTour.start();
                    }
                }, 800);
            }, 300);

            statusEl.innerText = '✅ 钢琴就绪（人声/小提琴/电吉他/鼓组后台加载中）';

            // 初始化 MIDI 输入
            initMIDI();

            // 初始化轨道管理器和可视化器
            initVisualizerAndTracks();
        }

        // === 初始化可视化器和轨道管理 ===
        function initVisualizerAndTracks() {
            // 创建实例
            trackManager = new TrackManager();
            visualizer = new FallingNotesVisualizer('fallingNotesCanvas', 'miniPiano');
            pianoRollEditor = new PianoRollEditor(visualizer);
            modalPianoRollEditor = new ModalPianoRollEditor();

            // 可视化器折叠/展开
            const toggleVisualizerBtn = document.getElementById('toggleVisualizerBtn');
            const visualizerWrapper = document.getElementById('visualizerWrapper');

            toggleVisualizerBtn.addEventListener('click', () => {
                visualizerVisible = !visualizerVisible;
                visualizerWrapper.classList.toggle('collapsed', !visualizerVisible);
                toggleVisualizerBtn.innerText = visualizerVisible ? '▼ 折叠' : '▶ 展开';

                // 保存状态
                localStorage.setItem('sv_piano_visualizer_visible', visualizerVisible);

                // 展开时重新调整大小
                if (visualizerVisible) {
                    setTimeout(() => visualizer.resize(), 350);
                }
            });

            // 轨道面板折叠/展开
            const toggleTracksBtn = document.getElementById('toggleTracksBtn');
            const trackList = document.getElementById('trackList');

            toggleTracksBtn.addEventListener('click', () => {
                const isCollapsed = trackList.classList.toggle('collapsed');
                toggleTracksBtn.innerText = isCollapsed ? '▶ 展开' : '▼ 折叠';
            });

            // 恢复可视化器状态
            const savedVisible = localStorage.getItem('sv_piano_visualizer_visible');
            if (savedVisible === 'false') {
                visualizerVisible = false;
                visualizerWrapper.classList.add('collapsed');
                toggleVisualizerBtn.innerText = '▶ 展开';
            }
        }

        // === 量化 ===
        const bpmInput = document.getElementById('bpmInput');
        const quantizeSelect = document.getElementById('quantizeSelect');
        const humanizeSlider = document.getElementById('humanizeSlider');
        const humanizeVal = document.getElementById('humanizeVal');
        const humanizePresetSelect = document.getElementById('humanizePresetSelect');

        humanizeSlider.addEventListener('input', (e) => humanizeVal.innerText = Math.round(e.target.value * 100) + "%");
        humanizePresetSelect.addEventListener('change', (e) => {
            currentHumanizePreset = e.target.value;
        });

        function getBPM() { return parseInt(bpmInput.value) || 120; }
        function getQuarterNoteMs() { return 60000 / getBPM(); }
        function getQuantizeUnitMs() { 
            const q = parseInt(quantizeSelect.value); 
            return q === 0 ? 0 : (getQuarterNoteMs() * 4) / q; 
        }
        
        function smartQuantize(rawVal, unitMs) {
            if (unitMs === 0) return rawVal;
            const strength = parseFloat(humanizeSlider.value);
            const perfectTarget = Math.round(rawVal / unitMs) * unitMs;
            return rawVal + (perfectTarget - rawVal) * strength;
        }

        // === 智能量化系统（用于MIDI导出）===
        function professionalQuantize(events, bpm, gridSize, options = {}) {
            const {
                strength = 1.0,
                alignChords = true,
                removeGhosts = true,
                fixedLength = true,
                humanizePreset = 'none'
            } = options;

            if (gridSize === 0) return events; // 自由模式不量化

            const gridMs = (60000 / bpm) * (4 / gridSize);
            let result = JSON.parse(JSON.stringify(events)); // 深拷贝

            // Step 1: 去除幽灵音符（误触）
            if (removeGhosts) {
                const minDuration = 50;  // 固定50ms，低于此视为误触
                result = result.filter(e => e.duration >= minDuration);
            }

            // Step 2: 和弦对齐（在量化之前做）
            if (alignChords) {
                result = detectAndAlignChords(result, 30);
            }

            // Step 3: 量化
            result = result.map(note => {
                const perfectGrid = Math.round(note.time / gridMs) * gridMs;
                const quantizedTime = note.time + (perfectGrid - note.time) * strength;

                let quantizedDuration = note.duration;
                if (fixedLength) {
                    quantizedDuration = Math.max(
                        Math.round(note.duration / gridMs) * gridMs,
                        gridMs
                    );
                }

                return { ...note, time: quantizedTime, duration: quantizedDuration };
            });

            // Step 4: 人性化（可选）
            if (humanizePreset !== 'none') {
                result = applyHumanize(result, bpm, humanizePreset);
            }

            return result;
        }

        function detectAndAlignChords(events, windowMs = 30) {
            events.sort((a, b) => a.time - b.time);
            const result = [];
            let i = 0;

            while (i < events.length) {
                const chord = [events[i]];
                let j = i + 1;

                while (j < events.length && events[j].time - events[i].time < windowMs) {
                    chord.push(events[j]);
                    j++;
                }

                if (chord.length > 1) {
                    const alignTime = chord[0].time;
                    chord.forEach(note => {
                        result.push({ ...note, time: alignTime });
                    });
                } else {
                    result.push(chord[0]);
                }

                i = j;
            }

            return result;
        }

        function applyHumanize(events, bpm, presetKey) {
            const config = HUMANIZE_PRESETS[presetKey];
            if (!config) return events;

            const beatMs = 60000 / bpm;

            return events.map(e => {
                let timeOffset = (Math.random() - 0.5) * 2 * config.timing;

                // 全局偏移（laid_back）
                if (config.globalOffset) {
                    timeOffset += config.globalOffset;
                }

                // Swing 处理
                if (config.swingAmount) {
                    const beatPosition = (e.time % beatMs) / beatMs;
                    if (beatPosition > 0.4 && beatPosition < 0.6) {
                        timeOffset += beatMs * config.swingAmount * 0.5;
                    }
                }

                // 力度偏移
                const velocityOffset = (Math.random() - 0.5) * 2 * config.velocity;

                // 时值偏移
                const durationScale = 1 + (Math.random() - 0.5) * 2 * config.duration;

                return {
                    ...e,
                    time: Math.max(0, e.time + timeOffset),
                    velocity: Math.min(127, Math.max(1, (e.velocity || 80) + velocityOffset)),
                    duration: e.duration * durationScale
                };
            });
        }

        document.getElementById('metronomeToggle').addEventListener('change', (e) => {
            if (e.target.checked) {
                const clickSynth = new Tone.MembraneSynth({ volume: -10 }).toDestination();
                let beatCount = 0;
                metronomeInterval = setInterval(() => {
                    beatCount = (beatCount % 4) + 1;
                    document.getElementById('beat-indicator').classList.add('on');
                    setTimeout(() => document.getElementById('beat-indicator').classList.remove('on'), 100);
                    clickSynth.triggerAttackRelease(beatCount === 1 ? 'C5' : 'C4', '32n');
                }, getQuarterNoteMs());
            } else { clearInterval(metronomeInterval); }
        });

        document.getElementById('wetSlider').addEventListener('input', (e) => {
            const wet = parseFloat(e.target.value);
            if (reverbWorkletNode) {
                reverbWorkletNode.port.postMessage({ wet });
            } else if (reverb) {
                reverb.wet.value = wet;
            }
            e.target.nextElementSibling.textContent = wet.toFixed(2);
        });
        document.getElementById('decaySlider').addEventListener('input', (e) => {
            e.target.nextElementSibling.textContent = parseFloat(e.target.value).toFixed(1);
        });
        document.getElementById('decaySlider').addEventListener('change', async (e) => {
            const decay = parseFloat(e.target.value);
            // decay 1-10 映射到 roomSize 0.7-0.95
            const roomSize = 0.7 + (decay - 1) / 9 * 0.25;
            if (reverbWorkletNode) {
                reverbWorkletNode.port.postMessage({ roomSize });
            } else if (reverb) {
                reverb.decay = decay;
                await reverb.generate();
            }
        });

        // === 音符转换 ===
        function noteToMidi(n) {
            const ns = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            const m = n.match(/^([A-G]#?)(\d+)$/);
            return m ? ns.indexOf(m[1]) + (parseInt(m[2]) + 1) * 12 : 60;
        }

        function midiToNote(midi) {
            const ns = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
            return ns[midi % 12] + (Math.floor(midi / 12) - 1);
        }

        // === TrackManager 类 ===
        class TrackManager {
            constructor() {
                this.tracks = [];
                this.soloActive = false;
            }

            loadFromMidi(midiData) {
                this.tracks = [];
                let trackIndex = 0;

                midiData.tracks.forEach((track, idx) => {
                    if (track.notes.length === 0) return;

                    // 自动检测轨道乐器
                    const ch = track.channel !== undefined ? track.channel : 0;
                    const trackName = track.name || '';
                    const nameLower = trackName.toLowerCase();

                    // 检测乐器类型
                    let detectedInstrument = 'piano'; // 默认钢琴
                    let defaultName = `轨道 ${trackIndex + 1}`;

                    // 鼓组检测 (MIDI channel 10 = index 9)
                    if (ch === 9 || ch === 10 || /drum|perc|kit/i.test(nameLower)) {
                        detectedInstrument = 'drums';
                        defaultName = `鼓组 ${trackIndex + 1}`;
                    }
                    // 小提琴检测 (包括 voice/人声，默认用小提琴)
                    else if (/violin|viola|cello|fiddle|strings?|弦|小提琴|中提琴|大提琴|voice|vocal|人声|歌|唱/i.test(nameLower)) {
                        detectedInstrument = 'violin';
                        defaultName = `小提琴 ${trackIndex + 1}`;
                    }
                    // 吉他检测
                    else if (/guitar|gtr|吉他/i.test(nameLower)) {
                        detectedInstrument = 'guitar';
                        defaultName = `吉他 ${trackIndex + 1}`;
                    }
                    // 钢琴检测
                    else if (/piano|pno|键盘|钢琴|keyboard|keys/i.test(nameLower)) {
                        detectedInstrument = 'piano';
                        defaultName = `钢琴 ${trackIndex + 1}`;
                    }

                    this.tracks.push({
                        id: trackIndex,
                        name: trackName || defaultName,
                        color: TRACK_COLORS[trackIndex % TRACK_COLORS.length],
                        instrument: detectedInstrument,
                        voicePreset: currentVoicePreset,
                        drumPreset: currentDrumPreset,
                        channel: ch,
                        muted: false,
                        solo: false,
                        volume: 1.0,
                        notes: track.notes.map(n => ({
                            note: midiToNote(n.midi),
                            time: n.time * 1000,
                            duration: n.duration * 1000,
                            midi: n.midi,
                            velocity: Math.round(n.velocity * 127)
                        }))
                    });
                    trackIndex++;
                });

                this.renderTrackList();
                return this.tracks;
            }

            setMuted(trackId, muted) {
                const track = this.tracks.find(t => t.id === trackId);
                if (track) {
                    track.muted = muted;
                    this.updatePlaybackNotes();
                }
            }

            setSolo(trackId, solo) {
                const track = this.tracks.find(t => t.id === trackId);
                if (track) {
                    track.solo = solo;
                    this.soloActive = this.tracks.some(t => t.solo);
                    this.updatePlaybackNotes();
                }
            }

            setInstrument(trackId, instrument) {
                const track = this.tracks.find(t => t.id === trackId);
                if (track) track.instrument = instrument;
            }

            setVolume(trackId, volume) {
                const track = this.tracks.find(t => t.id === trackId);
                if (track) track.volume = volume;
            }

            updatePlaybackNotes() {
                // 更新 recordedEvents 以反映当前的静音/独奏状态
                recordedEvents = this.getActiveNotes();
            }

            getActiveNotes() {
                return this.tracks
                    .filter(t => !t.muted && (!this.soloActive || t.solo))
                    .flatMap(t => t.notes.map(n => ({
                        ...n,
                        trackId: t.id,
                        instrument: t.instrument,
                        volume: t.volume,
                        color: t.color
                    })));
            }

            getAllNotes() {
                return this.tracks.flatMap(t => t.notes.map(n => ({
                    ...n,
                    trackId: t.id,
                    color: t.color,
                    muted: t.muted,
                    solo: t.solo
                })));
            }

            renderTrackList() {
                const container = document.getElementById('trackList');
                const countEl = document.getElementById('trackCount');
                container.innerHTML = '';
                countEl.innerText = this.tracks.length;

                if (this.tracks.length === 0) return;

                // 构建声线选项 HTML
                const voiceOptionsHtml = Object.entries(VOICE_PRESETS).map(([key, p]) =>
                    `<option value="${key}">${p.name}</option>`
                ).join('');
                // 构建鼓组选项 HTML
                const drumOptionsHtml = Object.entries(DRUM_PRESETS).map(([key, p]) =>
                    `<option value="${key}">${p.name}</option>`
                ).join('');

                this.tracks.forEach(track => {
                    const el = document.createElement('div');
                    el.className = 'track-item';
                    el.dataset.trackId = track.id;

                    const showVoicePreset = track.instrument === 'voice';
                    const showDrumPreset = track.instrument === 'drums';

                    el.innerHTML = `
                        <div class="track-color" style="background: ${track.color};"></div>
                        <span class="track-name" title="${track.name}">${track.name}</span>
                        <select class="track-instrument">
                            <option value="piano" ${track.instrument === 'piano' ? 'selected' : ''}>🎹</option>
                            <option value="voice" ${track.instrument === 'voice' ? 'selected' : ''}>🎤</option>
                            <option value="violin" ${track.instrument === 'violin' ? 'selected' : ''}>🎻</option>
                            <option value="guitar" ${track.instrument === 'guitar' ? 'selected' : ''}>🎸</option>
                            <option value="drums" ${track.instrument === 'drums' ? 'selected' : ''}>🥁</option>
                        </select>
                        <button class="btn-mute ${track.muted ? 'active' : ''}">M</button>
                        <button class="btn-solo ${track.solo ? 'active' : ''}">S</button>
                        <input type="range" class="track-volume" min="0" max="1" step="0.1" value="${track.volume}">
                        <div class="track-preset-row" style="${showVoicePreset ? '' : 'display:none;'}">
                            <select class="track-voice-preset">${voiceOptionsHtml}</select>
                        </div>
                        <div class="track-preset-row" style="${showDrumPreset ? '' : 'display:none;'}">
                            <select class="track-drum-preset">${drumOptionsHtml}</select>
                        </div>
                    `;

                    // 设置当前选中的预设
                    const vpSelect = el.querySelector('.track-voice-preset');
                    if (vpSelect && track.voicePreset) vpSelect.value = track.voicePreset;
                    const dpSelect = el.querySelector('.track-drum-preset');
                    if (dpSelect && track.drumPreset) dpSelect.value = track.drumPreset;

                    container.appendChild(el);
                });

                this.bindTrackEvents();
            }

            bindTrackEvents() {
                document.querySelectorAll('.track-item').forEach(item => {
                    const trackId = parseInt(item.dataset.trackId);

                    item.querySelector('.btn-mute').addEventListener('click', (e) => {
                        const btn = e.target;
                        const muted = !btn.classList.contains('active');
                        btn.classList.toggle('active', muted);
                        this.setMuted(trackId, muted);
                    });

                    item.querySelector('.btn-solo').addEventListener('click', (e) => {
                        const btn = e.target;
                        const solo = !btn.classList.contains('active');
                        btn.classList.toggle('active', solo);
                        this.setSolo(trackId, solo);
                        // 更新所有 solo 按钮的视觉状态
                        document.querySelectorAll('.btn-solo').forEach(b => {
                            const tid = parseInt(b.closest('.track-item').dataset.trackId);
                            const t = this.tracks.find(tr => tr.id === tid);
                            b.classList.toggle('active', t?.solo || false);
                        });
                    });

                    item.querySelector('.track-instrument').addEventListener('change', (e) => {
                        const inst = e.target.value;
                        this.setInstrument(trackId, inst);
                        // 显示/隐藏预设下拉框
                        const vpRow = item.querySelector('.track-voice-preset')?.closest('.track-preset-row');
                        const dpRow = item.querySelector('.track-drum-preset')?.closest('.track-preset-row');
                        if (vpRow) vpRow.style.display = inst === 'voice' ? '' : 'none';
                        if (dpRow) dpRow.style.display = inst === 'drums' ? '' : 'none';
                        // 切换到声线/鼓组时自动加载预设
                        const track = this.tracks.find(t => t.id === trackId);
                        if (track && inst === 'voice') {
                            getOrLoadVoiceSampler(track.voicePreset);
                        } else if (track && inst === 'drums') {
                            getOrLoadDrumKit(track.drumPreset);
                        }
                    });

                    // 声线预设切换
                    const vpSelect = item.querySelector('.track-voice-preset');
                    if (vpSelect) {
                        vpSelect.addEventListener('change', (e) => {
                            const track = this.tracks.find(t => t.id === trackId);
                            if (track) {
                                track.voicePreset = e.target.value;
                                getOrLoadVoiceSampler(e.target.value);
                            }
                        });
                    }

                    // 鼓组预设切换
                    const dpSelect = item.querySelector('.track-drum-preset');
                    if (dpSelect) {
                        dpSelect.addEventListener('change', (e) => {
                            const track = this.tracks.find(t => t.id === trackId);
                            if (track) {
                                track.drumPreset = e.target.value;
                                getOrLoadDrumKit(e.target.value);
                            }
                        });
                    }

                    item.querySelector('.track-volume').addEventListener('input', (e) => {
                        this.setVolume(trackId, parseFloat(e.target.value));
                    });
                });
            }

            clear() {
                this.tracks = [];
                this.soloActive = false;
                this.renderTrackList();
            }
        }

        // === FallingNotesVisualizer 类（横向钢琴卷帘） ===
        class FallingNotesVisualizer {
            constructor(canvasId, miniPianoId) {
                this.canvas = document.getElementById(canvasId);
                this.ctx = this.canvas.getContext('2d');
                this.miniPianoId = miniPianoId;

                // 配置
                this.lookAheadTime = 5000;  // 显示前方5秒的音符
                this.pixelsPerMs = 0.15;    // 滚动速度

                // 音域范围 (C2 到 C7，与主钢琴一致)
                this.midiMin = 36;  // C2
                this.midiMax = 96;  // C7
                this.totalKeys = this.midiMax - this.midiMin + 1;

                // 状态
                this.isRunning = false;
                this.currentTime = 0;
                this.tracks = [];
                this.keyPositions = {};  // midi -> { y, height, isBlack }

                // 尺寸
                this.width = 0;
                this.height = 0;

                // 初始化
                this.buildMiniPiano();
                this.resize();
                window.addEventListener('resize', () => this.resize());
            }

            buildMiniPiano() {
                const container = document.getElementById(this.miniPianoId);
                if (!container) return;
                container.innerHTML = '';

                const containerHeight = container.getBoundingClientRect().height || 500;
                const keyHeight = containerHeight / this.totalKeys;

                // 从高音到低音排列（上面是高音）
                for (let midi = this.midiMax; midi >= this.midiMin; midi--) {
                    const note = midiToNote(midi);
                    const isBlack = note.includes('#');
                    const y = (this.midiMax - midi) * keyHeight;

                    const keyEl = document.createElement('div');
                    keyEl.className = `mini-key ${isBlack ? 'black' : 'white'}`;
                    keyEl.dataset.midi = midi;
                    keyEl.style.top = y + 'px';
                    keyEl.style.height = keyHeight + 'px';

                    // 只在 C 音上显示标签
                    if (note.startsWith('C') && !isBlack) {
                        keyEl.innerText = note;
                    }

                    container.appendChild(keyEl);

                    // 保存位置信息
                    this.keyPositions[midi] = {
                        y: y,
                        height: keyHeight,
                        isBlack: isBlack
                    };
                }
            }

            resize() {
                const wrapper = this.canvas.parentElement;
                if (!wrapper) return;

                const dpr = window.devicePixelRatio || 1;
                const rect = wrapper.getBoundingClientRect();

                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(dpr, dpr);

                this.width = rect.width;
                this.height = rect.height;

                // 重建键位映射（高度可能变化）
                const keyHeight = this.height / this.totalKeys;
                for (let midi = this.midiMax; midi >= this.midiMin; midi--) {
                    const note = midiToNote(midi);
                    const isBlack = note.includes('#');
                    const y = (this.midiMax - midi) * keyHeight;

                    this.keyPositions[midi] = {
                        y: y,
                        height: keyHeight,
                        isBlack: isBlack
                    };
                }

                // 更新迷你钢琴
                this.updateMiniPianoSize();

                // 如果不在运行，渲染一帧静态画面
                if (!this.isRunning && this.tracks.length > 0) {
                    this.render();
                }
            }

            updateMiniPianoSize() {
                const container = document.getElementById(this.miniPianoId);
                if (!container) return;

                const keyHeight = this.height / this.totalKeys;
                container.querySelectorAll('.mini-key').forEach(keyEl => {
                    const midi = parseInt(keyEl.dataset.midi);
                    const y = (this.midiMax - midi) * keyHeight;
                    keyEl.style.top = y + 'px';
                    keyEl.style.height = keyHeight + 'px';
                });
            }

            setTracks(tracks) {
                this.tracks = tracks;
            }

            start(startTimeMs = 0) {
                this.currentTime = startTimeMs;
                this.isRunning = true;
                this.lastFrameTime = performance.now();
                this.animate();
            }

            pause() {
                this.isRunning = false;
            }

            stop() {
                this.isRunning = false;
                this.currentTime = 0;
                this.clear();
                this.clearMiniPianoHighlights();
            }

            seek(timeMs) {
                this.currentTime = timeMs;
                if (!this.isRunning) this.render();
            }

            animate() {
                if (!this.isRunning) return;

                const now = performance.now();
                const delta = now - this.lastFrameTime;
                this.lastFrameTime = now;

                this.currentTime += delta;
                this.render();

                requestAnimationFrame(() => this.animate());
            }

            render() {
                // 编辑模式下由 PianoRollEditor 负责渲染
                if (pianoRollEditor && pianoRollEditor.enabled) {
                    pianoRollEditor.editScrollX = this.currentTime - 200;
                    pianoRollEditor.renderEdit();
                    return;
                }

                this.clear();
                this.clearMiniPianoHighlights();

                if (this.tracks.length === 0) return;

                const visibleStart = this.currentTime - 500;  // 显示已过去的音符
                const visibleEnd = this.currentTime + this.lookAheadTime;

                // 绘制网格线（可选）
                this.drawGridLines();

                // 绘制每个轨道的音符
                this.tracks.forEach(track => {
                    track.notes.forEach(note => {
                        const noteEnd = note.time + note.duration;
                        if (noteEnd < visibleStart || note.time > visibleEnd) return;

                        this.drawNote(note, track.color, track.muted);

                        // 高亮正在播放的音符对应的迷你钢琴键
                        if (note.time <= this.currentTime && noteEnd > this.currentTime && !track.muted) {
                            this.highlightMiniKey(note.midi, track.color);
                        }
                    });
                });

                // 绘制播放线（左侧垂直线）
                this.drawPlayLine();
            }

            drawGridLines() {
                const ctx = this.ctx;

                // 每个音符行的细线
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
                ctx.lineWidth = 0.5;
                for (let midi = this.midiMin; midi <= this.midiMax; midi++) {
                    const pos = this.keyPositions[midi];
                    if (pos) {
                        ctx.beginPath();
                        ctx.moveTo(0, pos.y);
                        ctx.lineTo(this.width, pos.y);
                        ctx.stroke();
                    }
                }

                // 八度分隔线（更明显）
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                ctx.lineWidth = 1;
                for (let midi = this.midiMin; midi <= this.midiMax; midi += 12) {
                    const pos = this.keyPositions[midi];
                    if (pos) {
                        ctx.beginPath();
                        ctx.moveTo(0, pos.y);
                        ctx.lineTo(this.width, pos.y);
                        ctx.stroke();
                    }
                }
            }

            drawNote(note, color, muted) {
                const keyInfo = this.keyPositions[note.midi];
                if (!keyInfo) return;

                // 横向：X 是时间，从右往左移动
                // 当前时间在左边（x=0），未来在右边
                const timeUntilHit = note.time - this.currentTime;
                const x = timeUntilHit * this.pixelsPerMs;
                const noteWidth = Math.max(note.duration * this.pixelsPerMs, 4);

                // 如果完全在画布外，跳过
                if (x + noteWidth < 0 || x > this.width) return;

                // Y 位置和高度
                const y = keyInfo.y;
                const height = Math.max(keyInfo.height - 1, 2);

                // 颜色处理
                let noteColor = color;
                if (muted) {
                    noteColor = 'rgba(100, 100, 100, 0.3)';
                } else if (keyInfo.isBlack) {
                    noteColor = this.darkenColor(color, 0.15);
                }

                const ctx = this.ctx;
                const glow = 3; // 外发光像素

                if (!muted) {
                    // 外层发光（半透明扩散）
                    ctx.fillStyle = this.colorWithAlpha(noteColor, 0.2);
                    ctx.fillRect(x - glow, y + 0.5 - glow, noteWidth + glow * 2, height + glow * 2);

                    // 中层边框（较深色）
                    ctx.fillStyle = this.darkenColor(color, 0.25);
                    ctx.fillRect(x - 1, y + 0.5 - 1, noteWidth + 2, height + 2);
                }

                // 主体填充
                ctx.fillStyle = noteColor;
                ctx.fillRect(x, y + 0.5, noteWidth, height);

                // 接近播放线时添加发光效果
                if (timeUntilHit < 50 && timeUntilHit > -50 && !muted) {
                    ctx.shadowColor = color;
                    ctx.shadowBlur = 12;
                    ctx.fillRect(x, y + 0.5, noteWidth, height);
                    ctx.shadowBlur = 0;
                }
            }

            roundRect(x, y, w, h, r) {
                if (w < 2 * r) r = w / 2;
                if (h < 2 * r) r = h / 2;
                this.ctx.moveTo(x + r, y);
                this.ctx.arcTo(x + w, y, x + w, y + h, r);
                this.ctx.arcTo(x + w, y + h, x, y + h, r);
                this.ctx.arcTo(x, y + h, x, y, r);
                this.ctx.arcTo(x, y, x + w, y, r);
                this.ctx.closePath();
            }

            drawPlayLine() {
                // 左侧垂直播放线
                this.ctx.strokeStyle = 'rgba(255, 105, 180, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.beginPath();
                this.ctx.moveTo(2, 0);
                this.ctx.lineTo(2, this.height);
                this.ctx.stroke();

                // 发光效果
                this.ctx.shadowColor = '#ff69b4';
                this.ctx.shadowBlur = 10;
                this.ctx.stroke();
                this.ctx.shadowBlur = 0;
            }

            highlightMiniKey(midi, color) {
                const container = document.getElementById(this.miniPianoId);
                if (!container) return;

                const keyEl = container.querySelector(`.mini-key[data-midi="${midi}"]`);
                if (keyEl) {
                    keyEl.classList.add('active');
                    keyEl.style.background = `linear-gradient(90deg, ${color} 0%, ${this.lightenColor(color, 0.3)} 100%)`;
                }
            }

            clearMiniPianoHighlights() {
                const container = document.getElementById(this.miniPianoId);
                if (!container) return;

                container.querySelectorAll('.mini-key.active').forEach(keyEl => {
                    keyEl.classList.remove('active');
                    const isBlack = keyEl.classList.contains('black');
                    keyEl.style.background = '';
                });
            }

            darkenColor(hex, amount) {
                const num = parseInt(hex.slice(1), 16);
                const r = Math.max(0, (num >> 16) - Math.round(255 * amount));
                const g = Math.max(0, ((num >> 8) & 0x00FF) - Math.round(255 * amount));
                const b = Math.max(0, (num & 0x0000FF) - Math.round(255 * amount));
                return `rgb(${r}, ${g}, ${b})`;
            }

            lightenColor(hex, amount) {
                const num = parseInt(hex.slice(1), 16);
                const r = Math.min(255, (num >> 16) + Math.round(255 * amount));
                const g = Math.min(255, ((num >> 8) & 0x00FF) + Math.round(255 * amount));
                const b = Math.min(255, (num & 0x0000FF) + Math.round(255 * amount));
                return `rgb(${r}, ${g}, ${b})`;
            }

            colorWithAlpha(colorStr, alpha) {
                // 支持 hex (#rrggbb) 和 rgb() 格式
                if (colorStr.startsWith('#')) {
                    const num = parseInt(colorStr.slice(1), 16);
                    return `rgba(${num >> 16}, ${(num >> 8) & 0xFF}, ${num & 0xFF}, ${alpha})`;
                }
                if (colorStr.startsWith('rgb(')) {
                    return colorStr.replace('rgb(', 'rgba(').replace(')', `, ${alpha})`);
                }
                return colorStr;
            }

            clear() {
                this.ctx.clearRect(0, 0, this.width, this.height);
            }
        }

        // === 钢琴卷帘编辑器 ===
        class PianoRollEditor {
            constructor(visualizer) {
                this.vis = visualizer;
                this.canvas = visualizer.canvas;
                this.ctx = visualizer.ctx;
                this.enabled = false;
                this.tool = 'select'; // 'select', 'draw', 'erase'

                // 选中状态
                this.selectedNotes = [];  // { trackIdx, noteIdx, note }
                this.hoveredNote = null;  // { trackIdx, noteIdx, note }

                // 拖拽状态
                this.isDragging = false;
                this.isResizing = false;
                this.dragStartX = 0;
                this.dragStartY = 0;
                this.dragOffsetTime = 0;
                this.dragOffsetMidi = 0;
                this.dragOriginals = []; // 原始音符数据备份

                // 框选
                this.isBoxSelecting = false;
                this.boxStart = { x: 0, y: 0 };
                this.boxEnd = { x: 0, y: 0 };

                // 撤销/重做
                this.undoStack = [];
                this.redoStack = [];
                this.maxUndo = 50;

                // 网格吸附
                this.gridSnap = 4; // 1/4 拍
                this.bpm = 120;

                // 编辑时的视图偏移（不依赖播放时间）
                this.editScrollX = 0;  // 以毫秒为单位的水平偏移

                this.bindEvents();
                this.bindToolbar();
            }

            enable() {
                this.enabled = true;
                this.canvas.classList.add('edit-mode');
                document.getElementById('pianoRollToolbar').style.display = 'flex';
                document.getElementById('toggleEditModeBtn').classList.add('active');
                // 在编辑模式下，使用固定视图而不是跟随播放
                this.editScrollX = this.vis.currentTime;
                this.renderEdit();
            }

            disable() {
                this.enabled = false;
                this.selectedNotes = [];
                this.hoveredNote = null;
                this.canvas.classList.remove('edit-mode');
                document.getElementById('pianoRollToolbar').style.display = 'none';
                document.getElementById('toggleEditModeBtn').classList.remove('active');
            }

            toggle() {
                if (this.enabled) this.disable();
                else this.enable();
            }

            // 保存当前状态到撤销栈
            saveState() {
                const state = this.vis.tracks.map(t => ({
                    ...t,
                    notes: t.notes.map(n => ({ ...n }))
                }));
                this.undoStack.push(JSON.stringify(state));
                if (this.undoStack.length > this.maxUndo) this.undoStack.shift();
                this.redoStack = [];
            }

            undo() {
                if (this.undoStack.length === 0) return;
                const currentState = JSON.stringify(this.vis.tracks.map(t => ({
                    ...t, notes: t.notes.map(n => ({ ...n }))
                })));
                this.redoStack.push(currentState);
                const prevState = JSON.parse(this.undoStack.pop());
                this.vis.tracks.forEach((t, i) => {
                    if (prevState[i]) t.notes = prevState[i].notes;
                });
                this.selectedNotes = [];
                this.syncRecordedEvents();
                this.renderEdit();
            }

            redo() {
                if (this.redoStack.length === 0) return;
                const currentState = JSON.stringify(this.vis.tracks.map(t => ({
                    ...t, notes: t.notes.map(n => ({ ...n }))
                })));
                this.undoStack.push(currentState);
                const nextState = JSON.parse(this.redoStack.pop());
                this.vis.tracks.forEach((t, i) => {
                    if (nextState[i]) t.notes = nextState[i].notes;
                });
                this.selectedNotes = [];
                this.syncRecordedEvents();
                this.renderEdit();
            }

            // 同步编辑结果到 recordedEvents
            syncRecordedEvents() {
                if (typeof trackManager !== 'undefined' && trackManager) {
                    recordedEvents = trackManager.getActiveNotes();
                }
            }

            // 坐标转换：鼠标位置 -> 时间和MIDI音符
            canvasToMusicCoords(canvasX, canvasY) {
                const timeMs = this.editScrollX + (canvasX / this.vis.pixelsPerMs);
                const keyHeight = this.vis.height / this.vis.totalKeys;
                const midiNote = this.vis.midiMax - Math.floor(canvasY / keyHeight);
                return { time: Math.max(0, timeMs), midi: Math.max(this.vis.midiMin, Math.min(this.vis.midiMax, midiNote)) };
            }

            // 坐标转换：时间和MIDI -> 画布位置
            musicToCanvasCoords(timeMs, midi) {
                const x = (timeMs - this.editScrollX) * this.vis.pixelsPerMs;
                const keyHeight = this.vis.height / this.vis.totalKeys;
                const y = (this.vis.midiMax - midi) * keyHeight;
                return { x, y, h: keyHeight };
            }

            // 吸附到网格
            snapToGrid(timeMs) {
                if (this.gridSnap === 0) return timeMs;
                const beatMs = 60000 / this.bpm;
                const gridMs = beatMs / (this.gridSnap / 4);
                return Math.round(timeMs / gridMs) * gridMs;
            }

            // 默认音符时长（根据网格）
            getDefaultDuration() {
                if (this.gridSnap === 0) return 250; // 250ms默认
                const beatMs = 60000 / this.bpm;
                return beatMs / (this.gridSnap / 4);
            }

            // 查找鼠标位置下的音符
            hitTest(canvasX, canvasY) {
                const tracks = this.vis.tracks;
                for (let ti = tracks.length - 1; ti >= 0; ti--) {
                    const track = tracks[ti];
                    for (let ni = track.notes.length - 1; ni >= 0; ni--) {
                        const note = track.notes[ni];
                        const pos = this.musicToCanvasCoords(note.time, note.midi);
                        const w = Math.max(note.duration * this.vis.pixelsPerMs, 4);
                        const h = pos.h - 1;

                        if (canvasX >= pos.x && canvasX <= pos.x + w &&
                            canvasY >= pos.y && canvasY <= pos.y + h) {
                            // 检查是否在右边缘（调整大小区域）
                            const isRightEdge = canvasX >= pos.x + w - 6;
                            return { trackIdx: ti, noteIdx: ni, note, isRightEdge };
                        }
                    }
                }
                return null;
            }

            // 检查音符是否在选中列表中
            isSelected(trackIdx, noteIdx) {
                return this.selectedNotes.some(s => s.trackIdx === trackIdx && s.noteIdx === noteIdx);
            }

            bindEvents() {
                const canvas = this.canvas;

                canvas.addEventListener('mousedown', (e) => {
                    if (!this.enabled) return;
                    e.preventDefault();
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (e.button === 2) {
                        // 右键删除
                        const hit = this.hitTest(x, y);
                        if (hit) {
                            this.saveState();
                            this.vis.tracks[hit.trackIdx].notes.splice(hit.noteIdx, 1);
                            this.selectedNotes = this.selectedNotes.filter(
                                s => !(s.trackIdx === hit.trackIdx && s.noteIdx === hit.noteIdx)
                            );
                            this.syncRecordedEvents();
                            this.renderEdit();
                        }
                        return;
                    }

                    if (e.button !== 0) return;

                    if (this.tool === 'select') {
                        const hit = this.hitTest(x, y);
                        if (hit) {
                            if (hit.isRightEdge) {
                                // 拖拽右边缘调整时长
                                if (!this.isSelected(hit.trackIdx, hit.noteIdx)) {
                                    this.selectedNotes = [hit];
                                }
                                this.isResizing = true;
                                this.dragStartX = x;
                                this.dragOriginals = this.selectedNotes.map(s => ({
                                    ...s, origDuration: s.note.duration
                                }));
                            } else {
                                // 选中并准备拖拽
                                if (!e.shiftKey && !this.isSelected(hit.trackIdx, hit.noteIdx)) {
                                    this.selectedNotes = [hit];
                                } else if (e.shiftKey) {
                                    if (this.isSelected(hit.trackIdx, hit.noteIdx)) {
                                        this.selectedNotes = this.selectedNotes.filter(
                                            s => !(s.trackIdx === hit.trackIdx && s.noteIdx === hit.noteIdx)
                                        );
                                    } else {
                                        this.selectedNotes.push(hit);
                                    }
                                }
                                this.isDragging = true;
                                this.dragStartX = x;
                                this.dragStartY = y;
                                this.dragOriginals = this.selectedNotes.map(s => ({
                                    ...s, origTime: s.note.time, origMidi: s.note.midi
                                }));
                            }
                        } else {
                            // 空白区域：开始框选
                            if (!e.shiftKey) this.selectedNotes = [];
                            this.isBoxSelecting = true;
                            this.boxStart = { x, y };
                            this.boxEnd = { x, y };
                        }
                        this.renderEdit();

                    } else if (this.tool === 'draw') {
                        const coords = this.canvasToMusicCoords(x, y);
                        const snappedTime = this.snapToGrid(coords.time);
                        const duration = this.getDefaultDuration();

                        // 找到第一个非空轨道或第一个轨道
                        let targetTrack = 0;
                        if (this.selectedNotes.length > 0) {
                            targetTrack = this.selectedNotes[0].trackIdx;
                        }
                        if (this.vis.tracks.length === 0) {
                            // 没有轨道，创建一个
                            this.vis.tracks.push({
                                id: 0, name: 'Track 1', color: TRACK_COLORS[0],
                                instrument: 'piano', muted: false, solo: false,
                                volume: 1.0, notes: []
                            });
                            if (trackManager) trackManager.tracks = this.vis.tracks;
                        }

                        this.saveState();
                        const newNote = {
                            note: midiToNote(coords.midi),
                            time: snappedTime,
                            duration: duration,
                            midi: coords.midi,
                            velocity: 0.8
                        };
                        this.vis.tracks[targetTrack].notes.push(newNote);
                        const newIdx = this.vis.tracks[targetTrack].notes.length - 1;
                        this.selectedNotes = [{ trackIdx: targetTrack, noteIdx: newIdx, note: newNote }];

                        // 开始拖拽右边缘来设定长度
                        this.isResizing = true;
                        this.dragStartX = x;
                        this.dragOriginals = [{ trackIdx: targetTrack, noteIdx: newIdx, note: newNote, origDuration: duration }];

                        this.syncRecordedEvents();
                        this.renderEdit();

                        // 播放预听
                        this.previewNote(newNote);

                    } else if (this.tool === 'erase') {
                        const hit = this.hitTest(x, y);
                        if (hit) {
                            this.saveState();
                            this.vis.tracks[hit.trackIdx].notes.splice(hit.noteIdx, 1);
                            this.syncRecordedEvents();
                            this.renderEdit();
                        }
                    }
                });

                canvas.addEventListener('mousemove', (e) => {
                    if (!this.enabled) return;
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (this.isDragging && this.dragOriginals.length > 0) {
                        const dx = x - this.dragStartX;
                        const dy = y - this.dragStartY;
                        const dtMs = dx / this.vis.pixelsPerMs;
                        const keyHeight = this.vis.height / this.vis.totalKeys;
                        const dMidi = -Math.round(dy / keyHeight);

                        this.dragOriginals.forEach(orig => {
                            let newTime = orig.origTime + dtMs;
                            if (this.gridSnap > 0) newTime = this.snapToGrid(newTime);
                            newTime = Math.max(0, newTime);
                            const newMidi = Math.max(this.vis.midiMin, Math.min(this.vis.midiMax, orig.origMidi + dMidi));
                            orig.note.time = newTime;
                            orig.note.midi = newMidi;
                            orig.note.note = midiToNote(newMidi);
                        });
                        this.renderEdit();
                    } else if (this.isResizing && this.dragOriginals.length > 0) {
                        const dx = x - this.dragStartX;
                        const dtMs = dx / this.vis.pixelsPerMs;
                        this.dragOriginals.forEach(orig => {
                            let newDur = orig.origDuration + dtMs;
                            if (this.gridSnap > 0) {
                                const beatMs = 60000 / this.bpm;
                                const gridMs = beatMs / (this.gridSnap / 4);
                                newDur = Math.max(gridMs, Math.round(newDur / gridMs) * gridMs);
                            } else {
                                newDur = Math.max(20, newDur);
                            }
                            orig.note.duration = newDur;
                        });
                        this.renderEdit();
                    } else if (this.isBoxSelecting) {
                        this.boxEnd = { x, y };
                        this.renderEdit();
                    } else {
                        // 更新光标
                        const hit = this.hitTest(x, y);
                        this.hoveredNote = hit;
                        if (this.tool === 'select') {
                            if (hit && hit.isRightEdge) {
                                canvas.classList.add('resize-right');
                                canvas.classList.remove('dragging');
                            } else if (hit) {
                                canvas.classList.remove('resize-right');
                                canvas.classList.remove('dragging');
                                canvas.style.cursor = 'grab';
                            } else {
                                canvas.classList.remove('resize-right');
                                canvas.classList.remove('dragging');
                                canvas.style.cursor = 'default';
                            }
                        } else if (this.tool === 'erase') {
                            canvas.style.cursor = hit ? 'pointer' : 'crosshair';
                        }
                    }
                });

                canvas.addEventListener('mouseup', (e) => {
                    if (!this.enabled) return;

                    if (this.isDragging) {
                        if (this.dragOriginals.length > 0 && this.dragOriginals[0].origTime !== undefined) {
                            // 检查是否实际移动了
                            const moved = this.dragOriginals.some(o =>
                                o.note.time !== o.origTime || o.note.midi !== o.origMidi
                            );
                            if (moved) {
                                this.saveState();
                                this.syncRecordedEvents();
                            }
                        }
                        this.isDragging = false;
                        this.dragOriginals = [];
                    }

                    if (this.isResizing) {
                        this.syncRecordedEvents();
                        this.isResizing = false;
                        this.dragOriginals = [];
                    }

                    if (this.isBoxSelecting) {
                        // 完成框选：选中框内所有音符
                        const x1 = Math.min(this.boxStart.x, this.boxEnd.x);
                        const x2 = Math.max(this.boxStart.x, this.boxEnd.x);
                        const y1 = Math.min(this.boxStart.y, this.boxEnd.y);
                        const y2 = Math.max(this.boxStart.y, this.boxEnd.y);

                        if (Math.abs(x2 - x1) > 3 || Math.abs(y2 - y1) > 3) {
                            this.vis.tracks.forEach((track, ti) => {
                                track.notes.forEach((note, ni) => {
                                    const pos = this.musicToCanvasCoords(note.time, note.midi);
                                    const w = Math.max(note.duration * this.vis.pixelsPerMs, 4);
                                    const h = pos.h - 1;
                                    const nx1 = pos.x, nx2 = pos.x + w;
                                    const ny1 = pos.y, ny2 = pos.y + h;
                                    if (nx2 >= x1 && nx1 <= x2 && ny2 >= y1 && ny1 <= y2) {
                                        if (!this.isSelected(ti, ni)) {
                                            this.selectedNotes.push({ trackIdx: ti, noteIdx: ni, note });
                                        }
                                    }
                                });
                            });
                        }
                        this.isBoxSelecting = false;
                        this.renderEdit();
                    }
                });

                // 右键菜单禁止
                canvas.addEventListener('contextmenu', (e) => {
                    if (this.enabled) e.preventDefault();
                });

                // 鼠标滚轮水平滚动
                canvas.addEventListener('wheel', (e) => {
                    if (!this.enabled) return;
                    e.preventDefault();
                    if (e.ctrlKey) {
                        // Ctrl+滚轮: 水平缩放
                        const zoomFactor = e.deltaY > 0 ? 0.85 : 1.18;
                        this.vis.pixelsPerMs = Math.max(0.02, Math.min(1.0, this.vis.pixelsPerMs * zoomFactor));
                    } else if (e.shiftKey) {
                        // Shift+滚轮: 垂直缩放（改变显示的音域范围）
                        // 暂不实现
                    } else {
                        // 普通滚轮: 水平滚动
                        const scrollAmount = e.deltaY / this.vis.pixelsPerMs * 0.5;
                        this.editScrollX = Math.max(0, this.editScrollX + scrollAmount);
                    }
                    this.renderEdit();
                }, { passive: false });

                // 键盘快捷键
                document.addEventListener('keydown', (e) => {
                    if (!this.enabled) return;

                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (this.selectedNotes.length > 0) {
                            this.deleteSelected();
                        }
                    } else if (e.key === 'v' || e.key === 'V') {
                        if (!e.ctrlKey && !e.metaKey) this.setTool('select');
                    } else if (e.key === 'd' || e.key === 'D') {
                        if (!e.ctrlKey && !e.metaKey) this.setTool('draw');
                    } else if (e.key === 'e' || e.key === 'E') {
                        if (!e.ctrlKey && !e.metaKey) this.setTool('erase');
                    } else if (e.key === 'a' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        this.selectAll();
                    } else if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        if (e.shiftKey) this.redo();
                        else this.undo();
                    } else if (e.key === 'y' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        this.redo();
                    }
                });
            }

            bindToolbar() {
                // 编辑模式按钮
                document.getElementById('toggleEditModeBtn')?.addEventListener('click', () => this.toggle());

                // 工具按钮
                document.querySelectorAll('[data-tool]').forEach(btn => {
                    btn.addEventListener('click', () => this.setTool(btn.dataset.tool));
                });

                // 网格吸附
                document.getElementById('prGridSnap')?.addEventListener('change', (e) => {
                    this.gridSnap = parseInt(e.target.value);
                });

                // 缩放按钮
                document.getElementById('zoomInH')?.addEventListener('click', () => {
                    this.vis.pixelsPerMs = Math.min(1.0, this.vis.pixelsPerMs * 1.3);
                    this.renderEdit();
                });
                document.getElementById('zoomOutH')?.addEventListener('click', () => {
                    this.vis.pixelsPerMs = Math.max(0.02, this.vis.pixelsPerMs / 1.3);
                    this.renderEdit();
                });
                document.getElementById('zoomInV')?.addEventListener('click', () => {
                    const wrapper = document.getElementById('visualizerWrapper');
                    const h = wrapper.offsetHeight;
                    wrapper.style.height = Math.min(800, h + 80) + 'px';
                    this.vis.resize();
                    this.vis.buildMiniPiano();
                    this.renderEdit();
                });
                document.getElementById('zoomOutV')?.addEventListener('click', () => {
                    const wrapper = document.getElementById('visualizerWrapper');
                    const h = wrapper.offsetHeight;
                    wrapper.style.height = Math.max(200, h - 80) + 'px';
                    this.vis.resize();
                    this.vis.buildMiniPiano();
                    this.renderEdit();
                });

                // 撤销/重做/删除
                document.getElementById('prUndo')?.addEventListener('click', () => this.undo());
                document.getElementById('prRedo')?.addEventListener('click', () => this.redo());
                document.getElementById('prDeleteSelected')?.addEventListener('click', () => this.deleteSelected());
            }

            setTool(tool) {
                this.tool = tool;
                document.querySelectorAll('[data-tool]').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tool === tool);
                });
                if (tool === 'draw') {
                    this.canvas.style.cursor = 'crosshair';
                } else if (tool === 'erase') {
                    this.canvas.style.cursor = 'crosshair';
                } else {
                    this.canvas.style.cursor = 'default';
                }
            }

            selectAll() {
                this.selectedNotes = [];
                this.vis.tracks.forEach((track, ti) => {
                    track.notes.forEach((note, ni) => {
                        this.selectedNotes.push({ trackIdx: ti, noteIdx: ni, note });
                    });
                });
                this.renderEdit();
            }

            deleteSelected() {
                if (this.selectedNotes.length === 0) return;
                this.saveState();
                // 按 noteIdx 降序排列以避免删除时索引错乱
                const sorted = [...this.selectedNotes].sort((a, b) => {
                    if (a.trackIdx !== b.trackIdx) return b.trackIdx - a.trackIdx;
                    return b.noteIdx - a.noteIdx;
                });
                sorted.forEach(s => {
                    this.vis.tracks[s.trackIdx].notes.splice(s.noteIdx, 1);
                });
                this.selectedNotes = [];
                this.syncRecordedEvents();
                this.renderEdit();
            }

            previewNote(note) {
                try {
                    if (pianoSampler && pianoSampler.loaded) {
                        pianoSampler.triggerAttackRelease(note.note, 0.15, Tone.now(), 0.5);
                    }
                } catch(e) {}
            }

            // 编辑模式的渲染（使用固定视图偏移）
            renderEdit() {
                if (!this.enabled) return;
                const vis = this.vis;
                vis.clear();
                vis.clearMiniPianoHighlights();

                if (vis.tracks.length === 0) return;

                const ctx = vis.ctx;

                // 绘制水平网格线（每个音符）
                const keyHeight = vis.height / vis.totalKeys;
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.03)';
                ctx.lineWidth = 1;
                for (let midi = vis.midiMin; midi <= vis.midiMax; midi++) {
                    const y = (vis.midiMax - midi) * keyHeight;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(vis.width, y);
                    ctx.stroke();
                }

                // 八度线（更明显）
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
                for (let midi = vis.midiMin; midi <= vis.midiMax; midi++) {
                    if (midiToNote(midi).startsWith('C') && !midiToNote(midi).includes('#')) {
                        const y = (vis.midiMax - midi) * keyHeight;
                        ctx.beginPath();
                        ctx.moveTo(0, y);
                        ctx.lineTo(vis.width, y);
                        ctx.stroke();
                    }
                }

                // 绘制垂直网格线（节拍）
                if (this.gridSnap > 0) {
                    const beatMs = 60000 / this.bpm;
                    const gridMs = beatMs / (this.gridSnap / 4);
                    const startBeat = Math.floor(this.editScrollX / gridMs);
                    const endTime = this.editScrollX + vis.width / vis.pixelsPerMs;

                    for (let i = startBeat; ; i++) {
                        const t = i * gridMs;
                        if (t > endTime) break;
                        const x = (t - this.editScrollX) * vis.pixelsPerMs;
                        const isBeat = (i % (this.gridSnap / 4)) === 0;
                        const isBar = (i % (this.gridSnap)) === 0;
                        ctx.strokeStyle = isBar ? 'rgba(255,255,255,0.15)' :
                                          isBeat ? 'rgba(255,255,255,0.08)' :
                                          'rgba(255,255,255,0.04)';
                        ctx.lineWidth = isBar ? 1.5 : 1;
                        ctx.beginPath();
                        ctx.moveTo(x, 0);
                        ctx.lineTo(x, vis.height);
                        ctx.stroke();
                    }
                }

                // 绘制音符
                vis.tracks.forEach((track, ti) => {
                    track.notes.forEach((note, ni) => {
                        const pos = this.musicToCanvasCoords(note.time, note.midi);
                        const w = Math.max(note.duration * vis.pixelsPerMs, 4);
                        const h = Math.max(keyHeight - 1, 2);

                        // 跳过不可见音符
                        if (pos.x + w < 0 || pos.x > vis.width) return;

                        const selected = this.isSelected(ti, ni);
                        const hovered = this.hoveredNote &&
                            this.hoveredNote.trackIdx === ti && this.hoveredNote.noteIdx === ni;

                        // 颜色
                        let color = track.muted ? 'rgba(100,100,100,0.3)' : track.color;
                        const glow = 3;

                        if (!track.muted) {
                            // 外层发光
                            ctx.globalAlpha = selected ? 0.35 : (hovered ? 0.25 : 0.15);
                            ctx.fillStyle = color;
                            ctx.fillRect(pos.x - glow, pos.y + 0.5 - glow, w + glow * 2, h + glow * 2);

                            // 中层边框
                            ctx.globalAlpha = selected ? 0.7 : 0.5;
                            ctx.fillStyle = vis.darkenColor(track.color, 0.25);
                            ctx.fillRect(pos.x - 1, pos.y + 0.5 - 1, w + 2, h + 2);
                        }

                        // 主体填充
                        ctx.globalAlpha = selected ? 0.95 : (hovered ? 0.85 : 0.75);
                        ctx.fillStyle = color;
                        ctx.fillRect(pos.x, pos.y + 0.5, w, h);

                        // 选中时显示亮边框
                        if (selected) {
                            ctx.globalAlpha = 1.0;
                            ctx.strokeStyle = '#a0ffe0';
                            ctx.lineWidth = 1.5;
                            ctx.strokeRect(pos.x, pos.y + 0.5, w, h);
                        }

                        ctx.globalAlpha = 1.0;

                        // 调整大小手柄（选中时显示）
                        if (selected && w > 10) {
                            ctx.fillStyle = 'rgba(255,255,255,0.6)';
                            ctx.fillRect(pos.x + w - 4, pos.y + h * 0.2, 2, h * 0.6);
                        }
                    });
                });

                // 绘制框选框
                if (this.isBoxSelecting) {
                    const x = Math.min(this.boxStart.x, this.boxEnd.x);
                    const y = Math.min(this.boxStart.y, this.boxEnd.y);
                    const w = Math.abs(this.boxEnd.x - this.boxStart.x);
                    const h = Math.abs(this.boxEnd.y - this.boxStart.y);
                    ctx.fillStyle = 'rgba(94, 196, 182, 0.15)';
                    ctx.fillRect(x, y, w, h);
                    ctx.strokeStyle = 'rgba(94, 196, 182, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, w, h);
                }

                // 绘制播放位置线（如果在可见范围内）
                const playX = (vis.currentTime - this.editScrollX) * vis.pixelsPerMs;
                if (playX >= 0 && playX <= vis.width) {
                    ctx.strokeStyle = 'rgba(255, 105, 180, 0.8)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(playX, 0);
                    ctx.lineTo(playX, vis.height);
                    ctx.stroke();
                    ctx.shadowColor = '#ff69b4';
                    ctx.shadowBlur = 8;
                    ctx.stroke();
                    ctx.shadowBlur = 0;
                }
            }
        }

        let pianoRollEditor = null;

        // === 全屏钢琴卷帘编辑器模态窗口 ===
        class ModalPianoRollEditor {
            constructor() {
                this.modal = document.getElementById('pianoRollModal');
                this.canvas = document.getElementById('prmNoteCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.pianoContainer = document.getElementById('prmPianoKeys');
                this.rulerCanvas = document.getElementById('prmTimeRulerCanvas');
                this.rulerCtx = this.rulerCanvas.getContext('2d');
                this.velocityCanvas = document.getElementById('prmVelocityCanvas');
                this.velocityCtx = this.velocityCanvas.getContext('2d');

                // 配置
                this.midiMin = 21;  // A0 (全钢琴范围)
                this.midiMax = 108; // C8
                this.totalKeys = this.midiMax - this.midiMin + 1; // 88键
                this.keyHeight = 18; // 每个键的像素高度（可通过缩放改变）
                this.pixelsPerMs = 0.15;
                this.bpm = 120;
                this.beatsPerBar = 4;
                this.gridSnap = 4;

                // 视图状态
                this.scrollX = 0;
                this.scrollY = 0; // 垂直滚动偏移（像素）
                this.width = 0;
                this.height = 0;
                this.totalHeight = this.totalKeys * this.keyHeight; // 虚拟总高度

                // 播放控制
                this.prmIsPlaying = false;
                this.prmIsPaused = false;
                this.prmPlaybackStart = 0;
                this.prmPausedAt = 0;
                this.prmTimeouts = [];
                this.prmAnimId = null;

                // 编辑状态
                this.tool = 'select';
                this.selectedNotes = [];
                this.hoveredNote = null;
                this.hoveredVelocityNote = null;
                this.isDragging = false;
                this.isResizing = false;
                this.isDraggingVelocity = false;
                this.isBoxSelecting = false;
                this.boxStart = { x: 0, y: 0 };
                this.boxEnd = { x: 0, y: 0 };
                this.dragStartX = 0;
                this.dragStartY = 0;
                this.dragOriginals = [];

                // 撤销/重做
                this.undoStack = [];
                this.redoStack = [];
                this.maxUndo = 50;

                // 轨道数据引用
                this.tracks = [];
                this.keyPositions = {};

                this.isOpen = false;
                this.init();
            }

            init() {
                this.bindModalEvents();
                this.bindToolbarEvents();
                this.bindCanvasEvents();
                this.bindVelocityEvents();
                this.bindKeyboardShortcuts();
                this.bindTransportEvents();
            }

            open() {
                this.modal.classList.add('active');
                this.isOpen = true;

                // 同步数据
                if (visualizer && visualizer.tracks) {
                    this.tracks = visualizer.tracks;
                }

                // 同步 BPM
                const bpmInput = document.getElementById('bpmInput');
                if (bpmInput) {
                    this.bpm = parseInt(bpmInput.value) || 120;
                    document.getElementById('prmBpm').value = this.bpm;
                }

                // 更新时间显示
                this.updateTimeDisplay();

                // 初始化
                setTimeout(() => {
                    this.resize();
                    this.totalHeight = this.totalKeys * this.keyHeight;
                    // 默认滚动到 C4(midi=60) 附近居中
                    const c4Offset = (this.midiMax - 60) * this.keyHeight;
                    this.scrollY = Math.max(0, c4Offset - this.height / 2);
                    this.buildPianoKeys();
                    this.render();
                }, 50);

                document.body.style.overflow = 'hidden';
            }

            close() {
                this.prmStop();
                this.modal.classList.remove('active');
                this.isOpen = false;
                document.body.style.overflow = '';

                // 同步回主可视化器
                if (visualizer) {
                    visualizer.tracks = this.tracks;
                }
                this.syncRecordedEvents();
            }

            resize() {
                const wrapper = this.canvas.parentElement;
                if (!wrapper) return;

                const dpr = window.devicePixelRatio || 1;
                const rect = wrapper.getBoundingClientRect();

                // 主画布
                this.canvas.width = rect.width * dpr;
                this.canvas.height = rect.height * dpr;
                this.ctx.setTransform(1, 0, 0, 1, 0, 0);
                this.ctx.scale(dpr, dpr);
                this.width = rect.width;
                this.height = rect.height;

                // 时间标尺画布 — 钢琴宽度由 CSS 控制(80px)
                const pianoWidth = this.pianoContainer.getBoundingClientRect().width || 80;
                const rulerRow = this.rulerCanvas.closest('.pr-ruler-row');
                const rulerWidth = rulerRow ? rulerRow.getBoundingClientRect().width - pianoWidth : rect.width;
                this.rulerCanvas.width = rulerWidth * dpr;
                this.rulerCanvas.height = 30 * dpr;
                this.rulerCtx.setTransform(1, 0, 0, 1, 0, 0);
                this.rulerCtx.scale(dpr, dpr);

                // 力度画布
                const velRow = this.velocityCanvas.closest('.pr-velocity-row');
                const velWidth = velRow ? velRow.getBoundingClientRect().width - pianoWidth : rect.width;
                this.velocityCanvas.width = velWidth * dpr;
                this.velocityCanvas.height = 80 * dpr;
                this.velocityCtx.setTransform(1, 0, 0, 1, 0, 0);
                this.velocityCtx.scale(dpr, dpr);

                // 更新虚拟总高度
                this.totalHeight = this.totalKeys * this.keyHeight;
                // 限制滚动范围
                this.scrollY = Math.max(0, Math.min(this.scrollY, this.totalHeight - this.height));
            }

            buildPianoKeys() {
                this.pianoContainer.innerHTML = '';
                const kh = this.keyHeight;
                // 设置容器虚拟高度使键能绝对定位
                this.pianoContainer.style.position = 'relative';

                for (let midi = this.midiMax; midi >= this.midiMin; midi--) {
                    const noteName = midiToNote(midi);
                    const isBlack = noteName.includes('#');
                    // 虚拟位置（不含滚动偏移，滚动时用 transform 处理整体偏移）
                    const y = (this.midiMax - midi) * kh;

                    const keyEl = document.createElement('div');
                    keyEl.className = `pr-piano-key ${isBlack ? 'black' : 'white'}`;
                    keyEl.dataset.midi = midi;
                    keyEl.style.top = y + 'px';
                    keyEl.style.height = kh + 'px';

                    // C 音标注
                    if (noteName.startsWith('C') && !isBlack) {
                        keyEl.classList.add('c-note');
                        const label = document.createElement('span');
                        label.className = 'octave-label';
                        label.textContent = noteName;
                        keyEl.appendChild(label);
                    }

                    // 点击预听
                    keyEl.addEventListener('mousedown', () => this.previewMidi(midi));

                    this.pianoContainer.appendChild(keyEl);
                }
                this.syncPianoScroll();
            }

            // 同步钢琴键盘的滚动偏移
            syncPianoScroll() {
                // 使用 CSS transform 滚动钢琴键，比逐个修改 top 高效
                const children = this.pianoContainer.children;
                for (let i = 0; i < children.length; i++) {
                    children[i].style.transform = `translateY(${-this.scrollY}px)`;
                }
            }

            previewMidi(midi) {
                try {
                    const note = midiToNote(midi);
                    if (pianoSampler && pianoSampler.loaded) {
                        pianoSampler.triggerAttackRelease(note, 0.2, Tone.now(), 0.6);
                    }
                } catch(e) {}
            }

            // ========== 渲染 ==========
            renderTimeRuler() {
                const ctx = this.rulerCtx;
                const width = this.rulerCanvas.width / (window.devicePixelRatio || 1);
                const height = 30;

                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#1b1b22';
                ctx.fillRect(0, 0, width, height);

                const beatMs = 60000 / this.bpm;
                const barMs = beatMs * this.beatsPerBar;

                const startTime = this.scrollX;
                const endTime = startTime + width / this.pixelsPerMs;
                const startBar = Math.floor(startTime / barMs);
                const endBar = Math.ceil(endTime / barMs);

                ctx.font = '11px Consolas, Monaco, monospace';
                ctx.textAlign = 'left';

                for (let bar = startBar; bar <= endBar; bar++) {
                    const barTime = bar * barMs;
                    const x = (barTime - this.scrollX) * this.pixelsPerMs;

                    // 小节线
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();

                    // 小节号
                    if (x > 5 && x < width - 30) {
                        ctx.fillStyle = '#aaa';
                        ctx.fillText((bar + 1).toString(), x + 6, 18);
                    }

                    // 节拍细分
                    for (let beat = 1; beat < this.beatsPerBar; beat++) {
                        const beatTime = barTime + beat * beatMs;
                        const beatX = (beatTime - this.scrollX) * this.pixelsPerMs;
                        ctx.strokeStyle = '#383845';
                        ctx.beginPath();
                        ctx.moveTo(beatX, height - 8);
                        ctx.lineTo(beatX, height);
                        ctx.stroke();
                    }
                }
            }

            renderNotes() {
                const ctx = this.ctx;
                ctx.clearRect(0, 0, this.width, this.height);

                ctx.fillStyle = '#141419';
                ctx.fillRect(0, 0, this.width, this.height);

                const kh = this.keyHeight;

                // 水平网格线（只绘制可见区域内的）
                const topMidi = this.midiMax - Math.floor(this.scrollY / kh);
                const bottomMidi = this.midiMax - Math.ceil((this.scrollY + this.height) / kh);
                for (let midi = Math.max(this.midiMin, bottomMidi); midi <= Math.min(this.midiMax, topMidi + 1); midi++) {
                    const y = (this.midiMax - midi) * kh - this.scrollY;
                    const noteName = midiToNote(midi);
                    const isBlack = noteName.includes('#');

                    if (isBlack) {
                        ctx.fillStyle = 'rgba(0, 0, 0, 0.22)';
                        ctx.fillRect(0, y, this.width, kh);
                    }

                    if (noteName.startsWith('C') && !isBlack) {
                        ctx.fillStyle = 'rgba(94, 196, 182, 0.04)';
                        ctx.fillRect(0, y, this.width, kh);
                    }

                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.04)';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.width, y);
                    ctx.stroke();
                }

                // 八度分隔线
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
                ctx.lineWidth = 1;
                for (let oct = 0; oct <= 10; oct++) {
                    const midi = oct * 12; // C0, C1, C2...
                    if (midi < this.midiMin || midi > this.midiMax) continue;
                    const y = (this.midiMax - midi) * kh - this.scrollY;
                    if (y < -10 || y > this.height + 10) continue;
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.width, y);
                    ctx.stroke();
                }

                // 垂直网格线
                this.drawVerticalGrid(ctx);

                // 音符
                this.tracks.forEach((track, ti) => {
                    track.notes.forEach((note, ni) => {
                        this.drawNote(ctx, note, track.color, ti, ni, track.muted);
                    });
                });

                // 框选
                if (this.isBoxSelecting) {
                    const x = Math.min(this.boxStart.x, this.boxEnd.x);
                    const y = Math.min(this.boxStart.y, this.boxEnd.y);
                    const w = Math.abs(this.boxEnd.x - this.boxStart.x);
                    const h = Math.abs(this.boxEnd.y - this.boxStart.y);
                    ctx.fillStyle = 'rgba(94, 196, 182, 0.15)';
                    ctx.fillRect(x, y, w, h);
                    ctx.strokeStyle = 'rgba(94, 196, 182, 0.5)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, w, h);
                }

                // 播放头（编辑器内部播放）
                if (this.prmIsPlaying && !this.prmIsPaused) {
                    const elapsed = Date.now() - this.prmPlaybackStart;
                    const playX = (elapsed - this.scrollX) * this.pixelsPerMs;
                    if (playX >= 0 && playX <= this.width) {
                        ctx.strokeStyle = '#ff6b6b';
                        ctx.lineWidth = 2;
                        ctx.beginPath();
                        ctx.moveTo(playX, 0);
                        ctx.lineTo(playX, this.height);
                        ctx.stroke();
                    }
                }
            }

            drawVerticalGrid(ctx) {
                if (this.gridSnap === 0) return;

                const beatMs = 60000 / this.bpm;
                const barMs = beatMs * this.beatsPerBar;
                const gridMs = beatMs / (this.gridSnap / 4);

                const startTime = this.scrollX;
                const endTime = startTime + this.width / this.pixelsPerMs;
                const startGrid = Math.floor(startTime / gridMs);

                for (let i = startGrid; ; i++) {
                    const t = i * gridMs;
                    if (t > endTime) break;

                    const x = (t - this.scrollX) * this.pixelsPerMs;
                    const isBar = Math.abs(t % barMs) < 1;
                    const isBeat = Math.abs(t % beatMs) < 1;

                    if (isBar) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.15)';
                        ctx.lineWidth = 1;
                    } else if (isBeat) {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.06)';
                        ctx.lineWidth = 0.5;
                    } else {
                        ctx.strokeStyle = 'rgba(255, 255, 255, 0.025)';
                        ctx.lineWidth = 0.5;
                    }

                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, this.height);
                    ctx.stroke();
                }
            }

            drawNote(ctx, note, color, trackIdx, noteIdx, muted) {
                const kh = this.keyHeight;
                const x = (note.time - this.scrollX) * this.pixelsPerMs;
                const y = (this.midiMax - note.midi) * kh - this.scrollY;
                const w = Math.max(note.duration * this.pixelsPerMs, 4);
                const h = Math.max(kh - 1, 2);

                if (x + w < 0 || x > this.width) return;
                if (y + h < 0 || y > this.height) return; // 跳过不可见音符

                const selected = this.isSelected(trackIdx, noteIdx);
                const hovered = this.hoveredNote &&
                    this.hoveredNote.trackIdx === trackIdx &&
                    this.hoveredNote.noteIdx === noteIdx;

                const velocity = note.velocity || 0.8;
                const alpha = muted ? 0.3 : (0.5 + velocity * 0.4);
                const glow = 3;

                if (!muted) {
                    // 外层发光
                    ctx.globalAlpha = selected ? 0.3 : (alpha * 0.3);
                    ctx.fillStyle = color;
                    ctx.fillRect(x - glow, y + 0.5 - glow, w + glow * 2, h + glow * 2);

                    // 中层边框
                    ctx.globalAlpha = selected ? 0.6 : (alpha * 0.7);
                    ctx.fillStyle = this._darkenHex(color, 0.25);
                    ctx.fillRect(x - 1, y + 0.5 - 1, w + 2, h + 2);
                }

                // 主体填充
                ctx.globalAlpha = selected ? 0.95 : (hovered ? 0.85 : alpha);
                ctx.fillStyle = muted ? '#666' : (selected ? '#a0ffe0' : color);
                ctx.fillRect(x, y + 0.5, w, h);

                if (selected) {
                    ctx.strokeStyle = '#a0ffe0';
                    ctx.lineWidth = 1.5;
                    ctx.strokeRect(x, y + 0.5, w, h);

                    if (w > 12) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                        ctx.fillRect(x + w - 4, y + h * 0.2, 2, h * 0.6);
                    }
                }

                ctx.globalAlpha = 1.0;
            }

            _darkenHex(hex, amount) {
                if (!hex.startsWith('#')) return hex;
                const num = parseInt(hex.slice(1), 16);
                const r = Math.max(0, (num >> 16) - Math.round(255 * amount));
                const g = Math.max(0, ((num >> 8) & 0xFF) - Math.round(255 * amount));
                const b = Math.max(0, (num & 0xFF) - Math.round(255 * amount));
                return `rgb(${r},${g},${b})`;
            }

            roundRect(ctx, x, y, w, h, r) {
                ctx.moveTo(x + r, y);
                ctx.lineTo(x + w - r, y);
                ctx.quadraticCurveTo(x + w, y, x + w, y + r);
                ctx.lineTo(x + w, y + h - r);
                ctx.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
                ctx.lineTo(x + r, y + h);
                ctx.quadraticCurveTo(x, y + h, x, y + h - r);
                ctx.lineTo(x, y + r);
                ctx.quadraticCurveTo(x, y, x + r, y);
            }

            renderVelocity() {
                const ctx = this.velocityCtx;
                const width = this.velocityCanvas.width / (window.devicePixelRatio || 1);
                const height = 80;

                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = '#141419';
                ctx.fillRect(0, 0, width, height);

                // 网格线
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.06)';
                ctx.lineWidth = 0.5;
                for (let i = 0.25; i < 1; i += 0.25) {
                    const y = height * (1 - i);
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(width, y);
                    ctx.stroke();
                }

                // 小节线
                const beatMs = 60000 / this.bpm;
                const barMs = beatMs * this.beatsPerBar;
                const startTime = this.scrollX;
                const endTime = startTime + width / this.pixelsPerMs;
                const startBar = Math.floor(startTime / barMs);

                for (let bar = startBar; ; bar++) {
                    const t = bar * barMs;
                    if (t > endTime) break;
                    const x = (t - this.scrollX) * this.pixelsPerMs;
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.12)';
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                }

                // 力度条
                this.tracks.forEach((track, ti) => {
                    if (track.muted) return;

                    track.notes.forEach((note, ni) => {
                        const x = (note.time - this.scrollX) * this.pixelsPerMs;
                        const noteWidth = Math.max(note.duration * this.pixelsPerMs, 4);

                        if (x + noteWidth < 0 || x > width) return;

                        const velocity = note.velocity || 0.8;
                        const barHeight = velocity * (height - 12);
                        const barY = height - barHeight - 6;

                        const selected = this.isSelected(ti, ni);
                        const hovered = this.hoveredVelocityNote &&
                            this.hoveredVelocityNote.trackIdx === ti &&
                            this.hoveredVelocityNote.noteIdx === ni;

                        ctx.fillStyle = selected ? '#a0ffe0' : (hovered ? '#7dd4c8' : '#5ec4b6');

                        const barWidth = Math.min(noteWidth - 2, 8);
                        ctx.fillRect(x + (noteWidth - barWidth) / 2, barY, barWidth, barHeight);
                    });
                });
            }

            render() {
                this.renderTimeRuler();
                this.renderNotes();
                this.renderVelocity();
            }

            // ========== 坐标转换 ==========
            canvasToMusic(canvasX, canvasY) {
                const timeMs = this.scrollX + canvasX / this.pixelsPerMs;
                const kh = this.keyHeight;
                const midi = Math.round(this.midiMax - (canvasY + this.scrollY) / kh);
                return { time: timeMs, midi: Math.max(this.midiMin, Math.min(this.midiMax, midi)) };
            }

            musicToCanvas(timeMs, midi) {
                const x = (timeMs - this.scrollX) * this.pixelsPerMs;
                const kh = this.keyHeight;
                const y = (this.midiMax - midi) * kh - this.scrollY;
                return { x, y, h: kh };
            }

            snapToGrid(timeMs) {
                if (this.gridSnap === 0) return timeMs;
                const beatMs = 60000 / this.bpm;
                const gridMs = beatMs / (this.gridSnap / 4);
                return Math.round(timeMs / gridMs) * gridMs;
            }

            getDefaultDuration() {
                if (this.gridSnap === 0) return 250;
                const beatMs = 60000 / this.bpm;
                return beatMs / (this.gridSnap / 4);
            }

            // ========== 命中测试 ==========
            hitTest(x, y) {
                const kh = this.keyHeight;

                for (let ti = this.tracks.length - 1; ti >= 0; ti--) {
                    const track = this.tracks[ti];
                    for (let ni = track.notes.length - 1; ni >= 0; ni--) {
                        const note = track.notes[ni];
                        const nx = (note.time - this.scrollX) * this.pixelsPerMs;
                        const ny = (this.midiMax - note.midi) * kh - this.scrollY;
                        const nw = Math.max(note.duration * this.pixelsPerMs, 4);
                        const nh = kh;

                        if (x >= nx && x <= nx + nw && y >= ny && y <= ny + nh) {
                            const isRightEdge = x > nx + nw - 8;
                            return { trackIdx: ti, noteIdx: ni, note, isRightEdge };
                        }
                    }
                }
                return null;
            }

            hitTestVelocity(x, y) {
                const height = 80;
                for (let ti = this.tracks.length - 1; ti >= 0; ti--) {
                    const track = this.tracks[ti];
                    if (track.muted) continue;

                    for (let ni = track.notes.length - 1; ni >= 0; ni--) {
                        const note = track.notes[ni];
                        const noteX = (note.time - this.scrollX) * this.pixelsPerMs;
                        const noteWidth = Math.max(note.duration * this.pixelsPerMs, 4);
                        const barWidth = Math.min(noteWidth - 2, 12);
                        const barX = noteX + (noteWidth - barWidth) / 2;

                        if (x >= barX - 4 && x <= barX + barWidth + 4) {
                            return { trackIdx: ti, noteIdx: ni, note };
                        }
                    }
                }
                return null;
            }

            isSelected(trackIdx, noteIdx) {
                return this.selectedNotes.some(s => s.trackIdx === trackIdx && s.noteIdx === noteIdx);
            }

            // ========== 编辑操作 ==========
            saveState() {
                const state = JSON.stringify(this.tracks.map(t => ({
                    ...t,
                    notes: t.notes.map(n => ({ ...n }))
                })));
                this.undoStack.push(state);
                if (this.undoStack.length > this.maxUndo) this.undoStack.shift();
                this.redoStack = [];
            }

            undo() {
                if (this.undoStack.length === 0) return;
                const current = JSON.stringify(this.tracks.map(t => ({ ...t, notes: t.notes.map(n => ({ ...n })) })));
                this.redoStack.push(current);
                const state = this.undoStack.pop();
                const restored = JSON.parse(state);
                this.tracks.forEach((t, i) => {
                    if (restored[i]) t.notes = restored[i].notes;
                });
                this.selectedNotes = [];
                this.syncRecordedEvents();
                this.render();
            }

            redo() {
                if (this.redoStack.length === 0) return;
                const current = JSON.stringify(this.tracks.map(t => ({ ...t, notes: t.notes.map(n => ({ ...n })) })));
                this.undoStack.push(current);
                const state = this.redoStack.pop();
                const restored = JSON.parse(state);
                this.tracks.forEach((t, i) => {
                    if (restored[i]) t.notes = restored[i].notes;
                });
                this.selectedNotes = [];
                this.syncRecordedEvents();
                this.render();
            }

            deleteSelected() {
                if (this.selectedNotes.length === 0) return;
                this.saveState();
                const sorted = [...this.selectedNotes].sort((a, b) => b.noteIdx - a.noteIdx);
                sorted.forEach(sel => {
                    this.tracks[sel.trackIdx].notes.splice(sel.noteIdx, 1);
                });
                this.selectedNotes = [];
                this.syncRecordedEvents();
                this.render();
            }

            selectAll() {
                this.selectedNotes = [];
                this.tracks.forEach((track, ti) => {
                    track.notes.forEach((note, ni) => {
                        this.selectedNotes.push({ trackIdx: ti, noteIdx: ni, note });
                    });
                });
                this.render();
            }

            syncRecordedEvents() {
                recordedEvents = [];
                this.tracks.forEach(track => {
                    if (track.muted) return;
                    track.notes.forEach(note => {
                        recordedEvents.push({
                            note: note.note,
                            time: note.time,
                            duration: note.duration,
                            midi: note.midi,
                            velocity: note.velocity || 0.8,
                            instrument: track.instrument || 'piano'
                        });
                    });
                });
                recordedEvents.sort((a, b) => a.time - b.time);
                totalDuration = recordedEvents.length > 0
                    ? Math.max(...recordedEvents.map(e => e.time + e.duration))
                    : 0;
            }

            // ========== 事件绑定 ==========
            bindModalEvents() {
                document.getElementById('closePianoRollModal')?.addEventListener('click', () => this.close());
                document.getElementById('openPianoRollModalBtn')?.addEventListener('click', () => this.open());

                window.addEventListener('resize', () => {
                    if (this.isOpen) {
                        this.resize();
                        this.buildPianoKeys();
                        this.render();
                    }
                });
            }

            bindToolbarEvents() {
                // 工具按钮
                document.querySelectorAll('[data-prm-tool]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.tool = btn.dataset.prmTool;
                        document.querySelectorAll('[data-prm-tool]').forEach(b => b.classList.remove('active'));
                        btn.classList.add('active');
                    });
                });

                // 网格
                document.getElementById('prmGridSnap')?.addEventListener('change', (e) => {
                    this.gridSnap = parseInt(e.target.value);
                    this.render();
                });

                // BPM
                document.getElementById('prmBpm')?.addEventListener('change', (e) => {
                    this.bpm = parseInt(e.target.value) || 120;
                    const mainBpm = document.getElementById('bpmInput');
                    if (mainBpm) mainBpm.value = this.bpm;
                    this.render();
                });

                // 拍号
                document.getElementById('prmTimeSignature')?.addEventListener('change', (e) => {
                    this.beatsPerBar = parseInt(e.target.value);
                    this.render();
                });

                // 操作按钮
                document.getElementById('prmUndo')?.addEventListener('click', () => this.undo());
                document.getElementById('prmRedo')?.addEventListener('click', () => this.redo());
                document.getElementById('prmDelete')?.addEventListener('click', () => this.deleteSelected());
            }

            bindCanvasEvents() {
                const canvas = this.canvas;

                canvas.addEventListener('mousedown', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    // 右键删除
                    if (e.button === 2) {
                        const hit = this.hitTest(x, y);
                        if (hit) {
                            this.saveState();
                            this.tracks[hit.trackIdx].notes.splice(hit.noteIdx, 1);
                            this.syncRecordedEvents();
                            this.render();
                        }
                        return;
                    }

                    if (this.tool === 'select') {
                        const hit = this.hitTest(x, y);
                        if (hit) {
                            if (!e.shiftKey && !this.isSelected(hit.trackIdx, hit.noteIdx)) {
                                this.selectedNotes = [];
                            }
                            if (!this.isSelected(hit.trackIdx, hit.noteIdx)) {
                                this.selectedNotes.push(hit);
                            }

                            if (hit.isRightEdge) {
                                this.isResizing = true;
                            } else {
                                this.isDragging = true;
                            }

                            this.dragStartX = x;
                            this.dragStartY = y;
                            this.dragOriginals = this.selectedNotes.map(s => ({
                                note: s.note,
                                origTime: s.note.time,
                                origMidi: s.note.midi,
                                origDuration: s.note.duration
                            }));
                            this.saveState();
                        } else {
                            if (!e.shiftKey) this.selectedNotes = [];
                            this.isBoxSelecting = true;
                            this.boxStart = { x, y };
                            this.boxEnd = { x, y };
                        }
                    } else if (this.tool === 'draw') {
                        const coords = this.canvasToMusic(x, y);
                        const time = this.snapToGrid(Math.max(0, coords.time));
                        const duration = this.getDefaultDuration();

                        // 确保有轨道存在
                        if (this.tracks.length === 0) {
                            this.tracks.push({
                                id: 0, name: 'Track 1', color: TRACK_COLORS[0],
                                instrument: 'piano', muted: false, solo: false,
                                volume: 1.0, notes: []
                            });
                            if (trackManager) trackManager.tracks = this.tracks;
                            if (visualizer) visualizer.tracks = this.tracks;
                        }

                        const targetTrack = this.tracks[0];

                        const newNote = {
                            note: midiToNote(coords.midi),
                            time: time,
                            duration: duration,
                            midi: coords.midi,
                            velocity: 0.8
                        };

                        this.saveState();
                        targetTrack.notes.push(newNote);
                        this.selectedNotes = [{ trackIdx: 0, noteIdx: targetTrack.notes.length - 1, note: newNote }];

                        this.isResizing = true;
                        this.dragStartX = x;
                        this.dragOriginals = [{ note: newNote, origDuration: duration }];

                        this.previewMidi(coords.midi);
                        this.syncRecordedEvents();
                        this.render();
                    } else if (this.tool === 'erase') {
                        const hit = this.hitTest(x, y);
                        if (hit) {
                            this.saveState();
                            this.tracks[hit.trackIdx].notes.splice(hit.noteIdx, 1);
                            this.syncRecordedEvents();
                        }
                    }

                    this.render();
                });

                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (this.isDragging) {
                        const dx = x - this.dragStartX;
                        const dy = y - this.dragStartY;
                        const dtMs = dx / this.pixelsPerMs;
                        const dMidi = -Math.round(dy / this.keyHeight);

                        this.dragOriginals.forEach(orig => {
                            let newTime = orig.origTime + dtMs;
                            if (this.gridSnap > 0) newTime = this.snapToGrid(newTime);
                            newTime = Math.max(0, newTime);

                            const newMidi = Math.max(this.midiMin, Math.min(this.midiMax, orig.origMidi + dMidi));
                            orig.note.time = newTime;
                            orig.note.midi = newMidi;
                            orig.note.note = midiToNote(newMidi);
                        });
                        this.render();
                    } else if (this.isResizing) {
                        const dx = x - this.dragStartX;
                        const dtMs = dx / this.pixelsPerMs;

                        this.dragOriginals.forEach(orig => {
                            let newDur = orig.origDuration + dtMs;
                            if (this.gridSnap > 0) {
                                const gridMs = (60000 / this.bpm) / (this.gridSnap / 4);
                                newDur = Math.max(gridMs, Math.round(newDur / gridMs) * gridMs);
                            } else {
                                newDur = Math.max(20, newDur);
                            }
                            orig.note.duration = newDur;
                        });
                        this.render();
                    } else if (this.isBoxSelecting) {
                        this.boxEnd = { x, y };
                        this.render();
                    } else {
                        const hit = this.hitTest(x, y);
                        if (hit !== this.hoveredNote) {
                            this.hoveredNote = hit;
                            canvas.style.cursor = hit ? (hit.isRightEdge ? 'ew-resize' : 'move') : 'crosshair';
                            this.render();
                        }
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    if (this.isBoxSelecting) {
                        const x1 = Math.min(this.boxStart.x, this.boxEnd.x);
                        const y1 = Math.min(this.boxStart.y, this.boxEnd.y);
                        const x2 = Math.max(this.boxStart.x, this.boxEnd.x);
                        const y2 = Math.max(this.boxStart.y, this.boxEnd.y);
                        const kh = this.keyHeight;

                        this.tracks.forEach((track, ti) => {
                            track.notes.forEach((note, ni) => {
                                const nx = (note.time - this.scrollX) * this.pixelsPerMs;
                                const ny = (this.midiMax - note.midi) * kh - this.scrollY;
                                const nw = note.duration * this.pixelsPerMs;
                                const nh = kh;

                                if (nx + nw > x1 && nx < x2 && ny + nh > y1 && ny < y2) {
                                    if (!this.isSelected(ti, ni)) {
                                        this.selectedNotes.push({ trackIdx: ti, noteIdx: ni, note });
                                    }
                                }
                            });
                        });
                    }

                    if (this.isDragging || this.isResizing) {
                        this.syncRecordedEvents();
                    }

                    this.isDragging = false;
                    this.isResizing = false;
                    this.isBoxSelecting = false;
                    this.render();
                });

                canvas.addEventListener('mouseleave', () => {
                    this.hoveredNote = null;
                    this.render();
                });

                canvas.addEventListener('contextmenu', (e) => e.preventDefault());

                canvas.addEventListener('wheel', (e) => {
                    if (!this.isOpen) return;
                    e.preventDefault();

                    if (e.ctrlKey) {
                        // Ctrl+滚轮: 水平缩放
                        const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                        this.pixelsPerMs = Math.max(0.02, Math.min(1.0, this.pixelsPerMs * zoomFactor));
                    } else if (e.shiftKey) {
                        // Shift+滚轮: 水平滚动
                        const scrollAmount = e.deltaY * 2;
                        this.scrollX = Math.max(0, this.scrollX + scrollAmount / this.pixelsPerMs);
                    } else {
                        // 普通滚轮: 垂直滚动
                        this.scrollY = Math.max(0, Math.min(this.totalHeight - this.height, this.scrollY + e.deltaY));
                        this.syncPianoScroll();
                    }
                    this.render();
                }, { passive: false });
            }

            bindVelocityEvents() {
                const canvas = this.velocityCanvas;

                canvas.addEventListener('mousedown', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    const hit = this.hitTestVelocity(x, y);
                    if (hit) {
                        this.saveState();
                        this.isDraggingVelocity = true;
                        this.selectedNotes = [hit];
                        this.updateVelocityFromY(y);
                        this.render();
                    }
                });

                canvas.addEventListener('mousemove', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left;
                    const y = e.clientY - rect.top;

                    if (this.isDraggingVelocity) {
                        this.updateVelocityFromY(y);
                        this.render();
                    } else {
                        const hit = this.hitTestVelocity(x, y);
                        if (hit !== this.hoveredVelocityNote) {
                            this.hoveredVelocityNote = hit;
                            this.renderVelocity();
                        }
                    }
                });

                canvas.addEventListener('mouseup', () => {
                    if (this.isDraggingVelocity) {
                        this.isDraggingVelocity = false;
                        this.syncRecordedEvents();
                    }
                });

                canvas.addEventListener('mouseleave', () => {
                    this.hoveredVelocityNote = null;
                    this.isDraggingVelocity = false;
                    this.renderVelocity();
                });

                canvas.addEventListener('wheel', (e) => {
                    if (!this.isOpen) return;
                    e.preventDefault();
                    const scrollAmount = e.deltaY * 2;
                    this.scrollX = Math.max(0, this.scrollX + scrollAmount / this.pixelsPerMs);
                    this.render();
                }, { passive: false });
            }

            updateVelocityFromY(y) {
                const height = 80;
                let velocity = 1 - (y / (height - 12));
                velocity = Math.max(0.1, Math.min(1.0, velocity));

                this.selectedNotes.forEach(sel => {
                    sel.note.velocity = velocity;
                });

                document.getElementById('prmVelocityDisplay').textContent = Math.round(velocity * 127);
            }

            bindKeyboardShortcuts() {
                document.addEventListener('keydown', (e) => {
                    if (!this.isOpen) return;

                    if (e.key === 'Escape') {
                        this.close();
                        return;
                    }

                    if (e.key === 'Delete' || e.key === 'Backspace') {
                        if (this.selectedNotes.length > 0) {
                            e.preventDefault();
                            this.deleteSelected();
                        }
                    }

                    if (e.key === 'a' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        this.selectAll();
                    }

                    if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
                        e.preventDefault();
                        if (e.shiftKey) this.redo();
                        else this.undo();
                    }

                    if (!e.ctrlKey && !e.metaKey) {
                        if (e.key === 'v' || e.key === 'V') {
                            this.tool = 'select';
                            document.querySelectorAll('[data-prm-tool]').forEach(b => b.classList.remove('active'));
                            document.querySelector('[data-prm-tool="select"]')?.classList.add('active');
                        }
                        if (e.key === 'd' || e.key === 'D') {
                            this.tool = 'draw';
                            document.querySelectorAll('[data-prm-tool]').forEach(b => b.classList.remove('active'));
                            document.querySelector('[data-prm-tool="draw"]')?.classList.add('active');
                        }
                        if (e.key === 'e' || e.key === 'E') {
                            this.tool = 'erase';
                            document.querySelectorAll('[data-prm-tool]').forEach(b => b.classList.remove('active'));
                            document.querySelector('[data-prm-tool="erase"]')?.classList.add('active');
                        }
                    }

                    // Space 播放/暂停
                    if (e.key === ' ') {
                        e.preventDefault();
                        this.prmTogglePlay();
                    }
                });
            }

            // ========== 播放控制 ==========
            bindTransportEvents() {
                document.getElementById('prmPlayBtn')?.addEventListener('click', () => this.prmTogglePlay());
                document.getElementById('prmStopBtn')?.addEventListener('click', () => this.prmStop());

                // 进度条点击跳转
                const progressBg = document.getElementById('prmProgressBg');
                progressBg?.addEventListener('click', (e) => {
                    const rect = progressBg.getBoundingClientRect();
                    const ratio = (e.clientX - rect.left) / rect.width;
                    this.syncRecordedEvents();
                    const seekTo = ratio * totalDuration;
                    if (this.prmIsPlaying) {
                        this.prmStop();
                        this.prmPlay(seekTo);
                    } else {
                        this.prmPausedAt = seekTo;
                        this.updateTimeDisplay(seekTo);
                        this.updateProgressBar(seekTo);
                    }
                });
            }

            prmTogglePlay() {
                if (this.prmIsPlaying && !this.prmIsPaused) {
                    this.prmPause();
                } else if (this.prmIsPaused) {
                    this.prmPlay(this.prmPausedAt);
                } else {
                    this.syncRecordedEvents();
                    this.prmPlay(0);
                }
            }

            prmPlay(startFromMs = 0) {
                this.prmIsPlaying = true;
                this.prmIsPaused = false;
                this.prmPlaybackStart = Date.now() - startFromMs;

                const playBtn = document.getElementById('prmPlayBtn');
                playBtn.innerHTML = '&#9646;&#9646;'; // ⏸
                playBtn.classList.add('playing');

                // 调度所有音符
                const allEvents = this.tracks.flatMap(t =>
                    t.muted ? [] : t.notes.map(n => ({ ...n, instrument: t.instrument || 'piano', volume: t.volume || 1.0, trackId: t.id }))
                );

                allEvents.filter(e => e.time >= startFromMs).forEach(event => {
                    const delay = event.time - startFromMs;
                    this.prmTimeouts.push(setTimeout(() => {
                        if (this.prmIsPlaying && !this.prmIsPaused) {
                            triggerNoteForPlayback(event.note, event.duration, event.instrument, event.volume, event.trackId);
                        }
                    }, delay));
                });

                // 播放结束
                if (totalDuration > 0) {
                    this.prmTimeouts.push(setTimeout(() => {
                        if (this.prmIsPlaying) this.prmStop();
                    }, totalDuration - startFromMs + 100));
                }

                // 动画循环更新播放头和进度
                this.prmAnimate();
            }

            prmPause() {
                this.prmIsPaused = true;
                this.prmPausedAt = Date.now() - this.prmPlaybackStart;
                this.prmTimeouts.forEach(t => clearTimeout(t));
                this.prmTimeouts = [];
                cancelAnimationFrame(this.prmAnimId);

                if (pianoSampler?.loaded) pianoSampler.releaseAll();
                if (voiceSampler?.loaded) voiceSampler.releaseAll();
                if (violinSampler?.loaded) violinSampler.releaseAll();

                const playBtn = document.getElementById('prmPlayBtn');
                playBtn.innerHTML = '&#9654;'; // ▶
                playBtn.classList.remove('playing');
                this.render();
            }

            prmStop() {
                this.prmIsPlaying = false;
                this.prmIsPaused = false;
                this.prmPausedAt = 0;
                this.prmTimeouts.forEach(t => clearTimeout(t));
                this.prmTimeouts = [];
                cancelAnimationFrame(this.prmAnimId);

                if (pianoSampler?.loaded) pianoSampler.releaseAll();
                if (voiceSampler?.loaded) voiceSampler.releaseAll();
                if (violinSampler?.loaded) violinSampler.releaseAll();

                const playBtn = document.getElementById('prmPlayBtn');
                playBtn.innerHTML = '&#9654;'; // ▶
                playBtn.classList.remove('playing');

                this.updateProgressBar(0);
                this.updateTimeDisplay(0);
                this.render();
            }

            prmAnimate() {
                if (!this.prmIsPlaying || this.prmIsPaused) return;
                const elapsed = Date.now() - this.prmPlaybackStart;
                this.updateProgressBar(elapsed);
                this.updateTimeDisplay(elapsed);
                this.renderNotes(); // 重绘以更新播放头
                this.prmAnimId = requestAnimationFrame(() => this.prmAnimate());
            }

            updateProgressBar(elapsed) {
                const fill = document.getElementById('prmProgressFill');
                if (fill && totalDuration > 0) {
                    fill.style.width = Math.min(100, (elapsed / totalDuration) * 100) + '%';
                }
            }

            updateTimeDisplay(elapsed = 0) {
                const display = document.getElementById('prmTimeDisplay');
                if (display) {
                    display.textContent = `${formatTime(elapsed)} / ${formatTime(totalDuration)}`;
                }
            }
        }

        let modalPianoRollEditor = null;

        // === 人声预设切换 ===
        let voicePresetSelectorInited = false;

        // === IndexedDB 声线存储 ===
        const VOICE_DB_NAME = 'web-piano-voices';
        const VOICE_DB_VERSION = 1;

        function openVoiceDB() {
            return new Promise((resolve, reject) => {
                const req = indexedDB.open(VOICE_DB_NAME, VOICE_DB_VERSION);
                req.onupgradeneeded = (e) => {
                    const db = e.target.result;
                    if (!db.objectStoreNames.contains('presets')) {
                        db.createObjectStore('presets', { keyPath: 'key' });
                    }
                };
                req.onsuccess = (e) => resolve(e.target.result);
                req.onerror = (e) => reject(e.target.error);
            });
        }

        async function savePresetToIDB(presetKey, displayName, noteBlobs) {
            const db = await openVoiceDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('presets', 'readwrite');
                tx.objectStore('presets').put({
                    key: presetKey,
                    name: displayName,
                    notes: Object.keys(noteBlobs),
                    samples: noteBlobs,
                    createdAt: Date.now()
                });
                tx.oncomplete = () => { db.close(); resolve(); };
                tx.onerror = (e) => { db.close(); reject(e.target.error); };
            });
        }

        async function getAllIDBPresets() {
            const db = await openVoiceDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('presets', 'readonly');
                const req = tx.objectStore('presets').getAll();
                req.onsuccess = () => { db.close(); resolve(req.result); };
                req.onerror = (e) => { db.close(); reject(e.target.error); };
            });
        }

        async function getIDBPreset(presetKey) {
            const db = await openVoiceDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('presets', 'readonly');
                const req = tx.objectStore('presets').get(presetKey);
                req.onsuccess = () => { db.close(); resolve(req.result); };
                req.onerror = (e) => { db.close(); reject(e.target.error); };
            });
        }

        async function deleteIDBPreset(presetKey) {
            const db = await openVoiceDB();
            return new Promise((resolve, reject) => {
                const tx = db.transaction('presets', 'readwrite');
                tx.objectStore('presets').delete(presetKey);
                tx.oncomplete = () => { db.close(); resolve(); };
                tx.onerror = (e) => { db.close(); reject(e.target.error); };
            });
        }

        // Download WAVs from server path and save to IndexedDB
        async function downloadPresetToIDB(presetKey, displayName, serverPath, noteNames) {
            const noteBlobs = {};
            for (const note of noteNames) {
                const resp = await fetch(`${serverPath}${note}.mp3`);
                if (!resp.ok) throw new Error(`下载 ${note}.wav 失败`);
                noteBlobs[note] = await resp.blob();
            }
            await savePresetToIDB(presetKey, displayName, noteBlobs);
            // Clean up server files
            try { await fetch(`/api/voice-clone/preset/${presetKey}`, { method: 'DELETE' }); } catch (e) {}
        }

        // Load IDB presets into VOICE_PRESETS on startup
        async function discoverIDBPresets() {
            try {
                const presets = await getAllIDBPresets();
                for (const p of presets) {
                    VOICE_PRESETS[p.key] = {
                        name: p.name,
                        source: 'indexeddb',
                        range: { min: 'C4', max: 'C5' },
                        notes: p.notes
                    };
                }
                if (presets.length > 0) initVoicePresetSelector();
            } catch (e) { console.warn('IndexedDB 预设加载失败:', e); }
        }

        // Discover cloned presets from server and merge into VOICE_PRESETS
        async function discoverServerPresets() {
            try {
                const resp = await fetch('/api/voice-presets');
                if (!resp.ok) return;
                const presets = await resp.json();
                for (const p of presets) {
                    if (!VOICE_PRESETS[p.key]) {
                        VOICE_PRESETS[p.key] = {
                            name: p.name || p.key,
                            path: p.path,
                            range: { min: 'C4', max: 'C5' },
                            notes: p.notes
                        };
                    }
                }
                initVoicePresetSelector();
            } catch (e) { console.warn('预设发现失败:', e); }
        }

        function initVoicePresetSelector() {
            const select = document.getElementById('voicePresetSelect');
            const deleteBtn = document.getElementById('voiceDeletePresetBtn');

            // 动态生成选项
            select.innerHTML = '';
            for (const [key, preset] of Object.entries(VOICE_PRESETS)) {
                const option = document.createElement('option');
                option.value = key;
                option.textContent = preset.name + (preset.source === 'indexeddb' ? ' 🎙️' : '');
                select.appendChild(option);
            }

            // 更新删除按钮可见性
            const updateDeleteBtn = () => {
                const cur = VOICE_PRESETS[select.value];
                deleteBtn.style.display = (cur && cur.source === 'indexeddb') ? 'inline-block' : 'none';
            };
            updateDeleteBtn();

            if (!voicePresetSelectorInited) {
                voicePresetSelectorInited = true;
                select.addEventListener('change', (e) => {
                    loadVoicePreset(e.target.value);
                    updateDeleteBtn();
                });
                deleteBtn.addEventListener('click', async () => {
                    const key = select.value;
                    const preset = VOICE_PRESETS[key];
                    if (!preset || preset.source !== 'indexeddb') return;
                    if (!confirm(`确定删除声线「${preset.name}」？此操作不可恢复。`)) return;
                    try {
                        await deleteIDBPreset(key);
                        delete VOICE_PRESETS[key];
                        if (voiceSamplerCache[key]) {
                            try { voiceSamplerCache[key].dispose(); } catch(e) {}
                            delete voiceSamplerCache[key];
                        }
                        initVoicePresetSelector();
                        select.value = 'default';
                        loadVoicePreset('default');
                        statusEl.innerText = `🗑️ 已删除声线: ${preset.name}`;
                    } catch (e) {
                        statusEl.innerText = `❌ 删除失败: ${e.message}`;
                    }
                });
            }
        }

        // === Voice Clone ===
        function initVoiceClone() {
            const cloneBtn = document.getElementById('voiceCloneBtn');
            const modal = document.getElementById('voiceCloneModal');
            const closeBtn = document.getElementById('voiceCloneModalClose');
            const startBtn = document.getElementById('vcStartBtn');
            const fileInput = document.getElementById('vcFileInput');
            const displayInput = document.getElementById('vcDisplayNameInput');
            const progressArea = document.getElementById('vcProgressArea');
            const progressText = document.getElementById('vcProgressText');
            const progressPercent = document.getElementById('vcProgressPercent');
            const progressBar = document.getElementById('vcProgressBar');
            const errorArea = document.getElementById('vcErrorArea');

            // Advanced parameter sliders — wire up value display
            const vcSliders = [
                ['vcDiffusionSteps', 'vcDiffusionStepsVal', v => v],
                ['vcCfgRate', 'vcCfgRateVal', v => parseFloat(v).toFixed(2)],
                ['vcLengthAdjust', 'vcLengthAdjustVal', v => parseFloat(v).toFixed(2)],
                ['vcSemiToneShift', 'vcSemiToneShiftVal', v => (v > 0 ? '+' : '') + v],
            ];
            vcSliders.forEach(([sliderId, valId, fmt]) => {
                const slider = document.getElementById(sliderId);
                const valSpan = document.getElementById(valId);
                slider.addEventListener('input', () => { valSpan.textContent = fmt(slider.value); });
            });

            cloneBtn.addEventListener('click', () => {
                modal.classList.add('active');
                progressArea.style.display = 'none';
                errorArea.style.display = 'none';
                startBtn.disabled = false;
                fileInput.value = '';
            });
            closeBtn.addEventListener('click', () => modal.classList.remove('active'));
            modal.addEventListener('click', (e) => { if (e.target === modal) modal.classList.remove('active'); });

            startBtn.addEventListener('click', async () => {
                const file = fileInput.files[0];
                const displayName = displayInput.value.trim() || `克隆声线 ${new Date().toLocaleString('zh-CN', {month:'numeric',day:'numeric',hour:'numeric',minute:'numeric'})}`;

                if (!file) { errorArea.style.display = 'block'; errorArea.textContent = '请选择参考音频文件'; return; }

                // Disable controls
                startBtn.disabled = true;
                [fileInput, displayInput].forEach(el => el.disabled = true);
                errorArea.style.display = 'none';
                progressArea.style.display = 'block';
                progressText.textContent = '上传中...';
                progressBar.style.width = '0%';
                progressPercent.textContent = '0%';

                const formData = new FormData();
                formData.append('reference', file);
                formData.append('displayName', displayName);
                formData.append('diffusionSteps', document.getElementById('vcDiffusionSteps').value);
                formData.append('cfgRate', document.getElementById('vcCfgRate').value);
                formData.append('lengthAdjust', document.getElementById('vcLengthAdjust').value);
                formData.append('semiToneShift', document.getElementById('vcSemiToneShift').value);
                formData.append('f0Condition', document.getElementById('vcF0Condition').checked);
                formData.append('autoF0Adjust', document.getElementById('vcAutoF0Adjust').checked);

                const resetControls = () => {
                    startBtn.disabled = false;
                    [fileInput, displayInput].forEach(el => el.disabled = false);
                };

                try {
                    const resp = await fetch('/api/voice-clone', { method: 'POST', body: formData });
                    const data = await resp.json();
                    if (!resp.ok) throw new Error(data.error || '上传失败');

                    const evtSource = new EventSource(`/api/voice-clone/progress/${data.jobId}`);

                    evtSource.onmessage = async (event) => {
                        const msg = JSON.parse(event.data);

                        if (msg.error) {
                            evtSource.close();
                            errorArea.style.display = 'block';
                            errorArea.textContent = msg.message;
                            resetControls();
                            return;
                        }

                        if (msg.percent !== undefined) {
                            progressBar.style.width = msg.percent + '%';
                            progressPercent.textContent = msg.percent + '%';
                            progressText.textContent = msg.message || '处理中...';
                        }

                        if (msg.done && msg.result) {
                            evtSource.close();
                            const r = msg.result;
                            progressText.textContent = '保存到本地存储...';
                            progressBar.style.width = '95%';
                            progressPercent.textContent = '95%';

                            try {
                                // Download WAVs to IndexedDB, then delete from server
                                await downloadPresetToIDB(r.preset_key, displayName, r.preset_path, r.notes);

                                VOICE_PRESETS[r.preset_key] = {
                                    name: displayName,
                                    source: 'indexeddb',
                                    range: { min: 'C4', max: 'C5' },
                                    notes: r.notes
                                };
                                initVoicePresetSelector();
                                const select = document.getElementById('voicePresetSelect');
                                select.value = r.preset_key;
                                select.dispatchEvent(new Event('change'));
                                loadVoicePreset(r.preset_key);
                                progressText.textContent = '完成！';
                                progressBar.style.width = '100%';
                                progressPercent.textContent = '100%';
                                statusEl.innerText = `✅ 声线克隆完成: ${displayName}`;
                            } catch (idbErr) {
                                console.error('IDB save failed:', idbErr);
                                // Fallback: keep on server
                                VOICE_PRESETS[r.preset_key] = {
                                    name: displayName,
                                    path: r.preset_path,
                                    range: { min: 'C4', max: 'C5' },
                                    notes: r.notes
                                };
                                initVoicePresetSelector();
                                const select = document.getElementById('voicePresetSelect');
                                select.value = r.preset_key;
                                select.dispatchEvent(new Event('change'));
                                loadVoicePreset(r.preset_key);
                                progressText.textContent = '完成（本地存储失败，使用服务器模式）';
                                progressBar.style.width = '100%';
                                progressPercent.textContent = '100%';
                                statusEl.innerText = `⚠️ 声线已克隆但未保存到本地: ${displayName}`;
                            }
                            setTimeout(() => {
                                modal.classList.remove('active');
                                resetControls();
                            }, 1500);
                        }
                    };

                    evtSource.onerror = () => {
                        evtSource.close();
                        errorArea.style.display = 'block';
                        errorArea.textContent = '连接中断，请检查服务器状态';
                        resetControls();
                    };
                } catch (err) {
                    errorArea.style.display = 'block';
                    errorArea.textContent = err.message;
                    resetControls();
                }
            });
        }

        function initVoiceEffectsPanel() {
            const reverbToggle = document.getElementById('voiceReverbToggle');
            const doublerToggle = document.getElementById('voiceDoublerToggle');
            const irSelect = document.getElementById('voiceIRSelect');
            const reverbParamsPanel = document.getElementById('reverbParamsPanel');
            const doublerParamsPanel = document.getElementById('doublerParamsPanel');

            // Reverb send slider
            const reverbSendSlider = document.getElementById('vcReverbSend');
            const reverbSendVal = document.getElementById('vcReverbSendVal');
            reverbSendSlider.addEventListener('input', () => {
                const v = parseFloat(reverbSendSlider.value);
                reverbSendVal.textContent = v.toFixed(2);
                if (voiceReverbEnabled && voiceReverbSend) voiceReverbSend.gain.value = v;
            });

            // Doubler mix slider
            const doublerMixSlider = document.getElementById('vcDoublerMix');
            const doublerMixVal = document.getElementById('vcDoublerMixVal');
            doublerMixSlider.addEventListener('input', () => {
                const v = parseFloat(doublerMixSlider.value);
                doublerMixVal.textContent = v.toFixed(2);
                if (voiceDoublerEnabled && voiceDoublerGain) voiceDoublerGain.gain.value = v;
            });

            // Doubler pitch slider
            const doublerPitchSlider = document.getElementById('vcDoublerPitch');
            const doublerPitchVal = document.getElementById('vcDoublerPitchVal');
            doublerPitchSlider.addEventListener('input', () => {
                const v = parseFloat(doublerPitchSlider.value);
                doublerPitchVal.textContent = v.toFixed(3);
                if (voiceDoublerL) voiceDoublerL.pitch = -v;
                if (voiceDoublerR) voiceDoublerR.pitch = v;
            });

            // Doubler width slider
            const doublerWidthSlider = document.getElementById('vcDoublerWidth');
            const doublerWidthVal = document.getElementById('vcDoublerWidthVal');
            doublerWidthSlider.addEventListener('input', () => {
                const v = parseFloat(doublerWidthSlider.value);
                doublerWidthVal.textContent = v.toFixed(2);
                if (voiceDoublerPanL) voiceDoublerPanL.pan.value = -v;
                if (voiceDoublerPanR) voiceDoublerPanR.pan.value = v;
            });

            reverbToggle.addEventListener('change', (e) => {
                voiceReverbEnabled = e.target.checked;
                irSelect.style.display = voiceReverbEnabled ? 'inline-block' : 'none';
                reverbParamsPanel.classList.toggle('hidden', !voiceReverbEnabled);
                voiceReverbSend.gain.value = voiceReverbEnabled ? parseFloat(reverbSendSlider.value) : 0;
                statusEl.innerText = voiceReverbEnabled ? '🏛️ 空间混响 已开启' : '🏛️ 空间混响 已关闭';
            });

            irSelect.addEventListener('change', (e) => {
                currentVoiceIR = e.target.value;
                loadVoiceIRBuffer(currentVoiceIR);
            });

            doublerToggle.addEventListener('change', (e) => {
                voiceDoublerEnabled = e.target.checked;
                doublerParamsPanel.style.display = voiceDoublerEnabled ? 'flex' : 'none';
                voiceDoublerGain.gain.value = voiceDoublerEnabled ? parseFloat(doublerMixSlider.value) : 0;
                statusEl.innerText = voiceDoublerEnabled ? '👥 人声加倍 已开启' : '👥 人声加倍 已关闭';
            });
        }

        // 异步加载 IR 脉冲响应文件
        async function loadVoiceIRBuffer(irName) {
            statusEl.innerText = `⏳ 加载空间: ${irName}...`;
            try {
                const oldConvolver = voiceConvolver;
                voiceConvolver = new Tone.Convolver(`/samples/ir/${irName}.mp3`);
                await Tone.loaded();
                reconnectVoiceSampler();
                try { oldConvolver.dispose(); } catch(e) {}
                currentVoiceIR = irName;
                statusEl.innerText = `✅ 已切换空间: ${irName}`;
            } catch (err) {
                console.error('IR 加载失败:', err);
                statusEl.innerText = `❌ 空间加载失败`;
            }
        }

        // 连接人声采样器信号链（发送-返回架构）：
        // sampler → destination（干声直通，始终输出）
        // sampler → reverbSend(增益控制) → convolver → destination（混响湿声）
        // sampler → doublerL → panL ─┐
        //                             ├→ doublerGain → LPF → destination（加倍声）
        // sampler → doublerR → panR ─┘
        function reconnectVoiceSampler() {
            if (!voiceSampler) return;
            try { voiceSampler.disconnect(); } catch(e) {}
            try { voiceReverbSend.disconnect(); } catch(e) {}
            try { voiceConvolver.disconnect(); } catch(e) {}
            try { voiceDoublerGain.disconnect(); } catch(e) {}
            try { voiceDoublerL.disconnect(); } catch(e) {}
            try { voiceDoublerR.disconnect(); } catch(e) {}
            try { voiceDoublerPanL.disconnect(); } catch(e) {}
            try { voiceDoublerPanR.disconnect(); } catch(e) {}
            try { voiceDoublerLPF.disconnect(); } catch(e) {}

            // 干声路径（直通到目标）
            voiceSampler.toDestination();

            // 混响发送-返回路径
            voiceSampler.connect(voiceReverbSend);
            voiceReverbSend.connect(voiceConvolver);
            voiceConvolver.toDestination();

            // 加倍器路径（并行，经低通滤波后输出）
            voiceSampler.connect(voiceDoublerL);
            voiceSampler.connect(voiceDoublerR);
            voiceDoublerL.connect(voiceDoublerPanL);
            voiceDoublerR.connect(voiceDoublerPanR);
            voiceDoublerPanL.connect(voiceDoublerGain);
            voiceDoublerPanR.connect(voiceDoublerGain);
            voiceDoublerGain.connect(voiceDoublerLPF);
            voiceDoublerLPF.toDestination();

            // 应用当前开关状态（读取滑块值）
            const reverbVal = parseFloat(document.getElementById('vcReverbSend')?.value || 0.55);
            const doublerVal = parseFloat(document.getElementById('vcDoublerMix')?.value || 0.25);
            voiceReverbSend.gain.value = voiceReverbEnabled ? reverbVal : 0;
            voiceDoublerGain.gain.value = voiceDoublerEnabled ? doublerVal : 0;
        }

        // Helper: create blob URLs for IDB preset, returns { urls, blobUrls (to revoke later) }
        async function buildIDBBlobUrls(presetKey) {
            const idbData = await getIDBPreset(presetKey);
            if (!idbData || !idbData.samples) throw new Error('IndexedDB 中找不到该预设');
            const urls = {};
            const blobUrls = [];
            for (const note of idbData.notes) {
                const blobUrl = URL.createObjectURL(idbData.samples[note]);
                urls[note] = blobUrl;
                blobUrls.push(blobUrl);
            }
            return { urls, blobUrls };
        }

        async function loadVoicePreset(presetKey) {
            const preset = VOICE_PRESETS[presetKey];
            if (!preset) return;

            currentVoicePreset = presetKey;
            statusEl.innerText = `⏳ 加载音色: ${preset.name}...`;

            // 释放旧的 sampler
            if (voiceSampler) {
                voiceSampler.dispose();
                voiceSampler = null;
            }

            if (preset.source === 'indexeddb') {
                // Load from IndexedDB via blob URLs
                try {
                    const { urls, blobUrls } = await buildIDBBlobUrls(presetKey);
                    voiceBuffers = new Tone.ToneAudioBuffers(urls, () => {
                        blobUrls.forEach(u => URL.revokeObjectURL(u));
                        const samplerUrls = {};
                        for (const note of preset.notes) samplerUrls[note] = voiceBuffers.get(note);
                        voiceSampler = new Tone.Sampler({
                            urls: samplerUrls, attack: 0.05, release: 0.8, curve: 'exponential'
                        });
                        reconnectVoiceSampler();
                        voiceSamplerCache[presetKey] = voiceSampler;
                        VOICE_SAMPLED_NOTES.clear();
                        preset.notes.forEach(n => VOICE_SAMPLED_NOTES.add(n));
                        statusEl.innerText = `✅ 已切换到: ${preset.name}`;
                    });
                } catch (e) {
                    console.error('IDB preset load failed:', e);
                    statusEl.innerText = `❌ 加载失败: ${e.message}`;
                }
            } else {
                // Load from server URL
                const urls = {};
                for (const note of preset.notes) urls[note] = `${note}.mp3`;
                voiceBuffers = new Tone.ToneAudioBuffers(urls, () => {
                    const samplerUrls = {};
                    for (const note of preset.notes) samplerUrls[note] = voiceBuffers.get(note);
                    voiceSampler = new Tone.Sampler({
                        urls: samplerUrls, attack: 0.05, release: 0.8, curve: 'exponential'
                    });
                    reconnectVoiceSampler();
                    voiceSamplerCache[presetKey] = voiceSampler;
                    VOICE_SAMPLED_NOTES.clear();
                    preset.notes.forEach(n => VOICE_SAMPLED_NOTES.add(n));
                    statusEl.innerText = `✅ 已切换到: ${preset.name}`;
                }, preset.path);
            }
        }

        // === 轨道专用采样器/鼓组缓存管理 ===
        async function getOrLoadVoiceSampler(presetKey) {
            if (voiceSamplerCache[presetKey]) return voiceSamplerCache[presetKey];
            const preset = VOICE_PRESETS[presetKey];
            if (!preset) return voiceSampler; // fallback 到全局

            statusEl.innerText = `⏳ 加载声线: ${preset.name}...`;

            if (preset.source === 'indexeddb') {
                const { urls, blobUrls } = await buildIDBBlobUrls(presetKey);
                return new Promise((resolve) => {
                    const buffers = new Tone.ToneAudioBuffers(urls, () => {
                        blobUrls.forEach(u => URL.revokeObjectURL(u));
                        const samplerUrls = {};
                        for (const note of preset.notes) samplerUrls[note] = buffers.get(note);
                        const sampler = new Tone.Sampler({
                            urls: samplerUrls, attack: 0.05, release: 0.8, curve: 'exponential'
                        }).toDestination();
                        voiceSamplerCache[presetKey] = sampler;
                        statusEl.innerText = `✅ 声线已加载: ${preset.name}`;
                        resolve(sampler);
                    });
                });
            }

            const urls = {};
            for (const note of preset.notes) urls[note] = `${note}.mp3`;
            return new Promise((resolve) => {
                const buffers = new Tone.ToneAudioBuffers(urls, () => {
                    const samplerUrls = {};
                    for (const note of preset.notes) samplerUrls[note] = buffers.get(note);
                    const sampler = new Tone.Sampler({
                        urls: samplerUrls, attack: 0.05, release: 0.8, curve: 'exponential'
                    }).toDestination();
                    voiceSamplerCache[presetKey] = sampler;
                    statusEl.innerText = `✅ 声线已加载: ${preset.name}`;
                    resolve(sampler);
                }, preset.path);
            });
        }

        async function getOrLoadDrumKit(presetKey) {
            if (drumKitCache[presetKey]) return drumKitCache[presetKey];
            const preset = DRUM_PRESETS[presetKey];
            if (!preset) return drumKit; // fallback 到全局

            statusEl.innerText = `⏳ 加载鼓组: ${preset.name}...`;
            const kit = new DrumKit();
            await kit.init(presetKey);
            drumKitCache[presetKey] = kit;
            statusEl.innerText = `✅ 鼓组已加载: ${preset.name}`;
            return kit;
        }

        // === MIDI 输入支持 ===
        async function initMIDI() {
            if (!navigator.requestMIDIAccess) {
                console.log('浏览器不支持 Web MIDI API');
                updateMIDIStatus(false);
                return;
            }
            try {
                midiAccess = await navigator.requestMIDIAccess();
                midiAccess.inputs.forEach(input => {
                    input.onmidimessage = handleMIDIMessage;
                });
                midiAccess.onstatechange = onMIDIStateChange;
                updateMIDIStatus(midiAccess.inputs.size > 0);
            } catch (err) {
                console.error('MIDI 初始化失败:', err);
                updateMIDIStatus(false);
            }
        }

        function onMIDIStateChange(event) {
            // 设备连接/断开时重新绑定
            if (midiAccess) {
                midiAccess.inputs.forEach(input => {
                    input.onmidimessage = handleMIDIMessage;
                });
                updateMIDIStatus(midiAccess.inputs.size > 0);
            }
        }

        function updateMIDIStatus(connected) {
            const midiStatusEl = document.getElementById('midiStatus');
            if (midiStatusEl) {
                if (connected) {
                    let deviceName = '已连接';
                    if (midiAccess && midiAccess.inputs.size > 0) {
                        const firstInput = midiAccess.inputs.values().next().value;
                        deviceName = firstInput.name || '已连接';
                    }
                    midiStatusEl.innerText = '✓ ' + deviceName;
                    midiStatusEl.style.color = '#2ed573';
                } else {
                    midiStatusEl.innerText = '未连接';
                    midiStatusEl.style.color = '#aaa';
                }
            }
        }

        function handleMIDIMessage(event) {
            const [status, data1, data2] = event.data;
            const command = status >> 4;

            if (command === 9 && data2 > 0) {
                // Note On
                const note = midiToNote(data1);
                const velocity = data2;  // 0-127
                const keyEl = document.querySelector(`.key[data-note="${note}"]`);
                if (keyEl) startNote(note, keyEl, velocity);
            } else if (command === 8 || (command === 9 && data2 === 0)) {
                // Note Off
                stopNote(midiToNote(data1));
            } else if (command === 11 && data1 === 64) {
                // CC 64: Sustain Pedal
                setSustainPedal(data2 >= 64);
            }
        }

        function setSustainPedal(isDown) {
            sustainPedal = isDown;
            if (isDown) {
                // 踏板按下：增强混响
                if (reverb) reverb.wet.value = Math.min(1, reverb.wet.value + 0.2);
            } else {
                // 踏板释放：恢复混响，释放所有延音音符
                if (reverb) reverb.wet.value = parseFloat(document.getElementById('wetSlider').value);
                for (const note of Object.keys(sustainedNotes)) {
                    const sampler = getActiveSampler(note);
                    if (sampler?.loaded) sampler.triggerRelease(note);
                }
                sustainedNotes = {};
            }
        }

        // === 演奏 ===
        function startNote(note, keyElement, velocity = 100) {
            if (!audioStarted || activeNotes[note]) return;
            keyElement.classList.add('active');
            activeNotes[note] = { startTime: Date.now(), element: keyElement, velocity: velocity };

            if (currentSoundMode === 'drums' && drumKit?.ready) {
                const midi = noteToMidi(note);
                const volumeLinear = 0.1 + (velocity / 127) * 0.9;
                drumKit.trigger(midi, Tone.now(), volumeLinear);
            } else {
                const sampler = getActiveSampler(note);
                if (sampler?.loaded) {
                    const volumeLinear = 0.1 + (velocity / 127) * 0.9;
                    sampler.triggerAttack(note, Tone.now(), volumeLinear);
                }
            }
        }

        function stopNote(note) {
            if (!activeNotes[note]) return;
            const info = activeNotes[note];
            info.element.classList.remove('active');

            // 鼓组不需要释放（一次性触发）
            if (currentSoundMode !== 'drums') {
                if (sustainPedal) {
                    sustainedNotes[note] = true;
                } else {
                    const sampler = getActiveSampler(note);
                    if (sampler?.loaded) sampler.triggerRelease(note);
                }
            }

            if (isRecording) {
                const rawTime = info.startTime - recordingStartTime;
                const rawDur = Date.now() - info.startTime;
                const unit = getQuantizeUnitMs();
                let finalTime = rawTime, finalDur = rawDur;
                if (unit > 0) {
                    finalTime = smartQuantize(rawTime, unit);
                    finalDur = smartQuantize(rawDur, unit);
                    if (finalDur < getQuarterNoteMs() / 8) finalDur = getQuarterNoteMs() / 8;
                }
                recordedEvents.push({
                    note,
                    time: finalTime,
                    duration: finalDur,
                    midi: noteToMidi(note),
                    velocity: info.velocity || 100
                });
            }
            delete activeNotes[note];
        }

        function triggerNoteForPlayback(note, durationMs, instrument = 'piano', volume = 1.0, trackId = null) {
            // 实时检查轨道是否被静音/独奏
            let trackVoicePreset = null;
            let trackDrumPreset = null;
            if (trackId != null && trackManager && trackManager.tracks.length > 0) {
                const track = trackManager.tracks.find(t => t.id === trackId);
                if (track) {
                    // 检查是否应该播放这个轨道
                    if (track.muted) return;
                    if (trackManager.soloActive && !track.solo) return;
                    // 使用轨道当前的乐器和音量设置
                    instrument = track.instrument;
                    volume = track.volume;
                    trackVoicePreset = track.voicePreset;
                    trackDrumPreset = track.drumPreset;
                }
            }

            const keyEl = document.querySelector(`.key[data-note="${note}"]`);
            if (keyEl) keyEl.classList.add('active');

            // 鼓组使用 DrumKit 播放
            if (instrument === 'drums') {
                // 优先使用轨道指定的鼓组预设缓存
                const kit = (trackDrumPreset && drumKitCache[trackDrumPreset]) || drumKit;
                if (kit?.ready) {
                    const midi = noteToMidi(note);
                    kit.trigger(midi, Tone.now(), volume);
                }
                setTimeout(() => { if (keyEl) keyEl.classList.remove('active'); }, Math.min(durationMs, 300));
                return;
            }

            // 根据轨道乐器选择采样器
            let sampler = pianoSampler;
            if (instrument === 'voice') {
                // 优先使用轨道指定的声线预设缓存
                const cached = trackVoicePreset && voiceSamplerCache[trackVoicePreset];
                sampler = cached?.loaded ? cached : (voiceSampler?.loaded ? voiceSampler : pianoSampler);
            } else if (instrument === 'violin') {
                sampler = violinSampler?.loaded ? violinSampler : pianoSampler;
            } else if (instrument === 'guitar') {
                sampler = guitarSampler?.loaded ? guitarSampler : pianoSampler;
            }

            if (sampler?.loaded) {
                const durationSec = Math.max(0.1, durationMs / 1000);
                sampler.triggerAttackRelease(note, durationSec, Tone.now(), volume);
            }
            setTimeout(() => { if (keyEl) keyEl.classList.remove('active'); }, Math.min(durationMs, 300));
        }

        // === 键盘生成 ===
        const piano = document.getElementById('piano');
        const noteNames = ['C', 'C#', 'D', 'D#', 'E', 'F', 'F#', 'G', 'G#', 'A', 'A#', 'B'];
        let whiteKeyCount = 0;
        for (let o = 2; o <= 6; o++) noteNames.forEach(n => createKey(n, o));
        createKey('C', 7);

        function createKey(n, o) {
            const note = n + o;
            const isBlack = n.includes('#');
            const d = document.createElement('div');
            d.dataset.note = note;
            d.dataset.octave = o;
            d.className = isBlack ? 'key black-key' : 'key white-key';
            if (!isBlack) { d.innerText = note; whiteKeyCount++; }
            d.addEventListener('mousedown', (e) => { if (e.button === 0) startNote(note, d); });
            d.addEventListener('mouseup', () => stopNote(note));
            d.addEventListener('mouseleave', () => stopNote(note));
            d.addEventListener('contextmenu', (e) => { e.preventDefault(); startBind(note); });
            piano.appendChild(d);
        }

        // === 钢琴自适应布局 ===
        const pianoRowsWrapper = document.getElementById('pianoRowsWrapper');
        const pianoRow1 = document.getElementById('pianoRow1');
        const pianoRow2 = document.getElementById('pianoRow2');
        const SPLIT_OCTAVE = 5;
        const MIN_WHITE_KEY_W = 20; // 低于此宽度切换双排
        let pianoIsTwoRows = false;

        // 真实钢琴白键比例约 1:6.4 (23.5mm × 150mm)
        // 屏幕上用 1:4.5 比较合适，不会太高也不会太扁
        const KEY_ASPECT_RATIO = 4.5;
        const MIN_PIANO_H = 140;
        const MAX_PIANO_H = 360;

        function layoutPianoKeys() {
            const container = document.querySelector('.piano-container');
            const containerW = container.clientWidth;
            const whiteW = containerW / whiteKeyCount;
            const needTwoRows = whiteW < MIN_WHITE_KEY_W;

            if (needTwoRows !== pianoIsTwoRows) {
                pianoIsTwoRows = needTwoRows;
                if (needTwoRows) {
                    piano.classList.add('two-rows');
                    pianoRowsWrapper.classList.add('active');
                    const allKeys = Array.from(piano.querySelectorAll('.key'));
                    allKeys.forEach(k => {
                        const oct = parseInt(k.dataset.octave);
                        if (oct < SPLIT_OCTAVE) pianoRow1.appendChild(k);
                        else pianoRow2.appendChild(k);
                    });
                } else {
                    piano.classList.remove('two-rows');
                    pianoRowsWrapper.classList.remove('active');
                    const allKeys = [
                        ...Array.from(pianoRow1.querySelectorAll('.key')),
                        ...Array.from(pianoRow2.querySelectorAll('.key'))
                    ];
                    allKeys.sort((a, b) => noteToMidi(a.dataset.note) - noteToMidi(b.dataset.note));
                    allKeys.forEach(k => piano.appendChild(k));
                }
            }

            // 计算等比高度
            const effectiveWhiteW = pianoIsTwoRows
                ? containerW / Math.ceil(whiteKeyCount / 2)
                : whiteW;
            let whiteH = Math.round(effectiveWhiteW * KEY_ASPECT_RATIO);
            whiteH = Math.max(MIN_PIANO_H, Math.min(MAX_PIANO_H, whiteH));
            const blackH = Math.round(whiteH * 0.63);

            // 应用高度
            applyPianoHeights(whiteH, blackH);

            // 重新定位黑键
            if (pianoIsTwoRows) {
                positionBlackKeys(pianoRow1);
                positionBlackKeys(pianoRow2);
            } else {
                positionBlackKeys(piano);
            }

            // 按比例缩放全局 UI：以 30px 白键宽度为基准
            const scale = Math.max(0.8, Math.min(2, effectiveWhiteW / 30));
            const root = document.documentElement;

            // 动态更新 CSS 变量 → 侧边栏、播放器、按钮等全部自动缩放
            root.style.setProperty('--font-xs', Math.round(11 * scale) + 'px');
            root.style.setProperty('--font-sm', Math.round(13 * scale) + 'px');
            root.style.setProperty('--font-md', Math.round(15 * scale) + 'px');
            root.style.setProperty('--font-lg', Math.round(18 * scale) + 'px');
            root.style.setProperty('--font-xl', Math.round(24 * scale) + 'px');
            root.style.setProperty('--space-sm', Math.round(8 * scale) + 'px');
            root.style.setProperty('--space-md', Math.round(12 * scale) + 'px');
            root.style.setProperty('--space-lg', Math.round(16 * scale) + 'px');
            root.style.setProperty('--space-xl', Math.round(24 * scale) + 'px');
            root.style.setProperty('--sidebar-width', Math.round(280 * scale) + 'px');
            root.style.setProperty('--sidebar-collapsed-width', Math.round(48 * scale) + 'px');
            root.style.setProperty('--toggle-btn-size', Math.round(32 * scale) + 'px');
            root.style.setProperty('--help-btn-size', Math.round(36 * scale) + 'px');
            root.style.setProperty('--theme-dot-size', Math.round(22 * scale) + 'px');

            // 琴键标注（不走 CSS 变量，单独设置）
            const keyFontSize = Math.round(11 * scale) + 'px';
            const labelFontSize = Math.round(8 * scale) + 'px';
            document.querySelectorAll('#piano .key, .piano-row .key').forEach(k => {
                k.style.fontSize = keyFontSize;
                const lbl = k.querySelector('.key-label');
                if (lbl) lbl.style.fontSize = labelFontSize;
            });
        }

        function applyPianoHeights(whiteH, blackH) {
            if (pianoIsTwoRows) {
                [pianoRow1, pianoRow2].forEach(row => {
                    row.style.height = whiteH + 'px';
                    row.querySelectorAll('.white-key').forEach(k => k.style.height = whiteH + 'px');
                    row.querySelectorAll('.black-key').forEach(k => k.style.height = blackH + 'px');
                });
            } else {
                piano.style.height = whiteH + 'px';
                piano.querySelectorAll('.white-key').forEach(k => k.style.height = whiteH + 'px');
                piano.querySelectorAll('.black-key').forEach(k => k.style.height = blackH + 'px');
            }
        }

        function positionBlackKeys(parentEl) {
            const whites = parentEl.querySelectorAll('.white-key');
            if (whites.length === 0) return;
            const whiteW = whites[0].getBoundingClientRect().width;
            const blackW = whiteW * 0.6;
            let wIdx = 0;
            Array.from(parentEl.querySelectorAll('.key')).forEach(k => {
                if (k.classList.contains('black-key')) {
                    k.style.left = (wIdx * whiteW - blackW / 2) + 'px';
                    k.style.width = blackW + 'px';
                } else {
                    wIdx++;
                }
            });
        }

        window.addEventListener('resize', layoutPianoKeys);
        // 初始布局需要等 flex 渲染完成
        requestAnimationFrame(() => layoutPianoKeys());

        // === UI 控制 ===
        const playBtn = document.getElementById('playBtn');
        const pauseBtn = document.getElementById('pauseBtn');
        const stopBtn = document.getElementById('stopBtn');
        const recordBtn = document.getElementById('recordBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const exportWavBtn = document.getElementById('exportWavBtn');

        recordBtn.addEventListener('click', () => {
            if (isPlaying) stopPlayback();
            isRecording = !isRecording;
            if (isRecording) {
                recordedEvents = []; recordingStartTime = Date.now();
                // 清除轨道管理器（录制是单轨道）
                if (trackManager) trackManager.clear();
                document.getElementById('trackControlsPanel').classList.remove('visible');

                recordBtn.innerText = "⏹ 停止"; recordBtn.classList.add('recording');
                playBtn.disabled = true; downloadBtn.disabled = true; exportWavBtn.disabled = true;
                document.getElementById('midiInfoPanel').classList.remove('visible');
                statusEl.innerText = "🔴 录制中...";
            } else {
                recordBtn.innerText = "⏺ 录制"; recordBtn.classList.remove('recording');
                const hasNotes = recordedEvents.length > 0;
                playBtn.disabled = !hasNotes; downloadBtn.disabled = !hasNotes;
                if (hasNotes) {
                    totalDuration = Math.max(...recordedEvents.map(e => e.time + e.duration));
                    updateMidiInfoPanel({ bpm: getBPM(), tracks: 1, notes: recordedEvents.length, duration: totalDuration });
                    progressHandle.classList.add('visible');
                    exportWavBtn.disabled = false;
                }
                statusEl.innerText = `✅ 录制完成，共 ${recordedEvents.length} 个音符`;
            }
        });

        function updateMidiInfoPanel(info) {
            document.getElementById('infoBpm').innerText = info.bpm;
            document.getElementById('infoTracks').innerText = info.tracks;
            document.getElementById('infoNotes').innerText = info.notes;
            document.getElementById('infoDuration').innerText = formatTime(info.duration);
            document.getElementById('midiInfoPanel').classList.add('visible');
            timeDisplay.innerText = `00:00 / ${formatTime(info.duration)}`;
            updateRenderStatus();
        }

        function updateRenderStatus() {
            if (renderStatusEl) {
                renderStatusEl.innerText = '点击导出';
                renderStatusEl.className = 'midi-info-value';
            }
        }

        // === 离线渲染已移至导出弹窗（exportModal）===

        // 播放控制
        playBtn.addEventListener('click', () => {
            if (recordedEvents.length === 0) return;
            if (isPaused) resumePlayback(); else startPlayback(recordedEvents, 0);
        });

        function startPlayback(events, startFromMs = 0) {
            if (isPlaying && !isPaused) return;
            isPlaying = true; isPaused = false;
            playBtn.classList.add('playing'); playBtn.innerText = "▶ 播放中";
            pauseBtn.disabled = false; stopBtn.disabled = false; recordBtn.disabled = true;
            progressHandle.classList.add('visible');
            playbackStartTime = Date.now() - startFromMs;

            // 启动可视化器
            if (visualizer) {
                visualizer.start(startFromMs);
            }

            // 获取所有音符（不过滤静音，在播放时实时检查）
            const allEvents = trackManager && trackManager.tracks.length > 0
                ? trackManager.tracks.flatMap(t => t.notes.map(n => ({ ...n, trackId: t.id })))
                : events;

            allEvents.filter(e => e.time >= startFromMs).forEach(event => {
                const delay = event.time - startFromMs;
                playbackTimeouts.push(setTimeout(() => {
                    if (isPlaying && !isPaused) {
                        triggerNoteForPlayback(
                            event.note,
                            event.duration,
                            event.instrument || 'piano',
                            event.volume || 1.0,
                            event.trackId
                        );
                    }
                }, delay));
            });

            playbackTimeouts.push(setTimeout(() => {
                if (isPlaying) {
                    if (isLooping) {
                        // 单曲循环：停止当前播放后立即重新开始
                        stopPlayback();
                        startPlayback(recordedEvents, 0);
                        statusEl.innerText = "🔁 循环播放中...";
                    } else {
                        stopPlayback();
                        statusEl.innerText = "✅ 播放完成";
                    }
                }
            }, totalDuration - startFromMs + 100));

            updateProgress();
            statusEl.innerText = "▶ 播放中...";
        }

        function updateProgress() {
            if (!isPlaying || isPaused) return;
            const elapsed = Date.now() - playbackStartTime;
            const progress = Math.min(100, (elapsed / totalDuration) * 100);
            progressFill.style.width = progress + '%';
            progressHandle.style.left = progress + '%';
            timeDisplay.innerText = `${formatTime(elapsed)} / ${formatTime(totalDuration)}`;
            if (elapsed < totalDuration) progressAnimationId = requestAnimationFrame(updateProgress);
        }

        function pausePlayback() {
            if (!isPlaying || isPaused) return;
            isPaused = true;
            playbackPausedAt = Date.now() - playbackStartTime;
            playbackTimeouts.forEach(t => clearTimeout(t));
            playbackTimeouts = [];
            cancelAnimationFrame(progressAnimationId);

            // 暂停可视化器
            if (visualizer) {
                visualizer.pause();
            }

            if (pianoSampler?.loaded) pianoSampler.releaseAll();
            if (voiceSampler?.loaded) voiceSampler.releaseAll();
            if (violinSampler?.loaded) violinSampler.releaseAll();
            document.querySelectorAll('.key.active').forEach(k => k.classList.remove('active'));
            playBtn.classList.remove('playing'); playBtn.innerText = "▶ 继续"; pauseBtn.disabled = true;
            statusEl.innerText = "⏸ 已暂停";
        }

        function resumePlayback() { startPlayback(recordedEvents, playbackPausedAt); }

        function stopPlayback() {
            isPlaying = false; isPaused = false; playbackPausedAt = 0;
            playbackTimeouts.forEach(t => clearTimeout(t));
            playbackTimeouts = [];
            cancelAnimationFrame(progressAnimationId);

            // 停止可视化器
            if (visualizer) {
                visualizer.stop();
            }

            if (pianoSampler?.loaded) pianoSampler.releaseAll();
            if (voiceSampler?.loaded) voiceSampler.releaseAll();
            if (violinSampler?.loaded) violinSampler.releaseAll();
            document.querySelectorAll('.key.active').forEach(k => k.classList.remove('active'));
            playBtn.classList.remove('playing'); playBtn.innerText = "▶ 播放";
            pauseBtn.disabled = true; stopBtn.disabled = true; recordBtn.disabled = false;
            progressFill.style.width = '0%'; progressHandle.style.left = '0%';
            if (totalDuration > 0) timeDisplay.innerText = `00:00 / ${formatTime(totalDuration)}`;
        }

        function togglePlayPause() {
            if (recordedEvents.length === 0) return;
            if (isPlaying && !isPaused) pausePlayback(); else playBtn.click();
        }

        pauseBtn.addEventListener('click', pausePlayback);
        stopBtn.addEventListener('click', () => { stopPlayback(); statusEl.innerText = "⏹ 已停止"; });

        // 单曲循环
        const loopBtn = document.getElementById('loopBtn');
        loopBtn.addEventListener('click', () => {
            isLooping = !isLooping;
            loopBtn.classList.toggle('active', isLooping);
            statusEl.innerText = isLooping ? '🔁 单曲循环 已开启' : '🔁 单曲循环 已关闭';
        });

        // 音色切换
        const modeSelect = document.getElementById('modeSelect');
        if (modeSelect) {
            const MODE_LABELS = {
                'piano': '🎹 钢琴',
                'voice': '🎤 人声唱调',
                'violin': '🎻 小提琴',
                'guitar': '🎸 电吉他',
                'drums': '🥁 鼓组'
            };

            const updateModeSelect = () => {
                modeSelect.value = currentSoundMode;
                // 采样未好时禁用对应选项
                const voiceReady = !!(voiceSampler && voiceSampler.loaded);
                const violinReady = !!(violinSampler && violinSampler.loaded);
                const guitarReady = !!(guitarSampler && guitarSampler.loaded);
                const drumsReady = !!(drumKit && drumKit.ready);
                for (const opt of modeSelect.options) {
                    if (opt.value === 'voice') opt.disabled = !voiceReady;
                    else if (opt.value === 'violin') opt.disabled = !violinReady;
                    else if (opt.value === 'guitar') opt.disabled = !guitarReady;
                    else if (opt.value === 'drums') opt.disabled = !drumsReady;
                }
            };

            const stopAllSamplers = () => {
                if (pianoSampler?.loaded) pianoSampler.releaseAll();
                if (voiceSampler?.loaded) voiceSampler.releaseAll();
                if (violinSampler?.loaded) violinSampler.releaseAll();
                if (guitarSampler?.loaded) guitarSampler.releaseAll();
            };

            modeSelect.addEventListener('change', () => {
                stopAllSamplers();
                currentSoundMode = modeSelect.value;

                // 显示/隐藏预设选择器和效果面板
                document.getElementById('voicePresetSelect').style.display = currentSoundMode === 'voice' ? 'block' : 'none';
                document.getElementById('voiceCloneBtn').style.display = currentSoundMode === 'voice' ? 'block' : 'none';
                document.getElementById('voiceEffectsPanel').style.display = currentSoundMode === 'voice' ? 'block' : 'none';
                // 删除按钮：voice 模式下且当前选中的是 IDB 预设才显示
                const delBtn = document.getElementById('voiceDeletePresetBtn');
                if (currentSoundMode === 'voice') {
                    const cur = VOICE_PRESETS[document.getElementById('voicePresetSelect').value];
                    delBtn.style.display = (cur && cur.source === 'indexeddb') ? 'inline-block' : 'none';
                } else {
                    delBtn.style.display = 'none';
                }
                document.getElementById('drumPresetSelect').style.display = currentSoundMode === 'drums' ? 'block' : 'none';

                statusEl.innerText = `已切换：${MODE_LABELS[currentSoundMode]}模式`;
            });

            // 鼓组预设切换
            document.getElementById('drumPresetSelect').addEventListener('change', async (e) => {
                const presetKey = e.target.value;
                statusEl.innerText = `⏳ 切换鼓组: ${DRUM_PRESETS[presetKey].name}...`;
                await drumKit.switchPreset(presetKey);
                drumKitCache[presetKey] = drumKit;
                statusEl.innerText = `✅ 鼓组已切换为 ${DRUM_PRESETS[presetKey].name}`;
            });

            // 初始状态
            updateModeSelect();

            // 异步加载完成后刷新选项状态
            const tryWatch = setInterval(() => {
                const voiceReady = voiceSampler && voiceSampler.loaded;
                const violinReady = violinSampler && violinSampler.loaded;
                const drumsReady = drumKit && drumKit.ready;
                if (voiceReady && violinReady && drumsReady) {
                    updateModeSelect();
                    clearInterval(tryWatch);
                }
            }, 300);
        }

        // 进度条拖拽
        let isDragging = false;
        progressWrapper.addEventListener('mousedown', (e) => {
            if (recordedEvents.length === 0) return;
            isDragging = true;
            if (isPlaying && !isPaused) pausePlayback();
            updateSeekPosition(e);
        });
        document.addEventListener('mousemove', (e) => { if (isDragging) updateSeekPosition(e); });
        document.addEventListener('mouseup', () => { isDragging = false; });
        
        function updateSeekPosition(e) {
            const rect = progressWrapper.getBoundingClientRect();
            let percent = Math.max(0, Math.min(1, (e.clientX - rect.left) / rect.width));
            progressFill.style.width = (percent * 100) + '%';
            progressHandle.style.left = (percent * 100) + '%';
            playbackPausedAt = percent * totalDuration;
            timeDisplay.innerText = `${formatTime(playbackPausedAt)} / ${formatTime(totalDuration)}`;

            // 同步可视化器位置
            if (visualizer) {
                visualizer.seek(playbackPausedAt);
            }
        }

        // 下载 MIDI
        downloadBtn.addEventListener('click', async () => {
            try {
                statusEl.innerText = "⏳ 正在生成 MIDI...";

                // 应用专业量化
                const gridSize = parseInt(quantizeSelect.value);
                const strength = parseFloat(humanizeSlider.value);
                const quantizedEvents = professionalQuantize(recordedEvents, getBPM(), gridSize, {
                    strength: strength,
                    alignChords: true,
                    removeGhosts: true,
                    fixedLength: true,
                    humanizePreset: currentHumanizePreset
                });

                console.log('量化后音符数:', quantizedEvents.length, '原始:', recordedEvents.length);

                const res = await fetch('http://localhost:3000/create-midi', {
                    method: 'POST', headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        bpm: getBPM(),
                        notes: quantizedEvents,
                        gridSize: gridSize
                    })
                });

                if (res.ok) {
                    const url = window.URL.createObjectURL(await res.blob());
                    const a = document.createElement('a'); a.href = url; a.download = `piano-${getBPM()}bpm.mid`;
                    document.body.appendChild(a); a.click(); a.remove();
                    statusEl.innerText = `💾 MIDI 已下载 (${quantizedEvents.length}个音符, ${currentHumanizePreset === 'none' ? '纯量化' : HUMANIZE_PRESETS[currentHumanizePreset].name})`;
                } else {
                    statusEl.innerText = `❌ 服务器错误: ${res.status}`;
                }
            } catch (err) {
                console.error('MIDI 下载失败:', err);
                statusEl.innerText = `❌ 下载失败: ${err.message} (服务器是否启动?)`;
            }
        });

        // 导入 MIDI
        document.getElementById('midiFileInput').addEventListener('change', async (e) => {
            const file = e.target.files[0];
            if (!file) return;
            statusEl.innerText = "📂 解析 MIDI...";
            try {
                const midi = new Midi(await file.arrayBuffer());

                // 使用 TrackManager 解析轨道
                trackManager.loadFromMidi(midi);

                if (trackManager.tracks.length === 0) {
                    statusEl.innerText = "⚠️ MIDI 中没有音符";
                    return;
                }

                // 获取扁平化的音符列表（兼容旧逻辑）
                recordedEvents = trackManager.getActiveNotes();
                recordedEvents.sort((a, b) => a.time - b.time);

                const fileBpm = midi.header.tempos.length > 0 ? Math.round(midi.header.tempos[0].bpm) : 120;
                totalDuration = Math.max(...recordedEvents.map(e => e.time + e.duration));
                bpmInput.value = fileBpm;

                playBtn.disabled = false;
                downloadBtn.disabled = false;
                progressHandle.classList.add('visible');

                updateMidiInfoPanel({
                    bpm: fileBpm,
                    tracks: trackManager.tracks.length,
                    notes: recordedEvents.length,
                    duration: totalDuration
                });

                // 设置可视化器轨道
                visualizer.setTracks(trackManager.tracks);
                visualizer.seek(0);
                if (pianoRollEditor) {
                    pianoRollEditor.bpm = fileBpm;
                    pianoRollEditor.editScrollX = 0;
                }

                // 显示轨道控制面板
                document.getElementById('trackControlsPanel').classList.add('visible');

                statusEl.innerText = `✅ 已导入 ${file.name} (${trackManager.tracks.length} 轨道)`;
                exportWavBtn.disabled = false;
            } catch (err) {
                console.error(err);
                statusEl.innerText = "❌ 解析失败: " + err.message;
            }
            e.target.value = '';
        });

        // 导出 WAV — 打开导出弹窗
        exportWavBtn.addEventListener('click', () => {
            if (recordedEvents.length === 0) return;
            openExportModal();
        });

        async function encodeWAVAsync(left, right, rate) {
            const numSamples = left.length;
            const buffer = new ArrayBuffer(44 + numSamples * 4);
            const view = new DataView(buffer);
            const writeStr = (o, s) => { for(let i=0;i<s.length;i++) view.setUint8(o+i, s.charCodeAt(i)); };
            
            writeStr(0, 'RIFF');
            view.setUint32(4, 36 + numSamples * 4, true);
            writeStr(8, 'WAVE');
            writeStr(12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 2, true);
            view.setUint32(24, rate, true);
            view.setUint32(28, rate * 4, true);
            view.setUint16(32, 4, true);
            view.setUint16(34, 16, true);
            writeStr(36, 'data');
            view.setUint32(40, numSamples * 4, true);
            
            let offset = 44;
            const chunkSize = 100000;
            
            for (let i = 0; i < numSamples; i += chunkSize) {
                const end = Math.min(i + chunkSize, numSamples);
                for (let j = i; j < end; j++) {
                    const l = Math.max(-1, Math.min(1, left[j]));
                    const r = Math.max(-1, Math.min(1, right[j]));
                    view.setInt16(offset, l * 0x7FFF, true);
                    view.setInt16(offset + 2, r * 0x7FFF, true);
                    offset += 4;
                }
                await new Promise(r => setTimeout(r, 0));
            }
            
            return new Blob([buffer], { type: 'audio/wav' });
        }

        // ========== 导出弹窗逻辑 ==========
        let exportCancelled = false;
        let exportOfflineCtx = null;
        let exportCancelResolve = null;
        let exportRunningInBg = false;

        const INST_LABELS = { piano: '钢琴', voice: '人声', violin: '小提琴', guitar: '吉他', drums: '鼓组' };

        let exportModalBound = false;
        function openExportModal() {
            const modal = document.getElementById('exportModal');
            const list = document.getElementById('exportTrackList');
            const prog = document.getElementById('exportProgress');
            const startBtn = document.getElementById('exportStartBtn');

            // 首次打开时绑定事件
            if (!exportModalBound) {
                document.getElementById('exportModalClose').addEventListener('click', () => {
                    if (exportOfflineCtx) {
                        // 渲染中点关闭 = 后台运行
                        exportRunningInBg = true;
                        document.getElementById('exportModal').classList.remove('active');
                        showBgProgress(true);
                    } else {
                        exportCancelled = true;
                        if (exportCancelResolve) exportCancelResolve(null);
                        document.getElementById('exportModal').classList.remove('active');
                    }
                });
                document.getElementById('exportStartBtn').addEventListener('click', startExportRender);
                document.getElementById('exportCancelBtn').addEventListener('click', () => {
                    exportCancelled = true;
                    if (exportCancelResolve) exportCancelResolve(null);
                });
                document.getElementById('exportBgBtn').addEventListener('click', () => {
                    exportRunningInBg = true;
                    document.getElementById('exportModal').classList.remove('active');
                    showBgProgress(true);
                });
                document.getElementById('exportBgOpen').addEventListener('click', () => {
                    openExportModal();
                });
                exportModalBound = true;
            }

            list.innerHTML = '';
            // 如果渲染正在后台运行，恢复显示进度而不是重置
            if (exportOfflineCtx) {
                prog.style.display = 'flex';
                startBtn.style.display = 'none';
                exportRunningInBg = false;
                showBgProgress(false);
                modal.classList.add('active');
                return;
            }
            prog.style.display = 'none';
            startBtn.style.display = '';
            startBtn.disabled = false;
            exportCancelled = false;

            // 构建轨道列表
            const tracks = trackManager?.tracks?.length > 0
                ? trackManager.tracks
                : [{ name: '录制', instrument: currentSoundMode || 'piano', volume: 1.0, muted: false, color: '#4fc3f7' }];

            tracks.forEach(t => {
                const row = document.createElement('div');
                row.className = 'export-track-item' + (t.muted ? ' export-track-muted' : '');
                const col = t.color || '#4fc3f7';
                row.innerHTML = `<span class="export-track-color" style="background:${col}"></span>`
                    + `<span class="export-track-name">${t.name || '轨道'}</span>`
                    + `<span class="export-track-inst">${INST_LABELS[t.instrument] || t.instrument}</span>`
                    + `<span class="export-track-vol">${Math.round((t.volume ?? 1) * 100)}%</span>`;
                list.appendChild(row);
            });

            modal.classList.add('active');
        }

        // 采样选择：找最近的已加载采样，返回 { buffer: AudioBuffer, semitones }
        function buildSampleMap(toneBuffers, sampleKeys) {
            const map = []; // [{ midi, buffer }]
            for (const key of sampleKeys) {
                const b = toneBuffers.get(key);
                if (b) {
                    const raw = typeof b.get === 'function' ? b.get() : b;
                    if (raw) map.push({ midi: noteToMidi(key), buffer: raw });
                }
            }
            map.sort((a, b) => a.midi - b.midi);
            return map;
        }

        function findNearestSample(targetMidi, sampleMap) {
            if (sampleMap.length === 0) return null;
            // 二分查找最近采样
            let lo = 0, hi = sampleMap.length - 1;
            while (lo < hi) {
                const mid = (lo + hi) >> 1;
                if (sampleMap[mid].midi < targetMidi) lo = mid + 1;
                else hi = mid;
            }
            // 比较 lo 和 lo-1
            let best = sampleMap[lo];
            if (lo > 0) {
                const prev = sampleMap[lo - 1];
                if (Math.abs(targetMidi - prev.midi) < Math.abs(targetMidi - best.midi)) best = prev;
            }
            return { buffer: best.buffer, semitones: targetMidi - best.midi };
        }

        async function startExportRender() {
            const startBtn = document.getElementById('exportStartBtn');
            const prog = document.getElementById('exportProgress');
            const fill = document.getElementById('exportProgressFill');
            const text = document.getElementById('exportProgressText');
            const bgBtn = document.getElementById('exportBgBtn');
            const cancelBtn = document.getElementById('exportCancelBtn');
            startBtn.style.display = 'none';
            prog.style.display = 'flex';
            fill.style.width = '0%';
            text.innerText = '收集音符...';
            exportCancelled = false;
            exportRunningInBg = false;
            exportCancelResolve = null;
            exportOfflineCtx = {}; // 标记渲染中（非null即可）

            const t0 = performance.now();

            try {
                // 1. 收集音符
                const allEvents = trackManager?.tracks?.length > 0
                    ? trackManager.tracks.flatMap(t => {
                        if (t.muted) return [];
                        if (trackManager.soloActive && !t.solo) return [];
                        return t.notes.map(n => ({
                            ...n, instrument: t.instrument, volume: t.volume,
                            drumPreset: t.drumPreset
                        }));
                    })
                    : recordedEvents.map(e => ({
                        ...e, instrument: currentSoundMode || 'piano', volume: 1.0
                    }));

                if (allEvents.length === 0) throw new Error('没有可渲染的音符');

                const totalNotes = allEvents.length;
                text.innerText = `收集到 ${totalNotes} 个音符`;
                const durationSec = totalDuration / 1000 + 3;
                const sampleRate = 44100;
                const numSamples = Math.ceil(sampleRate * durationSec);

                fill.style.width = '5%';
                await new Promise(r => setTimeout(r, 0));
                if (exportCancelled) throw new Error('已取消');

                // 2. 构建采样映射
                text.innerText = '构建采样映射...';
                const pianoMap = pianoBuffers?.loaded ? buildSampleMap(pianoBuffers, Object.keys(PIANO_SAMPLES)) : [];
                const voiceMap = voiceBuffers?.loaded ? buildSampleMap(voiceBuffers, Object.keys(VOICE_SAMPLES)) : [];
                const violinMap = violinBuffers?.loaded ? buildSampleMap(violinBuffers, Object.keys(VIOLIN_SAMPLES)) : [];

                // 3. 创建输出缓冲区
                const left = new Float32Array(numSamples);
                const right = new Float32Array(numSamples);

                // 4. 手动混音 - 直接操作 Float32Array，无 Web Audio 开销
                const guitarRR = {};
                const reverbWet = parseFloat(document.getElementById('wetSlider')?.value || 0);

                for (let ni = 0; ni < totalNotes; ni++) {
                    // 每 200 个音符更新一次进度
                    if (ni % 200 === 0) {
                        const pct = 5 + (ni / totalNotes) * 70;
                        const elapsed = ((performance.now() - t0) / 1000).toFixed(1);
                        text.innerText = `混音 ${ni}/${totalNotes} (${elapsed}s)`;
                        fill.style.width = pct + '%';
                        if (exportRunningInBg) updateBgProgress(pct, text.innerText);
                        await new Promise(r => setTimeout(r, 0));
                        if (exportCancelled) throw new Error('已取消');
                    }

                    const event = allEvents[ni];
                    const startSample = Math.floor(event.time / 1000 * sampleRate);
                    const noteDurSamples = Math.floor(Math.max(0.05, event.duration / 1000) * sampleRate);
                    const vol = event.volume ?? 1.0;
                    const inst = event.instrument || 'piano';
                    const midi = event.midi || noteToMidi(event.note);

                    let srcBuf = null;
                    let playbackRate = 1;

                    // 根据乐器获取采样
                    if (inst === 'drums') {
                        const kit = (event.drumPreset && drumKitCache[event.drumPreset]) || drumKit;
                        if (!kit?.ready) continue;
                        let buf = kit.buffers[midi];
                        if (!buf) buf = kit.findNearest(midi);
                        if (!buf) continue;
                        if (Array.isArray(buf)) {
                            const idx = Math.min(Math.floor(vol * buf.length), buf.length - 1);
                            const sel = buf[idx];
                            srcBuf = sel ? (typeof sel.get === 'function' ? sel.get() : sel) : null;
                        } else {
                            srcBuf = typeof buf.get === 'function' ? buf.get() : buf;
                        }
                        playbackRate = 1;
                    } else if (inst === 'guitar' && guitarSampler?.loaded) {
                        const { note: sampleNote, semitones } = guitarSampler.findNearestNote(event.note);
                        const velLayer = guitarSampler.getVelocityLayer(vol);
                        if (!guitarRR[sampleNote]) guitarRR[sampleNote] = 0;
                        guitarRR[sampleNote] = (guitarRR[sampleNote] % (typeof GUITAR_ROUND_ROBINS !== 'undefined' ? GUITAR_ROUND_ROBINS : 2)) + 1;
                        const key = `${sampleNote}_${velLayer}_${guitarRR[sampleNote]}`;
                        const gBuf = guitarSampler.buffers[key];
                        if (gBuf) srcBuf = typeof gBuf.get === 'function' ? gBuf.get() : gBuf;
                        playbackRate = Math.pow(2, semitones / 12);
                    } else {
                        // piano / voice / violin
                        let sMap = pianoMap;
                        if (inst === 'voice' && voiceMap.length > 0) sMap = voiceMap;
                        else if (inst === 'violin' && violinMap.length > 0) sMap = violinMap;
                        const nearest = findNearestSample(midi, sMap);
                        if (nearest) {
                            srcBuf = nearest.buffer;
                            playbackRate = Math.pow(2, nearest.semitones / 12);
                        }
                    }

                    if (!srcBuf) continue;

                    // 获取源通��数据
                    const srcLeft = srcBuf.getChannelData(0);
                    const srcRight = srcBuf.numberOfChannels > 1 ? srcBuf.getChannelData(1) : srcLeft;
                    const srcLen = srcLeft.length;

                    // ADSR 参数
                    const atkSamples = Math.floor(0.005 * sampleRate);
                    const relSamples = Math.floor((inst === 'violin' ? 1.0 : (inst === 'voice' ? 0.5 : 0.8)) * sampleRate);
                    const totalNoteSamples = inst === 'drums'
                        ? Math.floor(srcLen / playbackRate)
                        : noteDurSamples + relSamples;

                    // 混音循环 - 线性插值重采样 + ADSR
                    for (let i = 0; i < totalNoteSamples; i++) {
                        const outIdx = startSample + i;
                        if (outIdx >= numSamples) break;

                        // 源采样位置（考虑 playbackRate）
                        const srcPos = i * playbackRate;
                        const srcIdx = Math.floor(srcPos);
                        if (srcIdx >= srcLen - 1) break;

                        // 线性插值
                        const frac = srcPos - srcIdx;
                        const lSample = srcLeft[srcIdx] * (1 - frac) + srcLeft[srcIdx + 1] * frac;
                        const rSample = srcRight[srcIdx] * (1 - frac) + srcRight[srcIdx + 1] * frac;

                        // ADSR 包络
                        let env = vol;
                        if (inst !== 'drums') {
                            if (i < atkSamples) {
                                env = vol * (i / atkSamples); // Attack
                            } else if (i >= noteDurSamples) {
                                const relPos = i - noteDurSamples;
                                env = vol * Math.exp(-relPos / (relSamples * 0.2)); // Release (指数衰减)
                            }
                        }

                        // 累加到输出
                        left[outIdx] += lSample * env;
                        right[outIdx] += rSample * env;
                    }
                }

                fill.style.width = '80%';
                text.innerText = '后处理...';
                if (exportRunningInBg) updateBgProgress(80, '后处理...');
                await new Promise(r => setTimeout(r, 0));
                if (exportCancelled) throw new Error('已取消');

                // 5. 混响后处理 - 模拟 Freeverb 风格的算法混响
                if (reverbWet > 0) {
                    // 创建湿信号缓冲区
                    const wetL = new Float32Array(numSamples);
                    const wetR = new Float32Array(numSamples);

                    // 梳状滤波器延迟时间（毫秒），模拟 Freeverb
                    const combDelays = [29.7, 37.1, 41.1, 43.7, 53.0, 59.9, 67.7, 74.0];
                    const combFeedback = 0.84; // 控制衰减时间

                    // 全通滤波器延迟时间
                    const allpassDelays = [5.0, 12.6, 10.0, 7.7];
                    const allpassFeedback = 0.5;

                    // 对每个梳状滤波器处理
                    for (let c = 0; c < combDelays.length; c++) {
                        const delaySamples = Math.floor(combDelays[c] / 1000 * sampleRate);
                        const bufL = new Float32Array(delaySamples);
                        const bufR = new Float32Array(delaySamples);
                        let idxL = 0, idxR = 0;

                        // 左右声道略微不同的延迟，增加立体声宽度
                        const delayR = Math.floor(delaySamples * (1 + (c % 2 ? 0.02 : -0.02)));
                        const bufR2 = new Float32Array(delayR);

                        for (let i = 0; i < numSamples; i++) {
                            // 左声道
                            const outL = bufL[idxL];
                            bufL[idxL] = left[i] + outL * combFeedback;
                            idxL = (idxL + 1) % delaySamples;
                            wetL[i] += outL;

                            // 右声道
                            const outR = bufR2[idxR % delayR];
                            bufR2[idxR % delayR] = right[i] + outR * combFeedback;
                            idxR++;
                            wetR[i] += outR;
                        }
                    }

                    // 归一化梳状滤波器输出
                    const combScale = 1 / combDelays.length;
                    for (let i = 0; i < numSamples; i++) {
                        wetL[i] *= combScale;
                        wetR[i] *= combScale;
                    }

                    // 全通滤波器（增加扩散）
                    for (const apDelay of allpassDelays) {
                        const delaySamples = Math.floor(apDelay / 1000 * sampleRate);
                        const bufL = new Float32Array(delaySamples);
                        const bufR = new Float32Array(delaySamples);
                        let idx = 0;

                        for (let i = 0; i < numSamples; i++) {
                            const delayedL = bufL[idx];
                            const delayedR = bufR[idx];
                            const inputL = wetL[i];
                            const inputR = wetR[i];

                            bufL[idx] = inputL + delayedL * allpassFeedback;
                            bufR[idx] = inputR + delayedR * allpassFeedback;

                            wetL[i] = delayedL - inputL * allpassFeedback;
                            wetR[i] = delayedR - inputR * allpassFeedback;

                            idx = (idx + 1) % delaySamples;
                        }
                    }

                    // 混合干湿信号
                    const wet = reverbWet;
                    const dry = 1 - wet * 0.5; // 保持干声主体
                    for (let i = 0; i < numSamples; i++) {
                        left[i] = left[i] * dry + wetL[i] * wet;
                        right[i] = right[i] * dry + wetR[i] * wet;
                    }
                }

                // 6. 归一化 + 增益 + 软限幅
                // 先计算 RMS 来判断整体响度
                let sumSq = 0;
                let maxVal = 0;
                for (let i = 0; i < numSamples; i++) {
                    sumSq += left[i] * left[i] + right[i] * right[i];
                    const absL = Math.abs(left[i]), absR = Math.abs(right[i]);
                    if (absL > maxVal) maxVal = absL;
                    if (absR > maxVal) maxVal = absR;
                }
                const rms = Math.sqrt(sumSq / (numSamples * 2));

                // 目标 RMS 约 -12dB (0.25)，如果当前 RMS 太低就增益
                const targetRms = 0.25;
                let gain = 1.0;
                if (rms > 0.001 && rms < targetRms) {
                    gain = Math.min(targetRms / rms, 3.0); // 最多增益 3 倍
                }

                // 应用增益 + 软限幅（tanh）防止削波
                for (let i = 0; i < numSamples; i++) {
                    left[i] *= gain;
                    right[i] *= gain;
                    // 软限幅：超过 0.9 的部分用 tanh 压缩
                    if (Math.abs(left[i]) > 0.9) {
                        left[i] = Math.sign(left[i]) * (0.9 + 0.1 * Math.tanh((Math.abs(left[i]) - 0.9) * 5));
                    }
                    if (Math.abs(right[i]) > 0.9) {
                        right[i] = Math.sign(right[i]) * (0.9 + 0.1 * Math.tanh((Math.abs(right[i]) - 0.9) * 5));
                    }
                }

                if (exportCancelled) throw new Error('已取消');

                fill.style.width = '90%';
                text.innerText = '编码 WAV...';
                if (exportRunningInBg) updateBgProgress(90, '编码 WAV...');
                bgBtn.style.display = 'none';
                cancelBtn.style.display = 'none';
                await new Promise(r => setTimeout(r, 0));

                // 7. 编码 WAV 并下载
                const blob = await encodeWAVAsync(left, right, sampleRate);
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `piano-${getBPM()}bpm.mp3`;
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);

                const renderTime = ((performance.now() - t0) / 1000).toFixed(2);
                fill.style.width = '100%';
                text.innerText = `✓ 导出完成 (${renderTime}s)`;
                statusEl.innerText = `✅ WAV 已导出 (${renderTime}s)`;

                if (exportRunningInBg) {
                    showExportToast(`✅ WAV 导出完成 (${renderTime}s)`);
                    showBgProgress(false);
                }

            } catch (err) {
                if (err.message === '已取消') {
                    text.innerText = '已取消';
                    fill.style.width = '0%';
                    if (exportRunningInBg) {
                        showExportToast('导出已取消');
                        showBgProgress(false);
                    }
                } else {
                    console.error('导出失败:', err);
                    text.innerText = '❌ 导出失败: ' + err.message;
                    statusEl.innerText = '⚠️ 导出失败: ' + err.message;
                    if (exportRunningInBg) {
                        showExportToast('❌ 导出失败: ' + err.message);
                        showBgProgress(false);
                    }
                }
                startBtn.style.display = '';
                startBtn.disabled = false;
            }
            exportOfflineCtx = null;
            exportCancelResolve = null;
            exportRunningInBg = false;
            bgBtn.style.display = '';
            cancelBtn.style.display = '';
        }

        function showBgProgress(visible) {
            const el = document.getElementById('exportBgProgress');
            if (el) el.style.display = visible ? 'flex' : 'none';
        }

        function updateBgProgress(pct, label) {
            const fill = document.getElementById('exportBgFill');
            const text = document.getElementById('exportBgText');
            if (fill) fill.style.width = pct + '%';
            if (text) text.textContent = label;
        }

        function showExportToast(msg) {
            let toast = document.getElementById('exportToast');
            if (!toast) {
                toast = document.createElement('div');
                toast.id = 'exportToast';
                toast.style.cssText = 'position:fixed;bottom:24px;left:50%;transform:translateX(-50%);'
                    + 'background:var(--pr-bg-darkest,#1a1a2e);color:var(--pr-text-primary,#fff);'
                    + 'padding:10px 20px;border-radius:8px;font-size:var(--font-sm,13px);'
                    + 'box-shadow:0 4px 20px rgba(0,0,0,0.5);border:1px solid var(--pr-border,#333);'
                    + 'z-index:30000;cursor:pointer;transition:opacity 0.3s;';
                toast.addEventListener('click', () => {
                    toast.style.opacity = '0';
                    setTimeout(() => toast.remove(), 300);
                    // 重新打开弹窗查看结果
                    document.getElementById('exportModal').classList.add('active');
                });
                document.body.appendChild(toast);
            }
            toast.textContent = msg;
            toast.style.opacity = '1';
            setTimeout(() => {
                if (toast.parentNode) {
                    toast.style.opacity = '0';
                    setTimeout(() => toast.remove(), 300);
                }
            }, 5000);
        }

    </script>

    <!-- Voice Clone Modal -->
    <div id="voiceCloneModal" class="pr-modal">
        <div class="pr-modal-content" style="width:420px;height:auto;max-height:80vh;">
            <div class="pr-modal-header" style="justify-content:space-between;">
                <div class="pr-modal-title">🎙️ 克隆声线</div>
                <button class="pr-modal-close" id="voiceCloneModalClose">&times;</button>
            </div>
            <div style="padding:16px;display:flex;flex-direction:column;gap:12px;">
                <label class="label-small">声线名称（可选，不填自动生成）</label>
                <input type="text" id="vcDisplayNameInput" placeholder="例：七海的声音" style="width:100%;">
                <label class="label-small">参考音频（5-25秒说话/唱歌片段）</label>
                <input type="file" id="vcFileInput" accept=".wav,.mp3,.flac,.ogg,.m4a">

                <!-- 高级参数折叠面板 -->
                <details id="vcAdvancedParams" style="border:1px solid rgba(255,255,255,0.1);border-radius:6px;padding:0;">
                    <summary style="padding:8px 12px;cursor:pointer;color:var(--text-secondary);user-select:none;">⚙️ 高级参数 <span style="opacity:0.6;">（参数不懂的话最好不要动咕~默认效果大多情况下也很好！）</span></summary>
                    <div style="padding:8px 12px 12px;display:flex;flex-direction:column;gap:10px;">
                        <div style="display:flex;align-items:center;justify-content:space-between;">
                            <label class="label-small" style="margin:0;" title="扩散步数，越高质量越好但越慢（10-100）">扩散步数</label>
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="range" id="vcDiffusionSteps" min="10" max="100" step="5" value="30" style="width:100px;">
                                <span id="vcDiffusionStepsVal" style="min-width:24px;text-align:right;" class="value-display">30</span>
                            </div>
                        </div>
                        <div style="display:flex;align-items:center;justify-content:space-between;">
                            <label class="label-small" style="margin:0;" title="推理引导率，越高越像参考音色（0.0-1.0）">相似度引导</label>
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="range" id="vcCfgRate" min="0" max="1" step="0.05" value="0.7" style="width:100px;">
                                <span id="vcCfgRateVal" style="min-width:28px;text-align:right;" class="value-display">0.7</span>
                            </div>
                        </div>
                        <div style="display:flex;align-items:center;justify-content:space-between;">
                            <label class="label-small" style="margin:0;" title="输出长度倍率（0.5-2.0）">长度调整</label>
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="range" id="vcLengthAdjust" min="0.5" max="2.0" step="0.05" value="1.0" style="width:100px;">
                                <span id="vcLengthAdjustVal" style="min-width:28px;text-align:right;" class="value-display">1.0</span>
                            </div>
                        </div>
                        <div style="display:flex;align-items:center;justify-content:space-between;">
                            <label class="label-small" style="margin:0;" title="半音偏移，正值升调负值降调（-12到12）">半音偏移</label>
                            <div style="display:flex;align-items:center;gap:6px;">
                                <input type="range" id="vcSemiToneShift" min="-12" max="12" step="1" value="0" style="width:100px;">
                                <span id="vcSemiToneShiftVal" style="min-width:24px;text-align:right;" class="value-display">0</span>
                            </div>
                        </div>
                        <div style="display:flex;align-items:center;justify-content:space-between;">
                            <label class="label-small" style="margin:0;" title="保留原始音高轮廓">F0 音高保留</label>
                            <input type="checkbox" id="vcF0Condition" checked style="width:16px;height:16px;">
                        </div>
                        <div style="display:flex;align-items:center;justify-content:space-between;">
                            <label class="label-small" style="margin:0;" title="自动将音高调整到参考音色的音域">自动 F0 调整</label>
                            <input type="checkbox" id="vcAutoF0Adjust" style="width:16px;height:16px;">
                        </div>
                    </div>
                </details>

                <div id="vcProgressArea" style="display:none;">
                    <div style="display:flex;justify-content:space-between;margin-bottom:4px;">
                        <span id="vcProgressText" class="label-small">准备中...</span>
                        <span id="vcProgressPercent" class="label-small">0%</span>
                    </div>
                    <div style="height:6px;background:rgba(255,255,255,0.1);border-radius:3px;overflow:hidden;">
                        <div id="vcProgressBar" style="height:100%;width:0%;background:var(--daw-accent);border-radius:3px;transition:width 0.3s;"></div>
                    </div>
                </div>
                <div id="vcErrorArea" style="display:none;color:#ff6b6b;"></div>
                <button class="btn" id="vcStartBtn">开始克隆</button>
            </div>
        </div>
    </div>

    <!-- 全屏钢琴卷帘编辑器模态窗口 -->
    <div id="pianoRollModal" class="pr-modal">
        <div class="pr-modal-content">
            <!-- 顶部标题栏 -->
            <div class="pr-modal-header">
                <span class="pr-modal-title">钢琴卷帘编辑器</span>
                <div class="pr-modal-toolbar">
                    <div class="prm-tool-group">
                        <span class="prm-tool-label">工具</span>
                        <button class="prm-tool-btn active" data-prm-tool="select" title="选择/移动 (V)">选择</button>
                        <button class="prm-tool-btn" data-prm-tool="draw" title="绘制音符 (D)">绘制</button>
                        <button class="prm-tool-btn" data-prm-tool="erase" title="擦除音符 (E)">擦除</button>
                    </div>
                    <div class="prm-tool-group">
                        <span class="prm-tool-label">网格</span>
                        <select class="prm-select" id="prmGridSnap">
                            <option value="0">自由</option>
                            <option value="4" selected>1/4</option>
                            <option value="8">1/8</option>
                            <option value="16">1/16</option>
                            <option value="32">1/32</option>
                        </select>
                    </div>
                    <div class="prm-tool-group">
                        <span class="prm-tool-label">BPM</span>
                        <input type="number" class="prm-input" id="prmBpm" value="120" min="40" max="300">
                    </div>
                    <div class="prm-tool-group">
                        <span class="prm-tool-label">拍号</span>
                        <select class="prm-select" id="prmTimeSignature">
                            <option value="4" selected>4/4</option>
                            <option value="3">3/4</option>
                            <option value="6">6/8</option>
                        </select>
                    </div>
                    <div class="prm-tool-group">
                        <button class="prm-tool-btn" id="prmUndo" title="撤销 (Ctrl+Z)">撤销</button>
                        <button class="prm-tool-btn" id="prmRedo" title="重做 (Ctrl+Shift+Z)">重做</button>
                        <button class="prm-tool-btn" id="prmDelete" title="删除选中 (Del)">删除</button>
                    </div>
                </div>
                <button class="pr-modal-close" id="closePianoRollModal" title="关闭 (Esc)">&times;</button>
            </div>

            <!-- 播放控制栏 -->
            <div class="prm-transport-bar">
                <button class="prm-transport-btn" id="prmPlayBtn" title="播放/暂停 (Space)">&#9654;</button>
                <button class="prm-transport-btn" id="prmStopBtn" title="停止">&#9632;</button>
                <div class="prm-transport-time">
                    <span id="prmTimeDisplay">00:00 / 00:00</span>
                </div>
                <div class="prm-transport-progress">
                    <div class="prm-transport-progress-bg" id="prmProgressBg">
                        <div class="prm-transport-progress-fill" id="prmProgressFill"></div>
                    </div>
                </div>
            </div>

            <!-- 主编辑区域 -->
            <div class="pr-modal-body">
                <!-- 时间标尺行 -->
                <div class="pr-ruler-row">
                    <div class="pr-ruler-corner">小节</div>
                    <canvas id="prmTimeRulerCanvas" class="pr-time-ruler"></canvas>
                </div>

                <!-- 中间主区域 -->
                <div class="pr-main-row">
                    <!-- 钢琴键盘 -->
                    <div id="prmPianoKeys" class="pr-piano-keys"></div>
                    <!-- 音符画布 -->
                    <div class="pr-canvas-wrapper">
                        <canvas id="prmNoteCanvas" class="pr-note-canvas"></canvas>
                    </div>
                </div>

                <!-- 力度编辑区 -->
                <div class="pr-velocity-row">
                    <div class="pr-velocity-label">
                        <span class="pr-velocity-label-text">力度</span>
                        <span class="pr-velocity-value" id="prmVelocityDisplay">100</span>
                    </div>
                    <canvas id="prmVelocityCanvas" class="pr-velocity-canvas"></canvas>
                </div>
            </div>
        </div>
    </div>

    <!-- 导出音频弹窗 -->
    <div id="exportModal" class="pr-modal">
        <div class="pr-modal-content" style="width:480px;height:auto;max-height:80vh;">
            <div class="pr-modal-header" style="justify-content:space-between;">
                <div class="pr-modal-title">🎵 导出音频</div>
                <button class="pr-modal-close" id="exportModalClose">&times;</button>
            </div>
            <div id="exportModalBody" style="padding:16px;display:flex;flex-direction:column;gap:12px;">
                <div id="exportTrackList"></div>
                <div class="export-format-info">WAV · 44100 Hz · 16 bit · 立体声</div>
                <button class="btn" id="exportStartBtn" style="align-self:stretch;">🎬 开始渲染</button>
                <div id="exportProgress" style="display:none;flex-direction:column;gap:8px;">
                    <div class="export-progress-bar"><div id="exportProgressFill"></div></div>
                    <div id="exportProgressText" style="text-align:center;color:var(--text-secondary);font-size:var(--font-xs);">准备中...</div>
                    <div style="display:flex;gap:8px;justify-content:center;">
                        <button class="btn" id="exportBgBtn" style="flex:1;">🔽 后台运行</button>
                        <button class="btn" id="exportCancelBtn" style="flex:1;">✖ 取消</button>
                    </div>
                </div>
            </div>
        </div>
    </div>

</body>
</html>
